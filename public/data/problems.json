[
  {
    "id": "1",
    "slug": "two-sum",
    "title": "Two Sum",
    "difficulty": "Easy",
    "description": "Given an array of integers `nums` and an integer `target`, return _indices of the two numbers such that they add up to `target`_. You may assume that each input would have **_exactly_ one solution**, and you may not use the _same_ element twice. You can return the answer in any order.",
    "examples": [
      {
        "input": "nums = \\[2,7,11,15\\], target = 9",
        "output": "\\[0,1\\]",
        "explanation": "Because nums\\[0\\] + nums\\[1\\] == 9, we return \\[0, 1\\]."
      },
      {
        "input": "nums = \\[3,2,4\\], target = 6",
        "output": "\\[1,2\\]"
      },
      {
        "input": "nums = \\[3,3\\], target = 6",
        "output": "\\[0,1\\]"
      }
    ],
    "constraints": [
      "`2 <= nums.length <= 104`",
      "`-109 <= nums[i] <= 109`",
      "`-109 <= target <= 109`",
      "Only one valid answer exists."
    ],
    "companies": [
      {
        "name": "Google",
        "slug": "google",
        "frequency": 237
      },
      {
        "name": "Amazon",
        "slug": "amazon",
        "frequency": 101
      },
      {
        "name": "Meta",
        "slug": "facebook",
        "frequency": 75
      },
      {
        "name": "Microsoft",
        "slug": "microsoft",
        "frequency": 57
      },
      {
        "name": "Bloomberg",
        "slug": "bloomberg",
        "frequency": 28
      },
      {
        "name": "tcs",
        "slug": "tcs",
        "frequency": 12
      },
      {
        "name": "Apple",
        "slug": "apple",
        "frequency": 9
      },
      {
        "name": "Visa",
        "slug": "visa",
        "frequency": 7
      },
      {
        "name": "Infosys",
        "slug": "infosys",
        "frequency": 7
      },
      {
        "name": "Accenture",
        "slug": "accenture",
        "frequency": 7
      },
      {
        "name": "Spotify",
        "slug": "spotify",
        "frequency": 5
      },
      {
        "name": "Oracle",
        "slug": "oracle",
        "frequency": 5
      },
      {
        "name": "Walmart Labs",
        "slug": "walmart-labs",
        "frequency": 5
      },
      {
        "name": "IBM",
        "slug": "ibm",
        "frequency": 5
      },
      {
        "name": "Goldman Sachs",
        "slug": "goldman-sachs",
        "frequency": 4
      },
      {
        "name": "EPAM Systems",
        "slug": "epam-systems",
        "frequency": 4
      },
      {
        "name": "SAP",
        "slug": "sap",
        "frequency": 4
      },
      {
        "name": "Salesforce",
        "slug": "salesforce",
        "frequency": 4
      },
      {
        "name": "Yandex",
        "slug": "yandex",
        "frequency": 3
      },
      {
        "name": "Zoho",
        "slug": "zoho",
        "frequency": 3
      },
      {
        "name": "Nvidia",
        "slug": "nvidia",
        "frequency": 3
      },
      {
        "name": "Intel",
        "slug": "intel",
        "frequency": 3
      },
      {
        "name": "TikTok",
        "slug": "tiktok",
        "frequency": 3
      },
      {
        "name": "Hubspot",
        "slug": "hubspot",
        "frequency": 3
      },
      {
        "name": "LinkedIn",
        "slug": "linkedin",
        "frequency": 2
      },
      {
        "name": "Wipro",
        "slug": "wipro",
        "frequency": 2
      },
      {
        "name": "Comcast",
        "slug": "comcast",
        "frequency": 2
      },
      {
        "name": "Western Digital",
        "slug": "western-digital",
        "frequency": 2
      },
      {
        "name": "DoorDash",
        "slug": "doordash",
        "frequency": 2
      },
      {
        "name": "Accolite",
        "slug": "accolite",
        "frequency": 2
      },
      {
        "name": "American Express",
        "slug": "american-express",
        "frequency": 2
      },
      {
        "name": "persistent systems",
        "slug": "persistent-systems",
        "frequency": 2
      },
      {
        "name": "Capgemini",
        "slug": "capgemini",
        "frequency": 2
      },
      {
        "name": "Snowflake",
        "slug": "snowflake",
        "frequency": 2
      },
      {
        "name": "Tekion",
        "slug": "tekion",
        "frequency": 2
      },
      {
        "name": "Pwc",
        "slug": "pwc",
        "frequency": 2
      },
      {
        "name": "Deloitte",
        "slug": "deloitte",
        "frequency": 2
      },
      {
        "name": "Adobe",
        "slug": "adobe",
        "frequency": 2
      },
      {
        "name": "Samsung",
        "slug": "samsung",
        "frequency": 2
      },
      {
        "name": "Yahoo",
        "slug": "yahoo",
        "frequency": 2
      },
      {
        "name": "Uber",
        "slug": "uber",
        "frequency": 2
      },
      {
        "name": "eBay",
        "slug": "ebay",
        "frequency": 2
      },
      {
        "name": "ServiceNow",
        "slug": "servicenow",
        "frequency": 2
      },
      {
        "name": "PayPal",
        "slug": "paypal",
        "frequency": 2
      },
      {
        "name": "Epic Systems",
        "slug": "epic-systems",
        "frequency": 2
      },
      {
        "name": "Karat",
        "slug": "karat",
        "frequency": 2
      },
      {
        "name": "HCL",
        "slug": "hcl",
        "frequency": 2
      },
      {
        "name": "Tinkoff",
        "slug": "tinkoff",
        "frequency": 2
      },
      {
        "name": "KLA",
        "slug": "kla",
        "frequency": 2
      }
    ]
  },
  {
    "id": "2",
    "slug": "add-two-numbers",
    "title": "Add Two Numbers",
    "difficulty": "Medium",
    "description": "You are given two **non-empty** linked lists representing two non-negative integers. The digits are stored in **reverse order**, and each of their nodes contains a single digit. Add the two numbers and return the sum as a linked list. You may assume the two numbers do not contain any leading zero, except the number 0 itself.",
    "examples": [
      {
        "input": "l1 = \\[2,4,3\\], l2 = \\[5,6,4\\]",
        "output": "\\[7,0,8\\]",
        "explanation": "342 + 465 = 807."
      },
      {
        "input": "l1 = \\[0\\], l2 = \\[0\\]",
        "output": "\\[0\\]"
      },
      {
        "input": "l1 = \\[9,9,9,9,9,9,9\\], l2 = \\[9,9,9,9\\]",
        "output": "\\[8,9,9,9,0,0,0,1\\]"
      }
    ],
    "constraints": [
      "The number of nodes in each linked list is in the range `[1, 100]`.",
      "`0 <= Node.val <= 9`",
      "It is guaranteed that the list represents a number that does not have leading zeros."
    ],
    "companies": [
      {
        "name": "Google",
        "slug": "google",
        "frequency": 58
      },
      {
        "name": "Amazon",
        "slug": "amazon",
        "frequency": 40
      },
      {
        "name": "Meta",
        "slug": "facebook",
        "frequency": 23
      },
      {
        "name": "Bloomberg",
        "slug": "bloomberg",
        "frequency": 16
      },
      {
        "name": "Microsoft",
        "slug": "microsoft",
        "frequency": 14
      },
      {
        "name": "Yandex",
        "slug": "yandex",
        "frequency": 3
      },
      {
        "name": "Goldman Sachs",
        "slug": "goldman-sachs",
        "frequency": 3
      },
      {
        "name": "Nvidia",
        "slug": "nvidia",
        "frequency": 2
      },
      {
        "name": "ByteDance",
        "slug": "bytedance",
        "frequency": 2
      },
      {
        "name": "Oracle",
        "slug": "oracle",
        "frequency": 2
      },
      {
        "name": "Apple",
        "slug": "apple",
        "frequency": 2
      },
      {
        "name": "Cisco",
        "slug": "cisco",
        "frequency": 2
      },
      {
        "name": "Accenture",
        "slug": "accenture",
        "frequency": 2
      },
      {
        "name": "Avito",
        "slug": "avito",
        "frequency": 2
      },
      {
        "name": "Zopsmart",
        "slug": "zopsmart",
        "frequency": 2
      }
    ]
  },
  {
    "id": "3",
    "slug": "longest-substring-without-repeating-characters",
    "title": "Longest Substring Without Repeating Characters",
    "difficulty": "Medium",
    "description": "Given a string `s`, find the length of the **longest** **substring** without repeating characters.",
    "examples": [
      {
        "input": "s =  \"abcabcbb \"",
        "output": "3",
        "explanation": "The answer is  \"abc \", with the length of 3."
      },
      {
        "input": "s =  \"bbbbb \"",
        "output": "1",
        "explanation": "The answer is  \"b \", with the length of 1."
      },
      {
        "input": "s =  \"pwwkew \"",
        "output": "3",
        "explanation": "The answer is  \"wke \", with the length of 3."
      }
    ],
    "constraints": [
      "`0 <= s.length <= 5  104`",
      "`s` consists of English letters, digits, symbols and spaces."
    ],
    "companies": [
      {
        "name": "Amazon",
        "slug": "amazon",
        "frequency": 53
      },
      {
        "name": "Google",
        "slug": "google",
        "frequency": 40
      },
      {
        "name": "Bloomberg",
        "slug": "bloomberg",
        "frequency": 21
      },
      {
        "name": "Microsoft",
        "slug": "microsoft",
        "frequency": 21
      },
      {
        "name": "Meta",
        "slug": "facebook",
        "frequency": 18
      },
      {
        "name": "Oracle",
        "slug": "oracle",
        "frequency": 11
      },
      {
        "name": "Walmart Labs",
        "slug": "walmart-labs",
        "frequency": 8
      },
      {
        "name": "Goldman Sachs",
        "slug": "goldman-sachs",
        "frequency": 7
      },
      {
        "name": "TikTok",
        "slug": "tiktok",
        "frequency": 7
      },
      {
        "name": "Yandex",
        "slug": "yandex",
        "frequency": 6
      },
      {
        "name": "Visa",
        "slug": "visa",
        "frequency": 6
      },
      {
        "name": "Apple",
        "slug": "apple",
        "frequency": 5
      },
      {
        "name": "Turing",
        "slug": "turing",
        "frequency": 4
      },
      {
        "name": "Cisco",
        "slug": "cisco",
        "frequency": 3
      },
      {
        "name": "Zoho",
        "slug": "zoho",
        "frequency": 3
      },
      {
        "name": "Infosys",
        "slug": "infosys",
        "frequency": 3
      },
      {
        "name": "HCL",
        "slug": "hcl",
        "frequency": 3
      },
      {
        "name": "Lyft",
        "slug": "lyft",
        "frequency": 3
      },
      {
        "name": "Salesforce",
        "slug": "salesforce",
        "frequency": 3
      },
      {
        "name": "ByteDance",
        "slug": "bytedance",
        "frequency": 3
      },
      {
        "name": "Accenture",
        "slug": "accenture",
        "frequency": 3
      },
      {
        "name": "Juspay",
        "slug": "juspay",
        "frequency": 3
      },
      {
        "name": "Netflix",
        "slug": "netflix",
        "frequency": 2
      },
      {
        "name": "Docusign",
        "slug": "docusign",
        "frequency": 2
      },
      {
        "name": "Coupang",
        "slug": "coupang",
        "frequency": 2
      },
      {
        "name": "J.P. Morgan",
        "slug": "jpmorgan",
        "frequency": 2
      },
      {
        "name": "Paytm",
        "slug": "paytm",
        "frequency": 2
      },
      {
        "name": "tcs",
        "slug": "tcs",
        "frequency": 2
      },
      {
        "name": "Nvidia",
        "slug": "nvidia",
        "frequency": 2
      },
      {
        "name": "IBM",
        "slug": "ibm",
        "frequency": 2
      },
      {
        "name": "persistent systems",
        "slug": "persistent-systems",
        "frequency": 2
      },
      {
        "name": "EPAM Systems",
        "slug": "epam-systems",
        "frequency": 2
      },
      {
        "name": "Palo Alto Networks",
        "slug": "palo-alto-networks",
        "frequency": 2
      },
      {
        "name": "Comcast",
        "slug": "comcast",
        "frequency": 2
      },
      {
        "name": "Freecharge",
        "slug": "freecharge",
        "frequency": 2
      },
      {
        "name": "PayPal",
        "slug": "paypal",
        "frequency": 2
      },
      {
        "name": "LinkedIn",
        "slug": "linkedin",
        "frequency": 2
      },
      {
        "name": "ServiceNow",
        "slug": "servicenow",
        "frequency": 2
      },
      {
        "name": "Roblox",
        "slug": "roblox",
        "frequency": 2
      },
      {
        "name": "Spotify",
        "slug": "spotify",
        "frequency": 2
      },
      {
        "name": "Morgan Stanley",
        "slug": "morgan-stanley",
        "frequency": 2
      },
      {
        "name": "American Express",
        "slug": "american-express",
        "frequency": 2
      },
      {
        "name": "Nagarro",
        "slug": "nagarro",
        "frequency": 2
      },
      {
        "name": "Capgemini",
        "slug": "capgemini",
        "frequency": 2
      },
      {
        "name": "Flipkart",
        "slug": "flipkart",
        "frequency": 2
      },
      {
        "name": "Agoda",
        "slug": "agoda",
        "frequency": 2
      },
      {
        "name": "AMD",
        "slug": "amd",
        "frequency": 2
      },
      {
        "name": "Dell",
        "slug": "dell",
        "frequency": 2
      }
    ]
  },
  {
    "id": "4",
    "slug": "median-of-two-sorted-arrays",
    "title": "Median of Two Sorted Arrays",
    "difficulty": "Hard",
    "description": "Given two sorted arrays `nums1` and `nums2` of size `m` and `n` respectively, return **the median** of the two sorted arrays. The overall run time complexity should be `O(log (m+n))`.",
    "examples": [
      {
        "input": "nums1 = \\[1,3\\], nums2 = \\[2\\]",
        "output": "2.00000",
        "explanation": "merged array = \\[1,2,3\\] and median is 2."
      },
      {
        "input": "nums1 = \\[1,2\\], nums2 = \\[3,4\\]",
        "output": "2.50000",
        "explanation": "merged array = \\[1,2,3,4\\] and median is (2 + 3) / 2 = 2.5."
      }
    ],
    "constraints": [
      "`nums1.length == m`",
      "`nums2.length == n`",
      "`0 <= m <= 1000`",
      "`0 <= n <= 1000`",
      "`1 <= m + n <= 2000`",
      "`-106 <= nums1[i], nums2[i] <= 106`"
    ],
    "companies": [
      {
        "name": "Google",
        "slug": "google",
        "frequency": 43
      },
      {
        "name": "Amazon",
        "slug": "amazon",
        "frequency": 27
      },
      {
        "name": "Goldman Sachs",
        "slug": "goldman-sachs",
        "frequency": 23
      },
      {
        "name": "Meta",
        "slug": "facebook",
        "frequency": 18
      },
      {
        "name": "Microsoft",
        "slug": "microsoft",
        "frequency": 11
      },
      {
        "name": "Bloomberg",
        "slug": "bloomberg",
        "frequency": 8
      },
      {
        "name": "Wix",
        "slug": "wix",
        "frequency": 6
      },
      {
        "name": "Adobe",
        "slug": "adobe",
        "frequency": 3
      },
      {
        "name": "Zoho",
        "slug": "zoho",
        "frequency": 3
      },
      {
        "name": "Walmart Labs",
        "slug": "walmart-labs",
        "frequency": 2
      },
      {
        "name": "Oracle",
        "slug": "oracle",
        "frequency": 2
      },
      {
        "name": "Rippling",
        "slug": "rippling",
        "frequency": 2
      },
      {
        "name": "Autodesk",
        "slug": "autodesk",
        "frequency": 2
      },
      {
        "name": "Cognizant",
        "slug": "cognizant",
        "frequency": 2
      },
      {
        "name": "Yandex",
        "slug": "yandex",
        "frequency": 2
      },
      {
        "name": "Palo Alto Networks",
        "slug": "palo-alto-networks",
        "frequency": 2
      },
      {
        "name": "Swiggy",
        "slug": "swiggy",
        "frequency": 2
      }
    ]
  },
  {
    "id": "5",
    "slug": "longest-palindromic-substring",
    "title": "Longest Palindromic Substring",
    "difficulty": "Medium",
    "description": "Given a string `s`, return _the longest_ _palindromic_ _substring_ in `s`.",
    "examples": [
      {
        "input": "s =  \"babad \"",
        "output": "\"bab \"",
        "explanation": "\"aba \" is also a valid answer."
      },
      {
        "input": "s =  \"cbbd \"",
        "output": "\"bb \""
      }
    ],
    "constraints": [
      "`1 <= s.length <= 1000`",
      "`s` consist of only digits and English letters."
    ],
    "companies": [
      {
        "name": "Google",
        "slug": "google",
        "frequency": 27
      },
      {
        "name": "Amazon",
        "slug": "amazon",
        "frequency": 24
      },
      {
        "name": "Meta",
        "slug": "facebook",
        "frequency": 19
      },
      {
        "name": "Cisco",
        "slug": "cisco",
        "frequency": 13
      },
      {
        "name": "Zoho",
        "slug": "zoho",
        "frequency": 8
      },
      {
        "name": "Microsoft",
        "slug": "microsoft",
        "frequency": 7
      },
      {
        "name": "Bloomberg",
        "slug": "bloomberg",
        "frequency": 6
      },
      {
        "name": "Oracle",
        "slug": "oracle",
        "frequency": 6
      },
      {
        "name": "Accenture",
        "slug": "accenture",
        "frequency": 4
      },
      {
        "name": "Walmart Labs",
        "slug": "walmart-labs",
        "frequency": 3
      },
      {
        "name": "TikTok",
        "slug": "tiktok",
        "frequency": 3
      },
      {
        "name": "EPAM Systems",
        "slug": "epam-systems",
        "frequency": 3
      },
      {
        "name": "Deloitte",
        "slug": "deloitte",
        "frequency": 3
      },
      {
        "name": "Pure Storage",
        "slug": "pure-storage",
        "frequency": 3
      },
      {
        "name": "Goldman Sachs",
        "slug": "goldman-sachs",
        "frequency": 3
      },
      {
        "name": "SAP",
        "slug": "sap",
        "frequency": 3
      },
      {
        "name": "tcs",
        "slug": "tcs",
        "frequency": 3
      },
      {
        "name": "Apple",
        "slug": "apple",
        "frequency": 2
      },
      {
        "name": "IBM",
        "slug": "ibm",
        "frequency": 2
      },
      {
        "name": "Salesforce",
        "slug": "salesforce",
        "frequency": 2
      },
      {
        "name": "Softwire",
        "slug": "softwire",
        "frequency": 2
      },
      {
        "name": "persistent systems",
        "slug": "persistent-systems",
        "frequency": 2
      },
      {
        "name": "Cognizant",
        "slug": "cognizant",
        "frequency": 2
      },
      {
        "name": "Visa",
        "slug": "visa",
        "frequency": 2
      },
      {
        "name": "Huawei",
        "slug": "huawei",
        "frequency": 2
      },
      {
        "name": "Yandex",
        "slug": "yandex",
        "frequency": 2
      },
      {
        "name": "Commvault",
        "slug": "commvault",
        "frequency": 2
      },
      {
        "name": "PhonePe",
        "slug": "phonepe",
        "frequency": 2
      },
      {
        "name": "Turing",
        "slug": "turing",
        "frequency": 2
      }
    ]
  },
  {
    "id": "11",
    "slug": "container-with-most-water",
    "title": "Container With Most Water",
    "difficulty": "Medium",
    "description": "You are given an integer array `height` of length `n`. There are `n` vertical lines drawn such that the two endpoints of the `ith` line are `(i, 0)` and `(i, height[i])`. Find two lines that together with the x-axis form a container, such that the container contains the most water. Return _the maximum amount of water a container can store_. **Notice** that you may not slant the container.",
    "examples": [
      {
        "input": "height = \\[1,8,6,2,5,4,8,3,7\\]",
        "output": "49",
        "explanation": "The above vertical lines are represented by array \\[1,8,6,2,5,4,8,3,7\\]. In this case, the max area of water (blue section) the container can contain is 49."
      },
      {
        "input": "height = \\[1,1\\]",
        "output": "1"
      }
    ],
    "constraints": [
      "`n == height.length`",
      "`2 <= n <= 105`",
      "`0 <= height[i] <= 104`"
    ],
    "companies": [
      {
        "name": "Google",
        "slug": "google",
        "frequency": 22
      },
      {
        "name": "Amazon",
        "slug": "amazon",
        "frequency": 16
      },
      {
        "name": "Microsoft",
        "slug": "microsoft",
        "frequency": 9
      },
      {
        "name": "Meta",
        "slug": "facebook",
        "frequency": 8
      },
      {
        "name": "Bloomberg",
        "slug": "bloomberg",
        "frequency": 6
      },
      {
        "name": "Oracle",
        "slug": "oracle",
        "frequency": 5
      },
      {
        "name": "SAP",
        "slug": "sap",
        "frequency": 5
      },
      {
        "name": "Goldman Sachs",
        "slug": "goldman-sachs",
        "frequency": 3
      },
      {
        "name": "ServiceNow",
        "slug": "servicenow",
        "frequency": 3
      },
      {
        "name": "Deloitte",
        "slug": "deloitte",
        "frequency": 3
      },
      {
        "name": "Zopsmart",
        "slug": "zopsmart",
        "frequency": 3
      },
      {
        "name": "TikTok",
        "slug": "tiktok",
        "frequency": 2
      },
      {
        "name": "Myntra",
        "slug": "myntra",
        "frequency": 2
      },
      {
        "name": "HashedIn",
        "slug": "hashedin",
        "frequency": 2
      },
      {
        "name": "Visa",
        "slug": "visa",
        "frequency": 2
      },
      {
        "name": "Accenture",
        "slug": "accenture",
        "frequency": 2
      },
      {
        "name": "Snowflake",
        "slug": "snowflake",
        "frequency": 2
      },
      {
        "name": "Mastercard",
        "slug": "mastercard",
        "frequency": 2
      }
    ]
  },
  {
    "id": "15",
    "slug": "3sum",
    "title": "3Sum",
    "difficulty": "Medium",
    "description": "Given an integer array nums, return all the triplets `[nums[i], nums[j], nums[k]]` such that `i != j`, `i != k`, and `j != k`, and `nums[i] + nums[j] + nums[k] == 0`. Notice that the solution set must not contain duplicate triplets.",
    "examples": [
      {
        "input": "nums = \\[-1,0,1,2,-1,-4\\]",
        "output": "\\[\\[-1,-1,2\\],\\[-1,0,1\\]\\]",
        "explanation": ""
      },
      {
        "input": "nums = \\[0,1,1\\]",
        "output": "\\[\\]",
        "explanation": "The only possible triplet does not sum up to 0."
      },
      {
        "input": "nums = \\[0,0,0\\]",
        "output": "\\[\\[0,0,0\\]\\]",
        "explanation": "The only possible triplet sums up to 0."
      }
    ],
    "constraints": ["`3 <= nums.length <= 3000`", "`-105 <= nums[i] <= 105`"],
    "companies": [
      {
        "name": "Google",
        "slug": "google",
        "frequency": 34
      },
      {
        "name": "Amazon",
        "slug": "amazon",
        "frequency": 28
      },
      {
        "name": "Meta",
        "slug": "facebook",
        "frequency": 18
      },
      {
        "name": "Microsoft",
        "slug": "microsoft",
        "frequency": 15
      },
      {
        "name": "Visa",
        "slug": "visa",
        "frequency": 9
      },
      {
        "name": "Bloomberg",
        "slug": "bloomberg",
        "frequency": 8
      },
      {
        "name": "TikTok",
        "slug": "tiktok",
        "frequency": 4
      },
      {
        "name": "Cloudflare",
        "slug": "cloudflare",
        "frequency": 4
      },
      {
        "name": "tcs",
        "slug": "tcs",
        "frequency": 3
      },
      {
        "name": "Agoda",
        "slug": "agoda",
        "frequency": 3
      },
      {
        "name": "Apple",
        "slug": "apple",
        "frequency": 2
      },
      {
        "name": "Walmart Labs",
        "slug": "walmart-labs",
        "frequency": 2
      },
      {
        "name": "Oracle",
        "slug": "oracle",
        "frequency": 2
      },
      {
        "name": "Zoho",
        "slug": "zoho",
        "frequency": 2
      },
      {
        "name": "IBM",
        "slug": "ibm",
        "frequency": 2
      },
      {
        "name": "Vimeo",
        "slug": "vimeo",
        "frequency": 2
      },
      {
        "name": "Goldman Sachs",
        "slug": "goldman-sachs",
        "frequency": 2
      },
      {
        "name": "Adobe",
        "slug": "adobe",
        "frequency": 2
      },
      {
        "name": "Morgan Stanley",
        "slug": "morgan-stanley",
        "frequency": 2
      },
      {
        "name": "Tesla",
        "slug": "tesla",
        "frequency": 2
      },
      {
        "name": "American Express",
        "slug": "american-express",
        "frequency": 2
      },
      {
        "name": "Accenture",
        "slug": "accenture",
        "frequency": 2
      },
      {
        "name": "HCL",
        "slug": "hcl",
        "frequency": 2
      },
      {
        "name": "BNY Mellon",
        "slug": "bny-mellon",
        "frequency": 2
      },
      {
        "name": "Turing",
        "slug": "turing",
        "frequency": 2
      }
    ]
  },
  {
    "id": "16",
    "slug": "3sum-closest",
    "title": "3Sum Closest",
    "difficulty": "Medium",
    "description": "Given an integer array `nums` of length `n` and an integer `target`, find three integers in `nums` such that the sum is closest to `target`. Return _the sum of the three integers_. You may assume that each input would have exactly one solution.",
    "examples": [
      {
        "input": "nums = \\[-1,2,1,-4\\], target = 1",
        "output": "2",
        "explanation": "The sum that is closest to the target is 2. (-1 + 2 + 1 = 2)."
      },
      {
        "input": "nums = \\[0,0,0\\], target = 1",
        "output": "0",
        "explanation": "The sum that is closest to the target is 0. (0 + 0 + 0 = 0)."
      }
    ],
    "constraints": [
      "`3 <= nums.length <= 500`",
      "`-1000 <= nums[i] <= 1000`",
      "`-104 <= target <= 104`"
    ],
    "companies": [
      {
        "name": "Google",
        "slug": "google",
        "frequency": 7
      },
      {
        "name": "Microsoft",
        "slug": "microsoft",
        "frequency": 6
      },
      {
        "name": "Meta",
        "slug": "facebook",
        "frequency": 5
      },
      {
        "name": "Amazon",
        "slug": "amazon",
        "frequency": 3
      },
      {
        "name": "Zoho",
        "slug": "zoho",
        "frequency": 3
      },
      {
        "name": "Flipkart",
        "slug": "flipkart",
        "frequency": 2
      },
      {
        "name": "Bloomberg",
        "slug": "bloomberg",
        "frequency": 2
      }
    ]
  },
  {
    "id": "17",
    "slug": "letter-combinations-of-a-phone-number",
    "title": "Letter Combinations of a Phone Number",
    "difficulty": "Medium",
    "description": "Given a string containing digits from `2-9` inclusive, return all possible letter combinations that the number could represent. Return the answer in **any order**. A mapping of digits to letters (just like on the telephone buttons) is given below. Note that 1 does not map to any letters.",
    "examples": [
      {
        "input": "digits =  \"23 \"",
        "output": "\\[ \"ad \", \"ae \", \"af \", \"bd \", \"be \", \"bf \", \"cd \", \"ce \", \"cf \"\\]"
      },
      {
        "input": "digits =  \" \"",
        "output": "\\[\\]"
      },
      {
        "input": "digits =  \"2 \"",
        "output": "\\[ \"a \", \"b \", \"c \"\\]"
      }
    ],
    "constraints": [
      "`0 <= digits.length <= 4`",
      "`digits[i]` is a digit in the range `['2', '9']`."
    ],
    "companies": [
      {
        "name": "Google",
        "slug": "google",
        "frequency": 19
      },
      {
        "name": "Amazon",
        "slug": "amazon",
        "frequency": 14
      },
      {
        "name": "Meta",
        "slug": "facebook",
        "frequency": 10
      },
      {
        "name": "LinkedIn",
        "slug": "linkedin",
        "frequency": 9
      },
      {
        "name": "Microsoft",
        "slug": "microsoft",
        "frequency": 8
      },
      {
        "name": "DE Shaw",
        "slug": "de-shaw",
        "frequency": 4
      },
      {
        "name": "IBM",
        "slug": "ibm",
        "frequency": 4
      },
      {
        "name": "Accenture",
        "slug": "accenture",
        "frequency": 4
      },
      {
        "name": "Apple",
        "slug": "apple",
        "frequency": 3
      },
      {
        "name": "Epic Systems",
        "slug": "epic-systems",
        "frequency": 3
      },
      {
        "name": "Uber",
        "slug": "uber",
        "frequency": 3
      },
      {
        "name": "Yandex",
        "slug": "yandex",
        "frequency": 3
      },
      {
        "name": "Bloomberg",
        "slug": "bloomberg",
        "frequency": 2
      },
      {
        "name": "Citadel",
        "slug": "citadel",
        "frequency": 2
      },
      {
        "name": "Flexport",
        "slug": "flexport",
        "frequency": 2
      }
    ]
  },
  {
    "id": "19",
    "slug": "remove-nth-node-from-end-of-list",
    "title": "Remove Nth Node From End of List",
    "difficulty": "Medium",
    "description": "Given the `head` of a linked list, remove the `nth` node from the end of the list and return its head.",
    "examples": [
      {
        "input": "head = \\[1,2,3,4,5\\], n = 2",
        "output": "\\[1,2,3,5\\]"
      },
      {
        "input": "head = \\[1\\], n = 1",
        "output": "\\[\\]"
      },
      {
        "input": "head = \\[1,2\\], n = 1",
        "output": "\\[1\\]"
      }
    ],
    "constraints": [
      "The number of nodes in the list is `sz`.",
      "`1 <= sz <= 30`",
      "`0 <= Node.val <= 100`",
      "`1 <= n <= sz`",
      "Follow up: Could you do this in one pass?"
    ],
    "companies": [
      {
        "name": "Meta",
        "slug": "facebook",
        "frequency": 45
      },
      {
        "name": "Google",
        "slug": "google",
        "frequency": 13
      },
      {
        "name": "Amazon",
        "slug": "amazon",
        "frequency": 9
      },
      {
        "name": "Apple",
        "slug": "apple",
        "frequency": 4
      },
      {
        "name": "Bloomberg",
        "slug": "bloomberg",
        "frequency": 3
      },
      {
        "name": "tcs",
        "slug": "tcs",
        "frequency": 3
      },
      {
        "name": "Microsoft",
        "slug": "microsoft",
        "frequency": 2
      },
      {
        "name": "Yandex",
        "slug": "yandex",
        "frequency": 2
      },
      {
        "name": "Accenture",
        "slug": "accenture",
        "frequency": 2
      },
      {
        "name": "TikTok",
        "slug": "tiktok",
        "frequency": 2
      }
    ]
  },
  {
    "id": "21",
    "slug": "merge-two-sorted-lists",
    "title": "Merge Two Sorted Lists",
    "difficulty": "Easy",
    "description": "You are given the heads of two sorted linked lists `list1` and `list2`. Merge the two lists in a one **sorted** list. The list should be made by splicing together the nodes of the first two lists. Return _the head of the merged linked list_.",
    "examples": [
      {
        "input": "list1 = \\[1,2,4\\], list2 = \\[1,3,4\\]",
        "output": "\\[1,1,2,3,4,4\\]"
      },
      {
        "input": "list1 = \\[\\], list2 = \\[\\]",
        "output": "\\[\\]"
      },
      {
        "input": "list1 = \\[\\], list2 = \\[0\\]",
        "output": "\\[0\\]"
      }
    ],
    "constraints": [
      "The number of nodes in both lists is in the range `[0, 50]`.",
      "`-100 <= Node.val <= 100`",
      "Both `list1` and `list2` are sorted in non-decreasing order."
    ],
    "companies": [
      {
        "name": "Google",
        "slug": "google",
        "frequency": 28
      },
      {
        "name": "Amazon",
        "slug": "amazon",
        "frequency": 19
      },
      {
        "name": "Meta",
        "slug": "facebook",
        "frequency": 13
      },
      {
        "name": "Microsoft",
        "slug": "microsoft",
        "frequency": 8
      },
      {
        "name": "Bloomberg",
        "slug": "bloomberg",
        "frequency": 7
      },
      {
        "name": "Apple",
        "slug": "apple",
        "frequency": 2
      },
      {
        "name": "Hubspot",
        "slug": "hubspot",
        "frequency": 2
      },
      {
        "name": "Zoho",
        "slug": "zoho",
        "frequency": 2
      },
      {
        "name": "Snowflake",
        "slug": "snowflake",
        "frequency": 2
      },
      {
        "name": "Palo Alto Networks",
        "slug": "palo-alto-networks",
        "frequency": 2
      },
      {
        "name": "LinkedIn",
        "slug": "linkedin",
        "frequency": 2
      },
      {
        "name": "Goldman Sachs",
        "slug": "goldman-sachs",
        "frequency": 2
      },
      {
        "name": "Huawei",
        "slug": "huawei",
        "frequency": 2
      },
      {
        "name": "Yandex",
        "slug": "yandex",
        "frequency": 2
      },
      {
        "name": "tcs",
        "slug": "tcs",
        "frequency": 2
      },
      {
        "name": "TikTok",
        "slug": "tiktok",
        "frequency": 2
      },
      {
        "name": "HPE",
        "slug": "hpe",
        "frequency": 2
      }
    ]
  },
  {
    "id": "22",
    "slug": "generate-parentheses",
    "title": "Generate Parentheses",
    "difficulty": "Medium",
    "description": "Given `n` pairs of parentheses, write a function to _generate all combinations of well-formed parentheses_.",
    "examples": [
      {
        "input": "n = 3",
        "output": "\\[\"((()))\",\"(()())\",\"(())()\",\"()(())\",\"()()()\"\\]"
      },
      {
        "input": "n = 1",
        "output": "\\[\"()\"\\]"
      }
    ],
    "constraints": ["`1 <= n <= 8`"],
    "companies": [
      {
        "name": "Google",
        "slug": "google",
        "frequency": 25
      },
      {
        "name": "Amazon",
        "slug": "amazon",
        "frequency": 22
      },
      {
        "name": "Meta",
        "slug": "facebook",
        "frequency": 13
      },
      {
        "name": "Bloomberg",
        "slug": "bloomberg",
        "frequency": 7
      },
      {
        "name": "Walmart Labs",
        "slug": "walmart-labs",
        "frequency": 6
      },
      {
        "name": "Microsoft",
        "slug": "microsoft",
        "frequency": 5
      },
      {
        "name": "Grammarly",
        "slug": "grammarly",
        "frequency": 4
      },
      {
        "name": "Yandex",
        "slug": "yandex",
        "frequency": 4
      },
      {
        "name": "Apple",
        "slug": "apple",
        "frequency": 3
      },
      {
        "name": "Goldman Sachs",
        "slug": "goldman-sachs",
        "frequency": 3
      },
      {
        "name": "Huawei",
        "slug": "huawei",
        "frequency": 3
      },
      {
        "name": "Zoho",
        "slug": "zoho",
        "frequency": 3
      },
      {
        "name": "Texas Instruments",
        "slug": "texas-instruments",
        "frequency": 3
      },
      {
        "name": "Infosys",
        "slug": "infosys",
        "frequency": 2
      },
      {
        "name": "TikTok",
        "slug": "tiktok",
        "frequency": 2
      },
      {
        "name": "Adobe",
        "slug": "adobe",
        "frequency": 2
      },
      {
        "name": "ServiceNow",
        "slug": "servicenow",
        "frequency": 2
      },
      {
        "name": "Oracle",
        "slug": "oracle",
        "frequency": 2
      },
      {
        "name": "tcs",
        "slug": "tcs",
        "frequency": 2
      },
      {
        "name": "Accenture",
        "slug": "accenture",
        "frequency": 2
      },
      {
        "name": "Disney",
        "slug": "disney",
        "frequency": 2
      }
    ]
  },
  {
    "id": "23",
    "slug": "merge-k-sorted-lists",
    "title": "Merge k Sorted Lists",
    "difficulty": "Hard",
    "description": "You are given an array of `k` linked-lists `lists`, each linked-list is sorted in ascending order. _Merge all the linked-lists into one sorted linked-list and return it._",
    "examples": [
      {
        "input": "lists = \\[\\[1,4,5\\],\\[1,3,4\\],\\[2,6\\]\\]",
        "output": "\\[1,1,2,3,4,4,5,6\\]",
        "explanation": "The linked-lists are:"
      },
      {
        "input": "lists = \\[\\]",
        "output": "\\[\\]"
      },
      {
        "input": "lists = \\[\\[\\]\\]",
        "output": "\\[\\]"
      }
    ],
    "constraints": [
      "`k == lists.length`",
      "`0 <= k <= 104`",
      "`0 <= lists[i].length <= 500`",
      "`-104 <= lists[i][j] <= 104`",
      "`lists[i]` is sorted in ascending order.",
      "The sum of `lists[i].length` will not exceed `104`."
    ],
    "companies": [
      {
        "name": "Meta",
        "slug": "facebook",
        "frequency": 76
      },
      {
        "name": "Amazon",
        "slug": "amazon",
        "frequency": 46
      },
      {
        "name": "Google",
        "slug": "google",
        "frequency": 11
      },
      {
        "name": "Microsoft",
        "slug": "microsoft",
        "frequency": 8
      },
      {
        "name": "TikTok",
        "slug": "tiktok",
        "frequency": 7
      },
      {
        "name": "Oracle",
        "slug": "oracle",
        "frequency": 6
      },
      {
        "name": "Warnermedia",
        "slug": "warnermedia",
        "frequency": 4
      },
      {
        "name": "Bloomberg",
        "slug": "bloomberg",
        "frequency": 3
      },
      {
        "name": "Yandex",
        "slug": "yandex",
        "frequency": 3
      },
      {
        "name": "Citadel",
        "slug": "citadel",
        "frequency": 3
      },
      {
        "name": "Apple",
        "slug": "apple",
        "frequency": 2
      },
      {
        "name": "Salesforce",
        "slug": "salesforce",
        "frequency": 2
      },
      {
        "name": "Nvidia",
        "slug": "nvidia",
        "frequency": 2
      },
      {
        "name": "Snowflake",
        "slug": "snowflake",
        "frequency": 2
      },
      {
        "name": "Anduril",
        "slug": "anduril",
        "frequency": 2
      },
      {
        "name": "Uber",
        "slug": "uber",
        "frequency": 2
      },
      {
        "name": "LinkedIn",
        "slug": "linkedin",
        "frequency": 2
      },
      {
        "name": "Cisco",
        "slug": "cisco",
        "frequency": 2
      },
      {
        "name": "Two Sigma",
        "slug": "two-sigma",
        "frequency": 2
      },
      {
        "name": "Nutanix",
        "slug": "nutanix",
        "frequency": 2
      },
      {
        "name": "Walmart Labs",
        "slug": "walmart-labs",
        "frequency": 2
      },
      {
        "name": "Goldman Sachs",
        "slug": "goldman-sachs",
        "frequency": 2
      },
      {
        "name": "Samsung",
        "slug": "samsung",
        "frequency": 2
      },
      {
        "name": "MongoDB",
        "slug": "mongodb",
        "frequency": 2
      },
      {
        "name": "DoorDash",
        "slug": "doordash",
        "frequency": 2
      }
    ]
  },
  {
    "id": "24",
    "slug": "swap-nodes-in-pairs",
    "title": "Swap Nodes in Pairs",
    "difficulty": "Medium",
    "description": "Given a linked list, swap every two adjacent nodes and return its head. You must solve the problem without modifying the values in the list's nodes (i.e., only nodes themselves may be changed.)",
    "examples": [
      {
        "input": "head = \\[1,2,3,4\\]",
        "output": "\\[2,1,4,3\\]"
      },
      {
        "input": "head = \\[\\]",
        "output": "\\[\\]"
      },
      {
        "input": "head = \\[1\\]",
        "output": "\\[1\\]"
      }
    ],
    "constraints": [
      "The number of nodes in the list is in the range `[0, 100]`.",
      "`0 <= Node.val <= 100`"
    ],
    "companies": [
      {
        "name": "Google",
        "slug": "google",
        "frequency": 9
      },
      {
        "name": "Microsoft",
        "slug": "microsoft",
        "frequency": 4
      },
      {
        "name": "Meta",
        "slug": "facebook",
        "frequency": 4
      },
      {
        "name": "Amazon",
        "slug": "amazon",
        "frequency": 3
      },
      {
        "name": "Bloomberg",
        "slug": "bloomberg",
        "frequency": 2
      },
      {
        "name": "PayPal",
        "slug": "paypal",
        "frequency": 2
      },
      {
        "name": "Yandex",
        "slug": "yandex",
        "frequency": 2
      }
    ]
  },
  {
    "id": "25",
    "slug": "reverse-nodes-in-k-group",
    "title": "Reverse Nodes in k-Group",
    "difficulty": "Hard",
    "description": "Given the `head` of a linked list, reverse the nodes of the list `k` at a time, and return _the modified list_. `k` is a positive integer and is less than or equal to the length of the linked list. If the number of nodes is not a multiple of `k` then left-out nodes, in the end, should remain as it is. You may not alter the values in the list's nodes, only nodes themselves may be changed.",
    "examples": [
      {
        "input": "head = \\[1,2,3,4,5\\], k = 2",
        "output": "\\[2,1,4,3,5\\]"
      },
      {
        "input": "head = \\[1,2,3,4,5\\], k = 3",
        "output": "\\[3,2,1,4,5\\]"
      }
    ],
    "constraints": [
      "The number of nodes in the list is `n`.",
      "`1 <= k <= n <= 5000`",
      "`0 <= Node.val <= 1000`"
    ],
    "companies": [
      {
        "name": "Amazon",
        "slug": "amazon",
        "frequency": 10
      },
      {
        "name": "Google",
        "slug": "google",
        "frequency": 10
      },
      {
        "name": "Bloomberg",
        "slug": "bloomberg",
        "frequency": 6
      },
      {
        "name": "Arista Networks",
        "slug": "arista-networks",
        "frequency": 6
      },
      {
        "name": "Meta",
        "slug": "facebook",
        "frequency": 3
      },
      {
        "name": "Microsoft",
        "slug": "microsoft",
        "frequency": 2
      },
      {
        "name": "Salesforce",
        "slug": "salesforce",
        "frequency": 2
      },
      {
        "name": "Tesla",
        "slug": "tesla",
        "frequency": 2
      },
      {
        "name": "TikTok",
        "slug": "tiktok",
        "frequency": 2
      },
      {
        "name": "Visa",
        "slug": "visa",
        "frequency": 2
      }
    ]
  },
  {
    "id": "30",
    "slug": "substring-with-concatenation-of-all-words",
    "title": "Substring with Concatenation of All Words",
    "difficulty": "Hard",
    "description": "You are given a string `s` and an array of strings `words`. All the strings of `words` are of **the same length**. A **concatenated substring** in `s` is a substring that contains all the strings of any permutation of `words` concatenated. *  For example, if `words = [ \"ab \", \"cd \", \"ef \"]`, then `\"abcdef \"`, `\"abefcd \"`, `\"cdabef \"`, `\"cdefab \"`, `\"efabcd \"`, and `\"efcdab \"` are all concatenated strings. `\"acdbef \"` is not a concatenated substring because it is not the concatenation of any permutation of `words`. Return _the starting indices of all the concatenated substrings in_ `s`. You can return the answer in **any order**.",
    "examples": [
      {
        "input": "s =  \"barfoothefoobarman \", words = \\[ \"foo \", \"bar \"\\]",
        "output": "\\[0,9\\]",
        "explanation": "Since words.length == 2 and words\\[i\\].length == 3, the concatenated substring has to be of length 6."
      },
      {
        "input": "s =  \"wordgoodgoodgoodbestword \", words = \\[ \"word \", \"good \", \"best \", \"word \"\\]",
        "output": "\\[\\]",
        "explanation": "Since words.length == 4 and words\\[i\\].length == 4, the concatenated substring has to be of length 16."
      },
      {
        "input": "s =  \"barfoofoobarthefoobarman \", words = \\[ \"bar \", \"foo \", \"the \"\\]",
        "output": "\\[6,9,12\\]",
        "explanation": "Since words.length == 3 and words\\[i\\].length == 3, the concatenated substring has to be of length 9."
      }
    ],
    "constraints": [
      "`1 <= s.length <= 104`",
      "`1 <= words.length <= 5000`",
      "`1 <= words[i].length <= 30`",
      "`s` and `words[i]` consist of lowercase English letters."
    ],
    "companies": [
      {
        "name": "Google",
        "slug": "google",
        "frequency": 4
      },
      {
        "name": "Amazon",
        "slug": "amazon",
        "frequency": 3
      },
      {
        "name": "Meta",
        "slug": "facebook",
        "frequency": 2
      },
      {
        "name": "Bloomberg",
        "slug": "bloomberg",
        "frequency": 2
      },
      {
        "name": "Microsoft",
        "slug": "microsoft",
        "frequency": 2
      }
    ]
  },
  {
    "id": "33",
    "slug": "search-in-rotated-sorted-array",
    "title": "Search in Rotated Sorted Array",
    "difficulty": "Medium",
    "description": "There is an integer array `nums` sorted in ascending order (with **distinct** values). Prior to being passed to your function, `nums` is **possibly rotated** at an unknown pivot index `k` (`1 <= k < nums.length`) such that the resulting array is `[nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]]` (**0-indexed**). For example, `[0,1,2,4,5,6,7]` might be rotated at pivot index `3` and become `[4,5,6,7,0,1,2]`. Given the array `nums` **after** the possible rotation and an integer `target`, return _the index of_ `target` _if it is in_ `nums`_, or_ `-1` _if it is not in_ `nums`. You must write an algorithm with `O(log n)` runtime complexity.",
    "examples": [
      {
        "input": "nums = \\[4,5,6,7,0,1,2\\], target = 0",
        "output": "4"
      },
      {
        "input": "nums = \\[4,5,6,7,0,1,2\\], target = 3",
        "output": "-1"
      },
      {
        "input": "nums = \\[1\\], target = 0",
        "output": "-1"
      }
    ],
    "constraints": [
      "`1 <= nums.length <= 5000`",
      "`-104 <= nums[i] <= 104`",
      "All values of `nums` are unique.",
      "`nums` is an ascending array that is possibly rotated.",
      "`-104 <= target <= 104`"
    ],
    "companies": [
      {
        "name": "Amazon",
        "slug": "amazon",
        "frequency": 25
      },
      {
        "name": "Meta",
        "slug": "facebook",
        "frequency": 11
      },
      {
        "name": "Google",
        "slug": "google",
        "frequency": 10
      },
      {
        "name": "LinkedIn",
        "slug": "linkedin",
        "frequency": 9
      },
      {
        "name": "Bloomberg",
        "slug": "bloomberg",
        "frequency": 8
      },
      {
        "name": "Microsoft",
        "slug": "microsoft",
        "frequency": 7
      },
      {
        "name": "TikTok",
        "slug": "tiktok",
        "frequency": 7
      },
      {
        "name": "Goldman Sachs",
        "slug": "goldman-sachs",
        "frequency": 6
      },
      {
        "name": "Walmart Labs",
        "slug": "walmart-labs",
        "frequency": 4
      },
      {
        "name": "Oracle",
        "slug": "oracle",
        "frequency": 4
      },
      {
        "name": "Arista Networks",
        "slug": "arista-networks",
        "frequency": 3
      },
      {
        "name": "Yandex",
        "slug": "yandex",
        "frequency": 3
      },
      {
        "name": "Grammarly",
        "slug": "grammarly",
        "frequency": 3
      },
      {
        "name": "Flipkart",
        "slug": "flipkart",
        "frequency": 3
      },
      {
        "name": "Apple",
        "slug": "apple",
        "frequency": 2
      },
      {
        "name": "Snap",
        "slug": "snapchat",
        "frequency": 2
      },
      {
        "name": "Palo Alto Networks",
        "slug": "palo-alto-networks",
        "frequency": 2
      },
      {
        "name": "Yahoo",
        "slug": "yahoo",
        "frequency": 2
      },
      {
        "name": "Samsung",
        "slug": "samsung",
        "frequency": 2
      },
      {
        "name": "Salesforce",
        "slug": "salesforce",
        "frequency": 2
      },
      {
        "name": "Nutanix",
        "slug": "nutanix",
        "frequency": 2
      },
      {
        "name": "ByteDance",
        "slug": "bytedance",
        "frequency": 2
      },
      {
        "name": "Infosys",
        "slug": "infosys",
        "frequency": 2
      },
      {
        "name": "Zoho",
        "slug": "zoho",
        "frequency": 2
      },
      {
        "name": "ZScaler",
        "slug": "zscaler",
        "frequency": 2
      },
      {
        "name": "Autodesk",
        "slug": "autodesk",
        "frequency": 2
      }
    ]
  },
  {
    "id": "37",
    "slug": "sudoku-solver",
    "title": "Sudoku Solver",
    "difficulty": "Hard",
    "description": "Write a program to solve a Sudoku puzzle by filling the empty cells. A sudoku solution must satisfy **all of the following rules**: 1. Each of the digits `1-9` must occur exactly once in each row. 2. Each of the digits `1-9` must occur exactly once in each column. 3. Each of the digits `1-9` must occur exactly once in each of the 9 `3x3` sub-boxes of the grid. The `'.'` character indicates empty cells.",
    "examples": [
      {
        "input": "board = \\[\\[ \"5 \", \"3 \", \". \", \". \", \"7 \", \". \", \". \", \". \", \". \"\\],\\[ \"6 \", \". \", \". \", \"1 \", \"9 \", \"5 \", \". \", \". \", \". \"\\],\\[ \". \", \"9 \", \"8 \", \". \", \". \", \". \", \". \", \"6 \", \". \"\\],\\[ \"8 \", \". \", \". \", \". \", \"6 \", \". \", \". \", \". \", \"3 \"\\],\\[ \"4 \", \". \", \". \", \"8 \", \". \", \"3 \", \". \", \". \", \"1 \"\\],\\[ \"7 \", \". \", \". \", \". \", \"2 \", \". \", \". \", \". \", \"6 \"\\],\\[ \". \", \"6 \", \". \", \". \", \". \", \". \", \"2 \", \"8 \", \". \"\\],\\[ \". \", \". \", \". \", \"4 \", \"1 \", \"9 \", \". \", \". \", \"5 \"\\],\\[ \". \", \". \", \". \", \". \", \"8 \", \". \", \". \", \"7 \", \"9 \"\\]\\]",
        "output": "\\[\\[ \"5 \", \"3 \", \"4 \", \"6 \", \"7 \", \"8 \", \"9 \", \"1 \", \"2 \"\\],\\[ \"6 \", \"7 \", \"2 \", \"1 \", \"9 \", \"5 \", \"3 \", \"4 \", \"8 \"\\],\\[ \"1 \", \"9 \", \"8 \", \"3 \", \"4 \", \"2 \", \"5 \", \"6 \", \"7 \"\\],\\[ \"8 \", \"5 \", \"9 \", \"7 \", \"6 \", \"1 \", \"4 \", \"2 \", \"3 \"\\],\\[ \"4 \", \"2 \", \"6 \", \"8 \", \"5 \", \"3 \", \"7 \", \"9 \", \"1 \"\\],\\[ \"7 \", \"1 \", \"3 \", \"9 \", \"2 \", \"4 \", \"8 \", \"5 \", \"6 \"\\],\\[ \"9 \", \"6 \", \"1 \", \"5 \", \"3 \", \"7 \", \"2 \", \"8 \", \"4 \"\\],\\[ \"2 \", \"8 \", \"7 \", \"4 \", \"1 \", \"9 \", \"6 \", \"3 \", \"5 \"\\],\\[ \"3 \", \"4 \", \"5 \", \"2 \", \"8 \", \"6 \", \"1 \", \"7 \", \"9 \"\\]\\]",
        "explanation": "The input board is shown above and the only valid solution is shown below:"
      }
    ],
    "constraints": [
      "`board.length == 9`",
      "`board[i].length == 9`",
      "`board[i][j]` is a digit or `'.'`.",
      "It is guaranteed that the input board has only one solution."
    ],
    "companies": [
      {
        "name": "Google",
        "slug": "google",
        "frequency": 8
      },
      {
        "name": "Amazon",
        "slug": "amazon",
        "frequency": 5
      },
      {
        "name": "Meta",
        "slug": "facebook",
        "frequency": 4
      },
      {
        "name": "Bloomberg",
        "slug": "bloomberg",
        "frequency": 3
      },
      {
        "name": "Confluent",
        "slug": "confluent",
        "frequency": 3
      },
      {
        "name": "Intuit",
        "slug": "intuit",
        "frequency": 3
      },
      {
        "name": "Microsoft",
        "slug": "microsoft",
        "frequency": 2
      },
      {
        "name": "Goldman Sachs",
        "slug": "goldman-sachs",
        "frequency": 2
      },
      {
        "name": "Zoho",
        "slug": "zoho",
        "frequency": 2
      }
    ]
  },
  {
    "id": "39",
    "slug": "combination-sum",
    "title": "Combination Sum",
    "difficulty": "Medium",
    "description": "Given an array of **distinct** integers `candidates` and a target integer `target`, return _a list of all **unique combinations** of_ `candidates` _where the chosen numbers sum to_ `target`_._ You may return the combinations in **any order**. The **same** number may be chosen from `candidates` an **unlimited number of times**. Two combinations are unique if the frequency of at least one of the chosen numbers is different. The test cases are generated such that the number of unique combinations that sum up to `target` is less than `150` combinations for the given input.",
    "examples": [
      {
        "input": "candidates = \\[2,3,6,7\\], target = 7",
        "output": "\\[\\[2,2,3\\],\\[7\\]\\]",
        "explanation": ""
      },
      {
        "input": "candidates = \\[2,3,5\\], target = 8",
        "output": "\\[\\[2,2,2,2\\],\\[2,3,3\\],\\[3,5\\]\\]"
      },
      {
        "input": "candidates = \\[2\\], target = 1",
        "output": "\\[\\]"
      }
    ],
    "constraints": [
      "`1 <= candidates.length <= 30`",
      "`2 <= candidates[i] <= 40`",
      "All elements of `candidates` are distinct.",
      "`1 <= target <= 40`"
    ],
    "companies": [
      {
        "name": "Google",
        "slug": "google",
        "frequency": 13
      },
      {
        "name": "Amazon",
        "slug": "amazon",
        "frequency": 11
      },
      {
        "name": "Microsoft",
        "slug": "microsoft",
        "frequency": 6
      },
      {
        "name": "Meta",
        "slug": "facebook",
        "frequency": 5
      },
      {
        "name": "Walmart Labs",
        "slug": "walmart-labs",
        "frequency": 4
      },
      {
        "name": "Airbnb",
        "slug": "airbnb",
        "frequency": 3
      },
      {
        "name": "Yahoo",
        "slug": "yahoo",
        "frequency": 3
      },
      {
        "name": "Bloomberg",
        "slug": "bloomberg",
        "frequency": 3
      },
      {
        "name": "LinkedIn",
        "slug": "linkedin",
        "frequency": 3
      },
      {
        "name": "ByteDance",
        "slug": "bytedance",
        "frequency": 2
      },
      {
        "name": "TikTok",
        "slug": "tiktok",
        "frequency": 2
      },
      {
        "name": "Confluent",
        "slug": "confluent",
        "frequency": 2
      },
      {
        "name": "Citadel",
        "slug": "citadel",
        "frequency": 2
      },
      {
        "name": "Infosys",
        "slug": "infosys",
        "frequency": 2
      },
      {
        "name": "Salesforce",
        "slug": "salesforce",
        "frequency": 2
      }
    ]
  },
  {
    "id": "40",
    "slug": "combination-sum-ii",
    "title": "Combination Sum II",
    "difficulty": "Medium",
    "description": "Given a collection of candidate numbers (`candidates`) and a target number (`target`), find all unique combinations in `candidates` where the candidate numbers sum to `target`. Each number in `candidates` may only be used **once** in the combination.",
    "examples": [
      {
        "input": "candidates = \\[10,1,2,7,6,1,5\\], target = 8",
        "output": ""
      },
      {
        "input": "candidates = \\[2,5,2,1,2\\], target = 5",
        "output": ""
      }
    ],
    "constraints": [
      "`1 <= candidates.length <= 100`",
      "`1 <= candidates[i] <= 50`",
      "`1 <= target <= 30`"
    ],
    "companies": [
      {
        "name": "Meta",
        "slug": "facebook",
        "frequency": 6
      },
      {
        "name": "Google",
        "slug": "google",
        "frequency": 5
      },
      {
        "name": "LinkedIn",
        "slug": "linkedin",
        "frequency": 4
      },
      {
        "name": "Bloomberg",
        "slug": "bloomberg",
        "frequency": 3
      },
      {
        "name": "TikTok",
        "slug": "tiktok",
        "frequency": 3
      },
      {
        "name": "Microsoft",
        "slug": "microsoft",
        "frequency": 2
      },
      {
        "name": "Amazon",
        "slug": "amazon",
        "frequency": 2
      },
      {
        "name": "Oracle",
        "slug": "oracle",
        "frequency": 2
      },
      {
        "name": "ByteDance",
        "slug": "bytedance",
        "frequency": 2
      }
    ]
  },
  {
    "id": "41",
    "slug": "first-missing-positive",
    "title": "First Missing Positive",
    "difficulty": "Hard",
    "description": "Given an unsorted integer array `nums`, return the smallest missing positive integer. You must implement an algorithm that runs in `O(n)` time and uses constant extra space.",
    "examples": [
      {
        "input": "nums = \\[1,2,0\\]",
        "output": "3",
        "explanation": "The numbers in the range \\[1,2\\] are all in the array."
      },
      {
        "input": "nums = \\[3,4,-1,1\\]",
        "output": "2",
        "explanation": "1 is in the array but 2 is missing."
      },
      {
        "input": "nums = \\[7,8,9,11,12\\]",
        "output": "1",
        "explanation": "The smallest positive integer 1 is missing."
      }
    ],
    "constraints": [
      "`1 <= nums.length <= 105`",
      "`-231 <= nums[i] <= 231 - 1`"
    ],
    "companies": [
      {
        "name": "Amazon",
        "slug": "amazon",
        "frequency": 16
      },
      {
        "name": "Google",
        "slug": "google",
        "frequency": 14
      },
      {
        "name": "Meta",
        "slug": "facebook",
        "frequency": 5
      },
      {
        "name": "Oracle",
        "slug": "oracle",
        "frequency": 5
      },
      {
        "name": "MakeMyTrip",
        "slug": "makemytrip",
        "frequency": 4
      },
      {
        "name": "ServiceNow",
        "slug": "servicenow",
        "frequency": 3
      },
      {
        "name": "Netflix",
        "slug": "netflix",
        "frequency": 3
      },
      {
        "name": "Zomato",
        "slug": "zomato",
        "frequency": 3
      },
      {
        "name": "Microsoft",
        "slug": "microsoft",
        "frequency": 2
      },
      {
        "name": "Tesla",
        "slug": "tesla",
        "frequency": 2
      },
      {
        "name": "Myntra",
        "slug": "myntra",
        "frequency": 2
      },
      {
        "name": "Apple",
        "slug": "apple",
        "frequency": 2
      },
      {
        "name": "Bloomberg",
        "slug": "bloomberg",
        "frequency": 2
      },
      {
        "name": "Nutanix",
        "slug": "nutanix",
        "frequency": 2
      },
      {
        "name": "SoundHound",
        "slug": "soundhound",
        "frequency": 2
      },
      {
        "name": "Sprinklr",
        "slug": "sprinklr",
        "frequency": 2
      }
    ]
  },
  {
    "id": "42",
    "slug": "trapping-rain-water",
    "title": "Trapping Rain Water",
    "difficulty": "Hard",
    "description": "Given `n` non-negative integers representing an elevation map where the width of each bar is `1`, compute how much water it can trap after raining.",
    "examples": [
      {
        "input": "height = \\[0,1,0,2,1,0,1,3,2,1,2,1\\]",
        "output": "6",
        "explanation": "The above elevation map (black section) is represented by array \\[0,1,0,2,1,0,1,3,2,1,2,1\\]. In this case, 6 units of rain water (blue section) are being trapped."
      },
      {
        "input": "height = \\[4,2,0,3,2,5\\]",
        "output": "9"
      }
    ],
    "constraints": [
      "`n == height.length`",
      "`1 <= n <= 2  104`",
      "`0 <= height[i] <= 105`"
    ],
    "companies": [
      {
        "name": "Goldman Sachs",
        "slug": "goldman-sachs",
        "frequency": 66
      },
      {
        "name": "Amazon",
        "slug": "amazon",
        "frequency": 59
      },
      {
        "name": "Google",
        "slug": "google",
        "frequency": 28
      },
      {
        "name": "Meta",
        "slug": "facebook",
        "frequency": 14
      },
      {
        "name": "Microsoft",
        "slug": "microsoft",
        "frequency": 11
      },
      {
        "name": "Bloomberg",
        "slug": "bloomberg",
        "frequency": 11
      },
      {
        "name": "TikTok",
        "slug": "tiktok",
        "frequency": 7
      },
      {
        "name": "Zopsmart",
        "slug": "zopsmart",
        "frequency": 5
      },
      {
        "name": "Oracle",
        "slug": "oracle",
        "frequency": 5
      },
      {
        "name": "Snowflake",
        "slug": "snowflake",
        "frequency": 4
      },
      {
        "name": "Visa",
        "slug": "visa",
        "frequency": 4
      },
      {
        "name": "PhonePe",
        "slug": "phonepe",
        "frequency": 4
      },
      {
        "name": "Apple",
        "slug": "apple",
        "frequency": 3
      },
      {
        "name": "Uber",
        "slug": "uber",
        "frequency": 3
      },
      {
        "name": "Salesforce",
        "slug": "salesforce",
        "frequency": 3
      },
      {
        "name": "Yandex",
        "slug": "yandex",
        "frequency": 3
      },
      {
        "name": "Expedia",
        "slug": "expedia",
        "frequency": 3
      },
      {
        "name": "Zoho",
        "slug": "zoho",
        "frequency": 2
      },
      {
        "name": "Walmart Labs",
        "slug": "walmart-labs",
        "frequency": 2
      },
      {
        "name": "Nutanix",
        "slug": "nutanix",
        "frequency": 2
      },
      {
        "name": "ServiceNow",
        "slug": "servicenow",
        "frequency": 2
      },
      {
        "name": "Tekion",
        "slug": "tekion",
        "frequency": 2
      },
      {
        "name": "tcs",
        "slug": "tcs",
        "frequency": 2
      },
      {
        "name": "Grammarly",
        "slug": "grammarly",
        "frequency": 2
      },
      {
        "name": "Zeta",
        "slug": "zeta",
        "frequency": 2
      },
      {
        "name": "Roblox",
        "slug": "roblox",
        "frequency": 2
      },
      {
        "name": "Qualcomm",
        "slug": "qualcomm",
        "frequency": 2
      },
      {
        "name": "Intel",
        "slug": "intel",
        "frequency": 2
      },
      {
        "name": "Flipkart",
        "slug": "flipkart",
        "frequency": 2
      },
      {
        "name": "InMobi",
        "slug": "inmobi",
        "frequency": 2
      },
      {
        "name": "SAP",
        "slug": "sap",
        "frequency": 2
      },
      {
        "name": "HashedIn",
        "slug": "hashedin",
        "frequency": 2
      },
      {
        "name": "American Express",
        "slug": "american-express",
        "frequency": 2
      }
    ]
  },
  {
    "id": "46",
    "slug": "permutations",
    "title": "Permutations",
    "difficulty": "Medium",
    "description": "Given an array `nums` of distinct integers, return _all the possible permutations_. You can return the answer in **any order**.",
    "examples": [
      {
        "input": "nums = \\[1,2,3\\]",
        "output": "\\[\\[1,2,3\\],\\[1,3,2\\],\\[2,1,3\\],\\[2,3,1\\],\\[3,1,2\\],\\[3,2,1\\]\\]"
      },
      {
        "input": "nums = \\[0,1\\]",
        "output": "\\[\\[0,1\\],\\[1,0\\]\\]"
      },
      {
        "input": "nums = \\[1\\]",
        "output": "\\[\\[1\\]\\]"
      }
    ],
    "constraints": [
      "`1 <= nums.length <= 6`",
      "`-10 <= nums[i] <= 10`",
      "All the integers of `nums` are unique."
    ],
    "companies": [
      {
        "name": "Google",
        "slug": "google",
        "frequency": 14
      },
      {
        "name": "Amazon",
        "slug": "amazon",
        "frequency": 11
      },
      {
        "name": "Microsoft",
        "slug": "microsoft",
        "frequency": 4
      },
      {
        "name": "Bloomberg",
        "slug": "bloomberg",
        "frequency": 4
      },
      {
        "name": "Apple",
        "slug": "apple",
        "frequency": 3
      },
      {
        "name": "Meta",
        "slug": "facebook",
        "frequency": 2
      },
      {
        "name": "Booking.com",
        "slug": "bookingcom",
        "frequency": 2
      },
      {
        "name": "American Express",
        "slug": "american-express",
        "frequency": 2
      },
      {
        "name": "LinkedIn",
        "slug": "linkedin",
        "frequency": 2
      },
      {
        "name": "Oracle",
        "slug": "oracle",
        "frequency": 2
      },
      {
        "name": "Uber",
        "slug": "uber",
        "frequency": 2
      },
      {
        "name": "TikTok",
        "slug": "tiktok",
        "frequency": 2
      },
      {
        "name": "Qualcomm",
        "slug": "qualcomm",
        "frequency": 2
      }
    ]
  },
  {
    "id": "47",
    "slug": "permutations-ii",
    "title": "Permutations II",
    "difficulty": "Medium",
    "description": "Given a collection of numbers, `nums`, that might contain duplicates, return _all possible unique permutations **in any order**._",
    "examples": [
      {
        "input": "nums = \\[1,1,2\\]",
        "output": ""
      },
      {
        "input": "nums = \\[1,2,3\\]",
        "output": "\\[\\[1,2,3\\],\\[1,3,2\\],\\[2,1,3\\],\\[2,3,1\\],\\[3,1,2\\],\\[3,2,1\\]\\]"
      }
    ],
    "constraints": ["`1 <= nums.length <= 8`", "`-10 <= nums[i] <= 10`"],
    "companies": [
      {
        "name": "Google",
        "slug": "google",
        "frequency": 5
      },
      {
        "name": "Amazon",
        "slug": "amazon",
        "frequency": 3
      },
      {
        "name": "Microsoft",
        "slug": "microsoft",
        "frequency": 2
      },
      {
        "name": "LinkedIn",
        "slug": "linkedin",
        "frequency": 2
      }
    ]
  },
  {
    "id": "48",
    "slug": "rotate-image",
    "title": "Rotate Image",
    "difficulty": "Medium",
    "description": "You are given an `n x n` 2D `matrix` representing an image, rotate the image by **90** degrees (clockwise). You have to rotate the image [**in-place**](https://en.wikipedia.org/wiki/In-place_algorithm), which means you have to modify the input 2D matrix directly. **DO NOT** allocate another 2D matrix and do the rotation.",
    "examples": [
      {
        "input": "matrix = \\[\\[1,2,3\\],\\[4,5,6\\],\\[7,8,9\\]\\]",
        "output": "\\[\\[7,4,1\\],\\[8,5,2\\],\\[9,6,3\\]\\]"
      },
      {
        "input": "matrix = \\[\\[5,1,9,11\\],\\[2,4,8,10\\],\\[13,3,6,7\\],\\[15,14,12,16\\]\\]",
        "output": "\\[\\[15,13,2,5\\],\\[14,3,4,1\\],\\[12,6,8,9\\],\\[16,7,10,11\\]\\]"
      }
    ],
    "constraints": [
      "`n == matrix.length == matrix[i].length`",
      "`1 <= n <= 20`",
      "`-1000 <= matrix[i][j] <= 1000`"
    ],
    "companies": [
      {
        "name": "Google",
        "slug": "google",
        "frequency": 26
      },
      {
        "name": "Amazon",
        "slug": "amazon",
        "frequency": 13
      },
      {
        "name": "Microsoft",
        "slug": "microsoft",
        "frequency": 8
      },
      {
        "name": "J.P. Morgan",
        "slug": "jpmorgan",
        "frequency": 8
      },
      {
        "name": "Meta",
        "slug": "facebook",
        "frequency": 6
      },
      {
        "name": "Cisco",
        "slug": "cisco",
        "frequency": 4
      },
      {
        "name": "Roblox",
        "slug": "roblox",
        "frequency": 4
      },
      {
        "name": "Bloomberg",
        "slug": "bloomberg",
        "frequency": 3
      },
      {
        "name": "Zoho",
        "slug": "zoho",
        "frequency": 3
      },
      {
        "name": "Apple",
        "slug": "apple",
        "frequency": 3
      },
      {
        "name": "Capital One",
        "slug": "capital-one",
        "frequency": 3
      },
      {
        "name": "Uber",
        "slug": "uber",
        "frequency": 2
      },
      {
        "name": "IBM",
        "slug": "ibm",
        "frequency": 2
      },
      {
        "name": "Infosys",
        "slug": "infosys",
        "frequency": 2
      },
      {
        "name": "Walmart Labs",
        "slug": "walmart-labs",
        "frequency": 2
      }
    ]
  },
  {
    "id": "51",
    "slug": "n-queens",
    "title": "N-Queens",
    "difficulty": "Hard",
    "description": "The **n-queens** puzzle is the problem of placing `n` queens on an `n x n` chessboard such that no two queens attack each other. Given an integer `n`, return _all distinct solutions to the **n-queens puzzle**_. You may return the answer in **any order**. Each solution contains a distinct board configuration of the n-queens' placement, where `'Q'` and `'.'` both indicate a queen and an empty space, respectively.",
    "examples": [
      {
        "input": "n = 4",
        "output": "\\[\\[ \".Q.. \", \"...Q \", \"Q... \", \"..Q. \"\\],\\[ \"..Q. \", \"Q... \", \"...Q \", \".Q.. \"\\]\\]",
        "explanation": "There exist two distinct solutions to the 4-queens puzzle as shown above"
      },
      {
        "input": "n = 1",
        "output": "\\[\\[ \"Q \"\\]\\]"
      }
    ],
    "constraints": ["`1 <= n <= 9`"],
    "companies": [
      {
        "name": "Amazon",
        "slug": "amazon",
        "frequency": 12
      },
      {
        "name": "Google",
        "slug": "google",
        "frequency": 11
      },
      {
        "name": "Microsoft",
        "slug": "microsoft",
        "frequency": 10
      },
      {
        "name": "Bloomberg",
        "slug": "bloomberg",
        "frequency": 4
      },
      {
        "name": "Meta",
        "slug": "facebook",
        "frequency": 3
      },
      {
        "name": "Oracle",
        "slug": "oracle",
        "frequency": 3
      },
      {
        "name": "TikTok",
        "slug": "tiktok",
        "frequency": 2
      },
      {
        "name": "Zoho",
        "slug": "zoho",
        "frequency": 2
      },
      {
        "name": "IBM",
        "slug": "ibm",
        "frequency": 2
      },
      {
        "name": "tcs",
        "slug": "tcs",
        "frequency": 2
      }
    ]
  },
  {
    "id": "53",
    "slug": "maximum-subarray",
    "title": "Maximum Subarray",
    "difficulty": "Medium",
    "description": "Given an integer array `nums`, find the subarray with the largest sum, and return _its sum_.",
    "examples": [
      {
        "input": "nums = \\[-2,1,-3,4,-1,2,1,-5,4\\]",
        "output": "6",
        "explanation": "The subarray \\[4,-1,2,1\\] has the largest sum 6."
      },
      {
        "input": "nums = \\[1\\]",
        "output": "1",
        "explanation": "The subarray \\[1\\] has the largest sum 1."
      },
      {
        "input": "nums = \\[5,4,-1,7,8\\]",
        "output": "23",
        "explanation": "The subarray \\[5,4,-1,7,8\\] has the largest sum 23."
      }
    ],
    "constraints": [
      "`1 <= nums.length <= 105`",
      "`-104 <= nums[i] <= 104`",
      "Follow up: If you have figured out the `O(n)` solution, try coding another solution using the divide and conquer approach, which is more subtle."
    ],
    "companies": [
      {
        "name": "Amazon",
        "slug": "amazon",
        "frequency": 30
      },
      {
        "name": "Google",
        "slug": "google",
        "frequency": 24
      },
      {
        "name": "LinkedIn",
        "slug": "linkedin",
        "frequency": 16
      },
      {
        "name": "Meta",
        "slug": "facebook",
        "frequency": 13
      },
      {
        "name": "Microsoft",
        "slug": "microsoft",
        "frequency": 11
      },
      {
        "name": "Bloomberg",
        "slug": "bloomberg",
        "frequency": 8
      },
      {
        "name": "Nvidia",
        "slug": "nvidia",
        "frequency": 7
      },
      {
        "name": "Upstart",
        "slug": "upstart",
        "frequency": 6
      },
      {
        "name": "Apple",
        "slug": "apple",
        "frequency": 5
      },
      {
        "name": "Oracle",
        "slug": "oracle",
        "frequency": 4
      },
      {
        "name": "TikTok",
        "slug": "tiktok",
        "frequency": 4
      },
      {
        "name": "Goldman Sachs",
        "slug": "goldman-sachs",
        "frequency": 3
      },
      {
        "name": "Cisco",
        "slug": "cisco",
        "frequency": 3
      },
      {
        "name": "Tekion",
        "slug": "tekion",
        "frequency": 3
      },
      {
        "name": "Uber",
        "slug": "uber",
        "frequency": 3
      },
      {
        "name": "Infosys",
        "slug": "infosys",
        "frequency": 3
      },
      {
        "name": "Intel",
        "slug": "intel",
        "frequency": 2
      },
      {
        "name": "tcs",
        "slug": "tcs",
        "frequency": 2
      },
      {
        "name": "Accenture",
        "slug": "accenture",
        "frequency": 2
      },
      {
        "name": "Vimeo",
        "slug": "vimeo",
        "frequency": 2
      },
      {
        "name": "IBM",
        "slug": "ibm",
        "frequency": 2
      },
      {
        "name": "Cognizant",
        "slug": "cognizant",
        "frequency": 2
      },
      {
        "name": "Squarepoint Capital",
        "slug": "squarepoint-capital",
        "frequency": 2
      }
    ]
  },
  {
    "id": "54",
    "slug": "spiral-matrix",
    "title": "Spiral Matrix",
    "difficulty": "Medium",
    "description": "Given an `m x n` `matrix`, return _all elements of the_ `matrix` _in spiral order_.",
    "examples": [
      {
        "input": "matrix = \\[\\[1,2,3\\],\\[4,5,6\\],\\[7,8,9\\]\\]",
        "output": "\\[1,2,3,6,9,8,7,4,5\\]"
      },
      {
        "input": "matrix = \\[\\[1,2,3,4\\],\\[5,6,7,8\\],\\[9,10,11,12\\]\\]",
        "output": "\\[1,2,3,4,8,12,11,10,9,5,6,7\\]"
      }
    ],
    "constraints": [
      "`m == matrix.length`",
      "`n == matrix[i].length`",
      "`1 <= m, n <= 10`",
      "`-100 <= matrix[i][j] <= 100`"
    ],
    "companies": [
      {
        "name": "Amazon",
        "slug": "amazon",
        "frequency": 18
      },
      {
        "name": "Google",
        "slug": "google",
        "frequency": 14
      },
      {
        "name": "Microsoft",
        "slug": "microsoft",
        "frequency": 7
      },
      {
        "name": "Apple",
        "slug": "apple",
        "frequency": 6
      },
      {
        "name": "Meta",
        "slug": "facebook",
        "frequency": 6
      },
      {
        "name": "Cisco",
        "slug": "cisco",
        "frequency": 6
      },
      {
        "name": "TikTok",
        "slug": "tiktok",
        "frequency": 6
      },
      {
        "name": "eBay",
        "slug": "ebay",
        "frequency": 4
      },
      {
        "name": "Uber",
        "slug": "uber",
        "frequency": 4
      },
      {
        "name": "Capital One",
        "slug": "capital-one",
        "frequency": 4
      },
      {
        "name": "Epic Systems",
        "slug": "epic-systems",
        "frequency": 2
      },
      {
        "name": "Bloomberg",
        "slug": "bloomberg",
        "frequency": 2
      },
      {
        "name": "Yahoo",
        "slug": "yahoo",
        "frequency": 2
      },
      {
        "name": "Oracle",
        "slug": "oracle",
        "frequency": 2
      },
      {
        "name": "Zoho",
        "slug": "zoho",
        "frequency": 2
      },
      {
        "name": "Roblox",
        "slug": "roblox",
        "frequency": 2
      },
      {
        "name": "RBC",
        "slug": "rbc",
        "frequency": 2
      },
      {
        "name": "Anduril",
        "slug": "anduril",
        "frequency": 2
      },
      {
        "name": "Adobe",
        "slug": "adobe",
        "frequency": 2
      },
      {
        "name": "PayPal",
        "slug": "paypal",
        "frequency": 2
      },
      {
        "name": "Nutanix",
        "slug": "nutanix",
        "frequency": 2
      },
      {
        "name": "Intuit",
        "slug": "intuit",
        "frequency": 2
      },
      {
        "name": "Databricks",
        "slug": "databricks",
        "frequency": 2
      },
      {
        "name": "IBM",
        "slug": "ibm",
        "frequency": 2
      },
      {
        "name": "Nordstrom",
        "slug": "nordstrom",
        "frequency": 2
      },
      {
        "name": "SIG",
        "slug": "sig",
        "frequency": 2
      }
    ]
  },
  {
    "id": "55",
    "slug": "jump-game",
    "title": "Jump Game",
    "difficulty": "Medium",
    "description": "You are given an integer array `nums`. You are initially positioned at the array's **first index**, and each element in the array represents your maximum jump length at that position. Return `true` _if you can reach the last index, or_ `false` _otherwise_.",
    "examples": [
      {
        "input": "nums = \\[2,3,1,1,4\\]",
        "output": "true",
        "explanation": "Jump 1 step from index 0 to 1, then 3 steps to the last index."
      },
      {
        "input": "nums = \\[3,2,1,0,4\\]",
        "output": "false",
        "explanation": "You will always arrive at index 3 no matter what. Its maximum jump length is 0, which makes it impossible to reach the last index."
      }
    ],
    "constraints": ["`1 <= nums.length <= 104`", "`0 <= nums[i] <= 105`"],
    "companies": [
      {
        "name": "Amazon",
        "slug": "amazon",
        "frequency": 31
      },
      {
        "name": "Google",
        "slug": "google",
        "frequency": 9
      },
      {
        "name": "Bloomberg",
        "slug": "bloomberg",
        "frequency": 8
      },
      {
        "name": "Meta",
        "slug": "facebook",
        "frequency": 6
      },
      {
        "name": "tcs",
        "slug": "tcs",
        "frequency": 6
      },
      {
        "name": "Microsoft",
        "slug": "microsoft",
        "frequency": 4
      },
      {
        "name": "Apple",
        "slug": "apple",
        "frequency": 4
      },
      {
        "name": "Goldman Sachs",
        "slug": "goldman-sachs",
        "frequency": 3
      },
      {
        "name": "Walmart Labs",
        "slug": "walmart-labs",
        "frequency": 3
      },
      {
        "name": "PayPal",
        "slug": "paypal",
        "frequency": 2
      },
      {
        "name": "Oracle",
        "slug": "oracle",
        "frequency": 2
      },
      {
        "name": "DoorDash",
        "slug": "doordash",
        "frequency": 2
      },
      {
        "name": "Zoho",
        "slug": "zoho",
        "frequency": 2
      },
      {
        "name": "HashedIn",
        "slug": "hashedin",
        "frequency": 2
      },
      {
        "name": "TikTok",
        "slug": "tiktok",
        "frequency": 2
      },
      {
        "name": "Meesho",
        "slug": "meesho",
        "frequency": 2
      }
    ]
  },
  {
    "id": "56",
    "slug": "merge-intervals",
    "title": "Merge Intervals",
    "difficulty": "Medium",
    "description": "Given an array of `intervals` where `intervals[i] = [starti, endi]`, merge all overlapping intervals, and return _an array of the non-overlapping intervals that cover all the intervals in the input_.",
    "examples": [
      {
        "input": "intervals = \\[\\[1,3\\],\\[2,6\\],\\[8,10\\],\\[15,18\\]\\]",
        "output": "\\[\\[1,6\\],\\[8,10\\],\\[15,18\\]\\]",
        "explanation": "Since intervals \\[1,3\\] and \\[2,6\\] overlap, merge them into \\[1,6\\]."
      },
      {
        "input": "intervals = \\[\\[1,4\\],\\[4,5\\]\\]",
        "output": "\\[\\[1,5\\]\\]",
        "explanation": "Intervals \\[1,4\\] and \\[4,5\\] are considered overlapping."
      }
    ],
    "constraints": [
      "`1 <= intervals.length <= 104`",
      "`intervals[i].length == 2`",
      "`0 <= starti <= endi <= 104`"
    ],
    "companies": [
      {
        "name": "Meta",
        "slug": "facebook",
        "frequency": 102
      },
      {
        "name": "Amazon",
        "slug": "amazon",
        "frequency": 57
      },
      {
        "name": "Bloomberg",
        "slug": "bloomberg",
        "frequency": 30
      },
      {
        "name": "Google",
        "slug": "google",
        "frequency": 24
      },
      {
        "name": "Microsoft",
        "slug": "microsoft",
        "frequency": 11
      },
      {
        "name": "Grammarly",
        "slug": "grammarly",
        "frequency": 9
      },
      {
        "name": "Citadel",
        "slug": "citadel",
        "frequency": 8
      },
      {
        "name": "Hubspot",
        "slug": "hubspot",
        "frequency": 8
      },
      {
        "name": "Apple",
        "slug": "apple",
        "frequency": 7
      },
      {
        "name": "Salesforce",
        "slug": "salesforce",
        "frequency": 7
      },
      {
        "name": "IBM",
        "slug": "ibm",
        "frequency": 6
      },
      {
        "name": "Walmart Labs",
        "slug": "walmart-labs",
        "frequency": 5
      },
      {
        "name": "Oracle",
        "slug": "oracle",
        "frequency": 5
      },
      {
        "name": "Tesco",
        "slug": "tesco",
        "frequency": 5
      },
      {
        "name": "Yandex",
        "slug": "yandex",
        "frequency": 4
      },
      {
        "name": "TikTok",
        "slug": "tiktok",
        "frequency": 4
      },
      {
        "name": "Roblox",
        "slug": "roblox",
        "frequency": 4
      },
      {
        "name": "Palantir Technologies",
        "slug": "palantir-technologies",
        "frequency": 3
      },
      {
        "name": "Goldman Sachs",
        "slug": "goldman-sachs",
        "frequency": 3
      },
      {
        "name": "Netflix",
        "slug": "netflix",
        "frequency": 3
      },
      {
        "name": "Visa",
        "slug": "visa",
        "frequency": 3
      },
      {
        "name": "Zoho",
        "slug": "zoho",
        "frequency": 3
      },
      {
        "name": "Cisco",
        "slug": "cisco",
        "frequency": 3
      },
      {
        "name": "Nextdoor",
        "slug": "nextdoor",
        "frequency": 3
      },
      {
        "name": "Disney",
        "slug": "disney",
        "frequency": 3
      },
      {
        "name": "CrowdStrike",
        "slug": "crowdstrike",
        "frequency": 3
      },
      {
        "name": "LinkedIn",
        "slug": "linkedin",
        "frequency": 2
      },
      {
        "name": "Uber",
        "slug": "uber",
        "frequency": 2
      },
      {
        "name": "ServiceNow",
        "slug": "servicenow",
        "frequency": 2
      },
      {
        "name": "Capital One",
        "slug": "capital-one",
        "frequency": 2
      },
      {
        "name": "Atlassian",
        "slug": "atlassian",
        "frequency": 2
      },
      {
        "name": "ByteDance",
        "slug": "bytedance",
        "frequency": 2
      },
      {
        "name": "IXL",
        "slug": "ixl",
        "frequency": 2
      },
      {
        "name": "J.P. Morgan",
        "slug": "jpmorgan",
        "frequency": 2
      },
      {
        "name": "Tesla",
        "slug": "tesla",
        "frequency": 2
      },
      {
        "name": "Ozon",
        "slug": "ozon",
        "frequency": 2
      },
      {
        "name": "Infosys",
        "slug": "infosys",
        "frequency": 2
      },
      {
        "name": "Docusign",
        "slug": "docusign",
        "frequency": 2
      },
      {
        "name": "GoDaddy",
        "slug": "godaddy",
        "frequency": 2
      },
      {
        "name": "Nvidia",
        "slug": "nvidia",
        "frequency": 2
      },
      {
        "name": "Expedia",
        "slug": "expedia",
        "frequency": 2
      },
      {
        "name": "razorpay",
        "slug": "razorpay",
        "frequency": 2
      },
      {
        "name": "EPAM Systems",
        "slug": "epam-systems",
        "frequency": 2
      },
      {
        "name": "AMD",
        "slug": "amd",
        "frequency": 2
      },
      {
        "name": "Anduril",
        "slug": "anduril",
        "frequency": 2
      },
      {
        "name": "Moveworks",
        "slug": "moveworks",
        "frequency": 2
      },
      {
        "name": "Ripple",
        "slug": "ripple",
        "frequency": 2
      }
    ]
  },
  {
    "id": "57",
    "slug": "insert-interval",
    "title": "Insert Interval",
    "difficulty": "Medium",
    "description": "You are given an array of non-overlapping intervals `intervals` where `intervals[i] = [starti, endi]` represent the start and the end of the `ith` interval and `intervals` is sorted in ascending order by `starti`. You are also given an interval `newInterval = [start, end]` that represents the start and end of another interval. Insert `newInterval` into `intervals` such that `intervals` is still sorted in ascending order by `starti` and `intervals` still does not have any overlapping intervals (merge overlapping intervals if necessary). Return `intervals` _after the insertion_.",
    "examples": [
      {
        "input": "intervals = \\[\\[1,3\\],\\[6,9\\]\\], newInterval = \\[2,5\\]",
        "output": "\\[\\[1,5\\],\\[6,9\\]\\]"
      },
      {
        "input": "intervals = \\[\\[1,2\\],\\[3,5\\],\\[6,7\\],\\[8,10\\],\\[12,16\\]\\], newInterval = \\[4,8\\]",
        "output": "\\[\\[1,2\\],\\[3,10\\],\\[12,16\\]\\]",
        "explanation": "Because the new interval \\[4,8\\] overlaps with \\[3,5\\],\\[6,7\\],\\[8,10\\]."
      }
    ],
    "constraints": [
      "`0 <= intervals.length <= 104`",
      "`intervals[i].length == 2`",
      "`0 <= starti <= endi <= 105`",
      "`intervals` is sorted by `starti` in ascending order.",
      "`newInterval.length == 2`",
      "`0 <= start <= end <= 105`"
    ],
    "companies": [
      {
        "name": "Uber",
        "slug": "uber",
        "frequency": 5
      },
      {
        "name": "Google",
        "slug": "google",
        "frequency": 4
      },
      {
        "name": "Amazon",
        "slug": "amazon",
        "frequency": 4
      },
      {
        "name": "MongoDB",
        "slug": "mongodb",
        "frequency": 3
      },
      {
        "name": "Meta",
        "slug": "facebook",
        "frequency": 2
      },
      {
        "name": "Microsoft",
        "slug": "microsoft",
        "frequency": 2
      },
      {
        "name": "Apple",
        "slug": "apple",
        "frequency": 2
      },
      {
        "name": "Bloomberg",
        "slug": "bloomberg",
        "frequency": 2
      }
    ]
  },
  {
    "id": "61",
    "slug": "rotate-list",
    "title": "Rotate List",
    "difficulty": "Medium",
    "description": "Given the `head` of a linked list, rotate the list to the right by `k` places.",
    "examples": [
      {
        "input": "head = \\[1,2,3,4,5\\], k = 2",
        "output": "\\[4,5,1,2,3\\]"
      },
      {
        "input": "head = \\[0,1,2\\], k = 4",
        "output": "\\[2,0,1\\]"
      }
    ],
    "constraints": [
      "The number of nodes in the list is in the range `[0, 500]`.",
      "`-100 <= Node.val <= 100`",
      "`0 <= k <= 2  109`"
    ],
    "companies": [
      {
        "name": "Google",
        "slug": "google",
        "frequency": 8
      },
      {
        "name": "Bloomberg",
        "slug": "bloomberg",
        "frequency": 7
      },
      {
        "name": "Meta",
        "slug": "facebook",
        "frequency": 5
      },
      {
        "name": "Amazon",
        "slug": "amazon",
        "frequency": 3
      },
      {
        "name": "LinkedIn",
        "slug": "linkedin",
        "frequency": 3
      },
      {
        "name": "Microsoft",
        "slug": "microsoft",
        "frequency": 2
      }
    ]
  },
  {
    "id": "62",
    "slug": "unique-paths",
    "title": "Unique Paths",
    "difficulty": "Medium",
    "description": "There is a robot on an `m x n` grid. The robot is initially located at the **top-left corner** (i.e., `grid[0][0]`). The robot tries to move to the **bottom-right corner** (i.e., `grid[m - 1][n - 1]`). The robot can only move either down or right at any point in time. Given the two integers `m` and `n`, return _the number of possible unique paths that the robot can take to reach the bottom-right corner_. The test cases are generated so that the answer will be less than or equal to `2 * 109`.",
    "examples": [
      {
        "input": "m = 3, n = 7",
        "output": "28"
      },
      {
        "input": "m = 3, n = 2",
        "output": "3",
        "explanation": "From the top-left corner, there are a total of 3 ways to reach the bottom-right corner:"
      }
    ],
    "constraints": ["`1 <= m, n <= 100`"],
    "companies": [
      {
        "name": "Amazon",
        "slug": "amazon",
        "frequency": 17
      },
      {
        "name": "Google",
        "slug": "google",
        "frequency": 10
      },
      {
        "name": "Meta",
        "slug": "facebook",
        "frequency": 7
      },
      {
        "name": "Microsoft",
        "slug": "microsoft",
        "frequency": 6
      },
      {
        "name": "Bloomberg",
        "slug": "bloomberg",
        "frequency": 4
      },
      {
        "name": "DE Shaw",
        "slug": "de-shaw",
        "frequency": 2
      },
      {
        "name": "Accenture",
        "slug": "accenture",
        "frequency": 2
      }
    ]
  },
  {
    "id": "70",
    "slug": "climbing-stairs",
    "title": "Climbing Stairs",
    "difficulty": "Easy",
    "description": "You are climbing a staircase. It takes `n` steps to reach the top. Each time you can either climb `1` or `2` steps. In how many distinct ways can you climb to the top?",
    "examples": [
      {
        "input": "n = 2",
        "output": "2",
        "explanation": "There are two ways to climb to the top."
      },
      {
        "input": "n = 3",
        "output": "3",
        "explanation": "There are three ways to climb to the top."
      }
    ],
    "constraints": ["`1 <= n <= 45`"],
    "companies": [
      {
        "name": "Google",
        "slug": "google",
        "frequency": 30
      },
      {
        "name": "Amazon",
        "slug": "amazon",
        "frequency": 27
      },
      {
        "name": "Microsoft",
        "slug": "microsoft",
        "frequency": 12
      },
      {
        "name": "Meta",
        "slug": "facebook",
        "frequency": 10
      },
      {
        "name": "Accenture",
        "slug": "accenture",
        "frequency": 7
      },
      {
        "name": "Zoho",
        "slug": "zoho",
        "frequency": 5
      },
      {
        "name": "Bloomberg",
        "slug": "bloomberg",
        "frequency": 4
      },
      {
        "name": "TikTok",
        "slug": "tiktok",
        "frequency": 3
      },
      {
        "name": "Grammarly",
        "slug": "grammarly",
        "frequency": 2
      },
      {
        "name": "IBM",
        "slug": "ibm",
        "frequency": 2
      },
      {
        "name": "Accolite",
        "slug": "accolite",
        "frequency": 2
      },
      {
        "name": "Deloitte",
        "slug": "deloitte",
        "frequency": 2
      },
      {
        "name": "ByteDance",
        "slug": "bytedance",
        "frequency": 2
      }
    ]
  },
  {
    "id": "73",
    "slug": "set-matrix-zeroes",
    "title": "Set Matrix Zeroes",
    "difficulty": "Medium",
    "description": "Given an `m x n` integer matrix `matrix`, if an element is `0`, set its entire row and column to `0`'s. You must do it [in place](https://en.wikipedia.org/wiki/In-place_algorithm).",
    "examples": [
      {
        "input": "matrix = \\[\\[1,1,1\\],\\[1,0,1\\],\\[1,1,1\\]\\]",
        "output": "\\[\\[1,0,1\\],\\[0,0,0\\],\\[1,0,1\\]\\]"
      },
      {
        "input": "matrix = \\[\\[0,1,2,0\\],\\[3,4,5,2\\],\\[1,3,1,5\\]\\]",
        "output": "\\[\\[0,0,0,0\\],\\[0,4,5,0\\],\\[0,3,1,0\\]\\]"
      }
    ],
    "constraints": [
      "`m == matrix.length`",
      "`n == matrix[0].length`",
      "`1 <= m, n <= 200`",
      "`-231 <= matrix[i][j] <= 231 - 1`",
      "Follow up:",
      "A straightforward solution using `O(mn)` space is probably a bad idea.",
      "A simple improvement uses `O(m + n)` space, but still not the best solution.",
      "Could you devise a constant space solution?"
    ],
    "companies": [
      {
        "name": "Google",
        "slug": "google",
        "frequency": 10
      },
      {
        "name": "Meta",
        "slug": "facebook",
        "frequency": 10
      },
      {
        "name": "Amazon",
        "slug": "amazon",
        "frequency": 9
      },
      {
        "name": "Bloomberg",
        "slug": "bloomberg",
        "frequency": 5
      },
      {
        "name": "Microsoft",
        "slug": "microsoft",
        "frequency": 5
      },
      {
        "name": "Oracle",
        "slug": "oracle",
        "frequency": 4
      },
      {
        "name": "Walmart Labs",
        "slug": "walmart-labs",
        "frequency": 3
      },
      {
        "name": "eBay",
        "slug": "ebay",
        "frequency": 3
      },
      {
        "name": "Apple",
        "slug": "apple",
        "frequency": 3
      },
      {
        "name": "Nutanix",
        "slug": "nutanix",
        "frequency": 2
      },
      {
        "name": "Infosys",
        "slug": "infosys",
        "frequency": 2
      },
      {
        "name": "Autodesk",
        "slug": "autodesk",
        "frequency": 2
      },
      {
        "name": "J.P. Morgan",
        "slug": "jpmorgan",
        "frequency": 2
      },
      {
        "name": "Goldman Sachs",
        "slug": "goldman-sachs",
        "frequency": 2
      }
    ]
  },
  {
    "id": "74",
    "slug": "search-a-2d-matrix",
    "title": "Search a 2D Matrix",
    "difficulty": "Medium",
    "description": "You are given an `m x n` integer matrix `matrix` with the following two properties: *  Each row is sorted in non-decreasing order. *  The first integer of each row is greater than the last integer of the previous row. Given an integer `target`, return `true` _if_ `target` _is in_ `matrix` _or_ `false` _otherwise_. You must write a solution in `O(log(m * n))` time complexity.",
    "examples": [
      {
        "input": "matrix = \\[\\[1,3,5,7\\],\\[10,11,16,20\\],\\[23,30,34,60\\]\\], target = 3",
        "output": "true"
      },
      {
        "input": "matrix = \\[\\[1,3,5,7\\],\\[10,11,16,20\\],\\[23,30,34,60\\]\\], target = 13",
        "output": "false"
      }
    ],
    "constraints": [
      "`m == matrix.length`",
      "`n == matrix[i].length`",
      "`1 <= m, n <= 100`",
      "`-104 <= matrix[i][j], target <= 104`"
    ],
    "companies": [
      {
        "name": "Amazon",
        "slug": "amazon",
        "frequency": 11
      },
      {
        "name": "Meta",
        "slug": "facebook",
        "frequency": 6
      },
      {
        "name": "Google",
        "slug": "google",
        "frequency": 5
      },
      {
        "name": "Bloomberg",
        "slug": "bloomberg",
        "frequency": 4
      },
      {
        "name": "Oracle",
        "slug": "oracle",
        "frequency": 4
      },
      {
        "name": "Microsoft",
        "slug": "microsoft",
        "frequency": 3
      },
      {
        "name": "Goldman Sachs",
        "slug": "goldman-sachs",
        "frequency": 2
      },
      {
        "name": "Nutanix",
        "slug": "nutanix",
        "frequency": 2
      },
      {
        "name": "TikTok",
        "slug": "tiktok",
        "frequency": 2
      }
    ]
  },
  {
    "id": "75",
    "slug": "sort-colors",
    "title": "Sort Colors",
    "difficulty": "Medium",
    "description": "Given an array `nums` with `n` objects colored red, white, or blue, sort them **[in-place](https://en.wikipedia.org/wiki/In-place_algorithm)** so that objects of the same color are adjacent, with the colors in the order red, white, and blue. We will use the integers `0`, `1`, and `2` to represent the color red, white, and blue, respectively. You must solve this problem without using the library's sort function.",
    "examples": [
      {
        "input": "nums = \\[2,0,2,1,1,0\\]",
        "output": "\\[0,0,1,1,2,2\\]"
      },
      {
        "input": "nums = \\[2,0,1\\]",
        "output": "\\[0,1,2\\]"
      }
    ],
    "constraints": [
      "`n == nums.length`",
      "`1 <= n <= 300`",
      "`nums[i]` is either `0`, `1`, or `2`.",
      "Follow up: Could you come up with a one-pass algorithm using only constant extra space?"
    ],
    "companies": [
      {
        "name": "Amazon",
        "slug": "amazon",
        "frequency": 18
      },
      {
        "name": "Google",
        "slug": "google",
        "frequency": 16
      },
      {
        "name": "Meta",
        "slug": "facebook",
        "frequency": 15
      },
      {
        "name": "Microsoft",
        "slug": "microsoft",
        "frequency": 12
      },
      {
        "name": "TikTok",
        "slug": "tiktok",
        "frequency": 6
      },
      {
        "name": "Bloomberg",
        "slug": "bloomberg",
        "frequency": 5
      },
      {
        "name": "tcs",
        "slug": "tcs",
        "frequency": 4
      },
      {
        "name": "Oracle",
        "slug": "oracle",
        "frequency": 2
      },
      {
        "name": "eBay",
        "slug": "ebay",
        "frequency": 2
      },
      {
        "name": "Swiggy",
        "slug": "swiggy",
        "frequency": 2
      },
      {
        "name": "Autodesk",
        "slug": "autodesk",
        "frequency": 2
      },
      {
        "name": "PayPal",
        "slug": "paypal",
        "frequency": 2
      },
      {
        "name": "PhonePe",
        "slug": "phonepe",
        "frequency": 2
      },
      {
        "name": "Zoho",
        "slug": "zoho",
        "frequency": 2
      }
    ]
  },
  {
    "id": "76",
    "slug": "minimum-window-substring",
    "title": "Minimum Window Substring",
    "difficulty": "Hard",
    "description": "Given two strings `s` and `t` of lengths `m` and `n` respectively, return _the **minimum window**_ **_substring_** _of_ `s` _such that every character in_ `t` _(**including duplicates**) is included in the window_. If there is no such substring, return _the empty string_ `\" \"`. The testcases will be generated such that the answer is **unique**.",
    "examples": [
      {
        "input": "s =  \"ADOBECODEBANC \", t =  \"ABC \"",
        "output": "\"BANC \"",
        "explanation": "The minimum window substring  \"BANC \" includes 'A', 'B', and 'C' from string t."
      },
      {
        "input": "s =  \"a \", t =  \"a \"",
        "output": "\"a \"",
        "explanation": "The entire string s is the minimum window."
      },
      {
        "input": "s =  \"a \", t =  \"aa \"",
        "output": "\" \"",
        "explanation": "Both 'a's from t must be included in the window."
      }
    ],
    "constraints": [
      "`m == s.length`",
      "`n == t.length`",
      "`1 <= m, n <= 105`",
      "`s` and `t` consist of uppercase and lowercase English letters.",
      "Follow up: Could you find an algorithm that runs in `O(m + n)` time?"
    ],
    "companies": [
      {
        "name": "Meta",
        "slug": "facebook",
        "frequency": 56
      },
      {
        "name": "Amazon",
        "slug": "amazon",
        "frequency": 12
      },
      {
        "name": "Snowflake",
        "slug": "snowflake",
        "frequency": 7
      },
      {
        "name": "LinkedIn",
        "slug": "linkedin",
        "frequency": 6
      },
      {
        "name": "TikTok",
        "slug": "tiktok",
        "frequency": 6
      },
      {
        "name": "Microsoft",
        "slug": "microsoft",
        "frequency": 5
      },
      {
        "name": "Lyft",
        "slug": "lyft",
        "frequency": 5
      },
      {
        "name": "Airbnb",
        "slug": "airbnb",
        "frequency": 5
      },
      {
        "name": "Google",
        "slug": "google",
        "frequency": 3
      },
      {
        "name": "SoFi",
        "slug": "sofi",
        "frequency": 3
      },
      {
        "name": "Yandex",
        "slug": "yandex",
        "frequency": 2
      },
      {
        "name": "Uber",
        "slug": "uber",
        "frequency": 2
      },
      {
        "name": "Snap",
        "slug": "snapchat",
        "frequency": 2
      },
      {
        "name": "Adobe",
        "slug": "adobe",
        "frequency": 2
      },
      {
        "name": "Salesforce",
        "slug": "salesforce",
        "frequency": 2
      },
      {
        "name": "Infosys",
        "slug": "infosys",
        "frequency": 2
      },
      {
        "name": "Zopsmart",
        "slug": "zopsmart",
        "frequency": 2
      },
      {
        "name": "Zeta",
        "slug": "zeta",
        "frequency": 2
      },
      {
        "name": "thoughtspot",
        "slug": "thoughtspot",
        "frequency": 2
      }
    ]
  },
  {
    "id": "77",
    "slug": "combinations",
    "title": "Combinations",
    "difficulty": "Medium",
    "description": "Given two integers `n` and `k`, return _all possible combinations of_ `k` _numbers chosen from the range_ `[1, n]`. You may return the answer in **any order**.",
    "examples": [
      {
        "input": "n = 4, k = 2",
        "output": "\\[\\[1,2\\],\\[1,3\\],\\[1,4\\],\\[2,3\\],\\[2,4\\],\\[3,4\\]\\]",
        "explanation": "There are 4 choose 2 = 6 total combinations."
      },
      {
        "input": "n = 1, k = 1",
        "output": "\\[\\[1\\]\\]",
        "explanation": "There is 1 choose 1 = 1 total combination."
      }
    ],
    "constraints": ["`1 <= n <= 20`", "`1 <= k <= n`"],
    "companies": [
      {
        "name": "Google",
        "slug": "google",
        "frequency": 4
      },
      {
        "name": "Meta",
        "slug": "facebook",
        "frequency": 3
      },
      {
        "name": "TikTok",
        "slug": "tiktok",
        "frequency": 3
      },
      {
        "name": "Microsoft",
        "slug": "microsoft",
        "frequency": 2
      },
      {
        "name": "Amazon",
        "slug": "amazon",
        "frequency": 2
      }
    ]
  },
  {
    "id": "78",
    "slug": "subsets",
    "title": "Subsets",
    "difficulty": "Medium",
    "description": "Given an integer array `nums` of **unique** elements, return _all possible_ _subsets_ _(the power set)_. The solution set **must not** contain duplicate subsets. Return the solution in **any order**.",
    "examples": [
      {
        "input": "nums = \\[1,2,3\\]",
        "output": "\\[\\[\\],\\[1\\],\\[2\\],\\[1,2\\],\\[3\\],\\[1,3\\],\\[2,3\\],\\[1,2,3\\]\\]"
      },
      {
        "input": "nums = \\[0\\]",
        "output": "\\[\\[\\],\\[0\\]\\]"
      }
    ],
    "constraints": [
      "`1 <= nums.length <= 10`",
      "`-10 <= nums[i] <= 10`",
      "All the numbers of `nums` are unique."
    ],
    "companies": [
      {
        "name": "Meta",
        "slug": "facebook",
        "frequency": 20
      },
      {
        "name": "Amazon",
        "slug": "amazon",
        "frequency": 17
      },
      {
        "name": "Google",
        "slug": "google",
        "frequency": 13
      },
      {
        "name": "Bloomberg",
        "slug": "bloomberg",
        "frequency": 9
      },
      {
        "name": "Microsoft",
        "slug": "microsoft",
        "frequency": 8
      },
      {
        "name": "TikTok",
        "slug": "tiktok",
        "frequency": 4
      },
      {
        "name": "PayPal",
        "slug": "paypal",
        "frequency": 2
      },
      {
        "name": "Wix",
        "slug": "wix",
        "frequency": 2
      },
      {
        "name": "Walmart Labs",
        "slug": "walmart-labs",
        "frequency": 2
      },
      {
        "name": "ByteDance",
        "slug": "bytedance",
        "frequency": 2
      }
    ]
  },
  {
    "id": "79",
    "slug": "word-search",
    "title": "Word Search",
    "difficulty": "Medium",
    "description": "Given an `m x n` grid of characters `board` and a string `word`, return `true` _if_ `word` _exists in the grid_. The word can be constructed from letters of sequentially adjacent cells, where adjacent cells are horizontally or vertically neighboring. The same letter cell may not be used more than once.",
    "examples": [
      {
        "input": "board = \\[\\[ \"A \", \"B \", \"C \", \"E \"\\],\\[ \"S \", \"F \", \"C \", \"S \"\\],\\[ \"A \", \"D \", \"E \", \"E \"\\]\\], word =  \"ABCCED \"",
        "output": "true"
      },
      {
        "input": "board = \\[\\[ \"A \", \"B \", \"C \", \"E \"\\],\\[ \"S \", \"F \", \"C \", \"S \"\\],\\[ \"A \", \"D \", \"E \", \"E \"\\]\\], word =  \"SEE \"",
        "output": "true"
      },
      {
        "input": "board = \\[\\[ \"A \", \"B \", \"C \", \"E \"\\],\\[ \"S \", \"F \", \"C \", \"S \"\\],\\[ \"A \", \"D \", \"E \", \"E \"\\]\\], word =  \"ABCB \"",
        "output": "false"
      }
    ],
    "constraints": [
      "`m == board.length`",
      "`n = board[i].length`",
      "`1 <= m, n <= 6`",
      "`1 <= word.length <= 15`",
      "`board` and `word` consists of only lowercase and uppercase English letters.",
      "Follow up: Could you use search pruning to make your solution faster with a larger `board`?"
    ],
    "companies": [
      {
        "name": "Amazon",
        "slug": "amazon",
        "frequency": 32
      },
      {
        "name": "Bloomberg",
        "slug": "bloomberg",
        "frequency": 22
      },
      {
        "name": "Uber",
        "slug": "uber",
        "frequency": 8
      },
      {
        "name": "Karat",
        "slug": "karat",
        "frequency": 7
      },
      {
        "name": "Google",
        "slug": "google",
        "frequency": 6
      },
      {
        "name": "Microsoft",
        "slug": "microsoft",
        "frequency": 5
      },
      {
        "name": "Goldman Sachs",
        "slug": "goldman-sachs",
        "frequency": 3
      },
      {
        "name": "Meta",
        "slug": "facebook",
        "frequency": 3
      },
      {
        "name": "Netflix",
        "slug": "netflix",
        "frequency": 3
      },
      {
        "name": "Faire",
        "slug": "faire",
        "frequency": 3
      },
      {
        "name": "Oracle",
        "slug": "oracle",
        "frequency": 3
      },
      {
        "name": "Atlassian",
        "slug": "atlassian",
        "frequency": 3
      },
      {
        "name": "PayPal",
        "slug": "paypal",
        "frequency": 2
      },
      {
        "name": "TikTok",
        "slug": "tiktok",
        "frequency": 2
      },
      {
        "name": "Salesforce",
        "slug": "salesforce",
        "frequency": 2
      },
      {
        "name": "Grammarly",
        "slug": "grammarly",
        "frequency": 2
      },
      {
        "name": "Walmart Labs",
        "slug": "walmart-labs",
        "frequency": 2
      },
      {
        "name": "Samsung",
        "slug": "samsung",
        "frequency": 2
      },
      {
        "name": "Zoho",
        "slug": "zoho",
        "frequency": 2
      },
      {
        "name": "Citadel",
        "slug": "citadel",
        "frequency": 2
      },
      {
        "name": "Epic Systems",
        "slug": "epic-systems",
        "frequency": 2
      }
    ]
  },
  {
    "id": "81",
    "slug": "search-in-rotated-sorted-array-ii",
    "title": "Search in Rotated Sorted Array II",
    "difficulty": "Medium",
    "description": "There is an integer array `nums` sorted in non-decreasing order (not necessarily with **distinct** values). Before being passed to your function, `nums` is **rotated** at an unknown pivot index `k` (`0 <= k < nums.length`) such that the resulting array is `[nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]]` (**0-indexed**). For example, `[0,1,2,4,4,4,5,6,6,7]` might be rotated at pivot index `5` and become `[4,5,6,6,7,0,1,2,4,4]`. Given the array `nums` **after** the rotation and an integer `target`, return `true` _if_ `target` _is in_ `nums`_, or_ `false` _if it is not in_ `nums`_._ You must decrease the overall operation steps as much as possible.",
    "examples": [
      {
        "input": "nums = \\[2,5,6,0,0,1,2\\], target = 0",
        "output": "true"
      },
      {
        "input": "nums = \\[2,5,6,0,0,1,2\\], target = 3",
        "output": "false"
      }
    ],
    "constraints": [
      "`1 <= nums.length <= 5000`",
      "`-104 <= nums[i] <= 104`",
      "`nums` is guaranteed to be rotated at some pivot.",
      "`-104 <= target <= 104`",
      "Follow up: This problem is similar to Search in Rotated Sorted Array, but `nums` may contain duplicates. Would this affect the runtime complexity? How and why?"
    ],
    "companies": [
      {
        "name": "Meta",
        "slug": "facebook",
        "frequency": 6
      },
      {
        "name": "Microsoft",
        "slug": "microsoft",
        "frequency": 3
      },
      {
        "name": "Google",
        "slug": "google",
        "frequency": 2
      },
      {
        "name": "Amazon",
        "slug": "amazon",
        "frequency": 2
      },
      {
        "name": "Bloomberg",
        "slug": "bloomberg",
        "frequency": 2
      },
      {
        "name": "Walmart Labs",
        "slug": "walmart-labs",
        "frequency": 2
      }
    ]
  },
  {
    "id": "83",
    "slug": "remove-duplicates-from-sorted-list",
    "title": "Remove Duplicates from Sorted List",
    "difficulty": "Easy",
    "description": "Given the `head` of a sorted linked list, _delete all duplicates such that each element appears only once_. Return _the linked list **sorted** as well_.",
    "examples": [
      {
        "input": "head = \\[1,1,2\\]",
        "output": "\\[1,2\\]"
      },
      {
        "input": "head = \\[1,1,2,3,3\\]",
        "output": "\\[1,2,3\\]"
      }
    ],
    "constraints": [
      "The number of nodes in the list is in the range `[0, 300]`.",
      "`-100 <= Node.val <= 100`",
      "The list is guaranteed to be sorted in ascending order."
    ],
    "companies": [
      {
        "name": "Google",
        "slug": "google",
        "frequency": 4
      },
      {
        "name": "Microsoft",
        "slug": "microsoft",
        "frequency": 3
      },
      {
        "name": "Bloomberg",
        "slug": "bloomberg",
        "frequency": 3
      },
      {
        "name": "Amazon",
        "slug": "amazon",
        "frequency": 3
      },
      {
        "name": "Adobe",
        "slug": "adobe",
        "frequency": 2
      },
      {
        "name": "Meta",
        "slug": "facebook",
        "frequency": 2
      },
      {
        "name": "Nvidia",
        "slug": "nvidia",
        "frequency": 2
      }
    ]
  },
  {
    "id": "90",
    "slug": "subsets-ii",
    "title": "Subsets II",
    "difficulty": "Medium",
    "description": "Given an integer array `nums` that may contain duplicates, return _all possible_ _subsets_ _(the power set)_. The solution set **must not** contain duplicate subsets. Return the solution in **any order**.",
    "examples": [
      {
        "input": "nums = \\[1,2,2\\]",
        "output": "\\[\\[\\],\\[1\\],\\[1,2\\],\\[1,2,2\\],\\[2\\],\\[2,2\\]\\]"
      },
      {
        "input": "nums = \\[0\\]",
        "output": "\\[\\[\\],\\[0\\]\\]"
      }
    ],
    "constraints": ["`1 <= nums.length <= 10`", "`-10 <= nums[i] <= 10`"],
    "companies": [
      {
        "name": "Google",
        "slug": "google",
        "frequency": 6
      },
      {
        "name": "Amazon",
        "slug": "amazon",
        "frequency": 4
      },
      {
        "name": "Meta",
        "slug": "facebook",
        "frequency": 3
      },
      {
        "name": "Microsoft",
        "slug": "microsoft",
        "frequency": 2
      },
      {
        "name": "Bloomberg",
        "slug": "bloomberg",
        "frequency": 2
      },
      {
        "name": "Walmart Labs",
        "slug": "walmart-labs",
        "frequency": 2
      }
    ]
  },
  {
    "id": "91",
    "slug": "decode-ways",
    "title": "Decode Ways",
    "difficulty": "Medium",
    "description": "A message containing letters from `A-Z` can be **encoded** into numbers using the following mapping: 'A' -> \"1 \" 'B' -> \"2 \" ... 'Z' -> \"26 \" To **decode** an encoded message, all the digits must be grouped then mapped back into letters using the reverse of the mapping above (there may be multiple ways). For example, `\"11106 \"` can be mapped into: *  `\"AAJF \"` with the grouping `(1 1 10 6)` *  `\"KJF \"` with the grouping `(11 10 6)` Note that the grouping `(1 11 06)` is invalid because `\"06 \"` cannot be mapped into `'F'` since `\"6 \"` is different from `\"06 \"`. Given a string `s` containing only digits, return _the **number** of ways to **decode** it_. The test cases are generated so that the answer fits in a **32-bit** integer.",
    "examples": [
      {
        "input": "s =  \"12 \"",
        "output": "2",
        "explanation": "\"12 \" could be decoded as  \"AB \" (1 2) or  \"L \" (12)."
      },
      {
        "input": "s =  \"226 \"",
        "output": "3",
        "explanation": "\"226 \" could be decoded as  \"BZ \" (2 26),  \"VF \" (22 6), or  \"BBF \" (2 2 6)."
      },
      {
        "input": "s =  \"06 \"",
        "output": "0",
        "explanation": "\"06 \" cannot be mapped to  \"F \" because of the leading zero ( \"6 \" is different from  \"06 \")."
      }
    ],
    "constraints": [
      "`1 <= s.length <= 100`",
      "`s` contains only digits and may contain leading zero(s)."
    ],
    "companies": [
      {
        "name": "Goldman Sachs",
        "slug": "goldman-sachs",
        "frequency": 5
      },
      {
        "name": "Amazon",
        "slug": "amazon",
        "frequency": 4
      },
      {
        "name": "Google",
        "slug": "google",
        "frequency": 4
      },
      {
        "name": "Microsoft",
        "slug": "microsoft",
        "frequency": 4
      },
      {
        "name": "Meta",
        "slug": "facebook",
        "frequency": 3
      },
      {
        "name": "Lyft",
        "slug": "lyft",
        "frequency": 3
      },
      {
        "name": "Snap",
        "slug": "snapchat",
        "frequency": 3
      },
      {
        "name": "Zoho",
        "slug": "zoho",
        "frequency": 3
      },
      {
        "name": "Apple",
        "slug": "apple",
        "frequency": 2
      },
      {
        "name": "TikTok",
        "slug": "tiktok",
        "frequency": 2
      }
    ]
  },
  {
    "id": "92",
    "slug": "reverse-linked-list-ii",
    "title": "Reverse Linked List II",
    "difficulty": "Medium",
    "description": "Given the `head` of a singly linked list and two integers `left` and `right` where `left <= right`, reverse the nodes of the list from position `left` to position `right`, and return _the reversed list_.",
    "examples": [
      {
        "input": "head = \\[1,2,3,4,5\\], left = 2, right = 4",
        "output": "\\[1,4,3,2,5\\]"
      },
      {
        "input": "head = \\[5\\], left = 1, right = 1",
        "output": "\\[5\\]"
      }
    ],
    "constraints": [
      "The number of nodes in the list is `n`.",
      "`1 <= n <= 500`",
      "`-500 <= Node.val <= 500`",
      "`1 <= left <= right <= n`",
      "Follow up: Could you do it in one pass?"
    ],
    "companies": [
      {
        "name": "Google",
        "slug": "google",
        "frequency": 6
      },
      {
        "name": "Amazon",
        "slug": "amazon",
        "frequency": 4
      },
      {
        "name": "Arista Networks",
        "slug": "arista-networks",
        "frequency": 4
      },
      {
        "name": "Meta",
        "slug": "facebook",
        "frequency": 2
      },
      {
        "name": "Nutanix",
        "slug": "nutanix",
        "frequency": 2
      },
      {
        "name": "Microsoft",
        "slug": "microsoft",
        "frequency": 2
      },
      {
        "name": "Apple",
        "slug": "apple",
        "frequency": 2
      },
      {
        "name": "Walmart Labs",
        "slug": "walmart-labs",
        "frequency": 2
      }
    ]
  },
  {
    "id": "98",
    "slug": "validate-binary-search-tree",
    "title": "Validate Binary Search Tree",
    "difficulty": "Medium",
    "description": "Given the `root` of a binary tree, _determine if it is a valid binary search tree (BST)_. A **valid BST** is defined as follows: *  The left subtree of a node contains only nodes with keys **less than** the node's key. *  The right subtree of a node contains only nodes with keys **greater than** the node's key. *  Both the left and right subtrees must also be binary search trees.",
    "examples": [
      {
        "input": "root = \\[2,1,3\\]",
        "output": "true"
      },
      {
        "input": "root = \\[5,1,4,null,null,3,6\\]",
        "output": "false",
        "explanation": "The root node's value is 5 but its right child's value is 4."
      }
    ],
    "constraints": [
      "The number of nodes in the tree is in the range `[1, 104]`.",
      "`-231 <= Node.val <= 231 - 1`"
    ],
    "companies": [
      {
        "name": "Amazon",
        "slug": "amazon",
        "frequency": 10
      },
      {
        "name": "Meta",
        "slug": "facebook",
        "frequency": 5
      },
      {
        "name": "Google",
        "slug": "google",
        "frequency": 4
      },
      {
        "name": "Bloomberg",
        "slug": "bloomberg",
        "frequency": 4
      },
      {
        "name": "Microsoft",
        "slug": "microsoft",
        "frequency": 3
      },
      {
        "name": "Salesforce",
        "slug": "salesforce",
        "frequency": 2
      },
      {
        "name": "Oracle",
        "slug": "oracle",
        "frequency": 2
      },
      {
        "name": "Yandex",
        "slug": "yandex",
        "frequency": 2
      },
      {
        "name": "IBM",
        "slug": "ibm",
        "frequency": 2
      }
    ]
  },
  {
    "id": "100",
    "slug": "same-tree",
    "title": "Same Tree",
    "difficulty": "Easy",
    "description": "Given the roots of two binary trees `p` and `q`, write a function to check if they are the same or not. Two binary trees are considered the same if they are structurally identical, and the nodes have the same value.",
    "examples": [
      {
        "input": "p = \\[1,2,3\\], q = \\[1,2,3\\]",
        "output": "true"
      },
      {
        "input": "p = \\[1,2\\], q = \\[1,null,2\\]",
        "output": "false"
      },
      {
        "input": "p = \\[1,2,1\\], q = \\[1,1,2\\]",
        "output": "false"
      }
    ],
    "constraints": [
      "The number of nodes in both trees is in the range `[0, 100]`.",
      "`-104 <= Node.val <= 104`"
    ],
    "companies": [
      {
        "name": "Google",
        "slug": "google",
        "frequency": 12
      },
      {
        "name": "Microsoft",
        "slug": "microsoft",
        "frequency": 6
      },
      {
        "name": "Amazon",
        "slug": "amazon",
        "frequency": 2
      },
      {
        "name": "Meta",
        "slug": "facebook",
        "frequency": 2
      },
      {
        "name": "Bloomberg",
        "slug": "bloomberg",
        "frequency": 2
      }
    ]
  },
  {
    "id": "102",
    "slug": "binary-tree-level-order-traversal",
    "title": "Binary Tree Level Order Traversal",
    "difficulty": "Medium",
    "description": "Given the `root` of a binary tree, return _the level order traversal of its nodes' values_. (i.e., from left to right, level by level).",
    "examples": [
      {
        "input": "root = \\[3,9,20,null,null,15,7\\]",
        "output": "\\[\\[3\\],\\[9,20\\],\\[15,7\\]\\]"
      },
      {
        "input": "root = \\[1\\]",
        "output": "\\[\\[1\\]\\]"
      },
      {
        "input": "root = \\[\\]",
        "output": "\\[\\]"
      }
    ],
    "constraints": [
      "The number of nodes in the tree is in the range `[0, 2000]`.",
      "`-1000 <= Node.val <= 1000`"
    ],
    "companies": [
      {
        "name": "Amazon",
        "slug": "amazon",
        "frequency": 17
      },
      {
        "name": "Meta",
        "slug": "facebook",
        "frequency": 5
      },
      {
        "name": "Google",
        "slug": "google",
        "frequency": 5
      },
      {
        "name": "Bloomberg",
        "slug": "bloomberg",
        "frequency": 5
      },
      {
        "name": "Microsoft",
        "slug": "microsoft",
        "frequency": 2
      },
      {
        "name": "Adobe",
        "slug": "adobe",
        "frequency": 2
      },
      {
        "name": "Goldman Sachs",
        "slug": "goldman-sachs",
        "frequency": 2
      },
      {
        "name": "Palo Alto Networks",
        "slug": "palo-alto-networks",
        "frequency": 2
      },
      {
        "name": "Yandex",
        "slug": "yandex",
        "frequency": 2
      }
    ]
  },
  {
    "id": "103",
    "slug": "binary-tree-zigzag-level-order-traversal",
    "title": "Binary Tree Zigzag Level Order Traversal",
    "difficulty": "Medium",
    "description": "Given the `root` of a binary tree, return _the zigzag level order traversal of its nodes' values_. (i.e., from left to right, then right to left for the next level and alternate between).",
    "examples": [
      {
        "input": "root = \\[3,9,20,null,null,15,7\\]",
        "output": "\\[\\[3\\],\\[20,9\\],\\[15,7\\]\\]"
      },
      {
        "input": "root = \\[1\\]",
        "output": "\\[\\[1\\]\\]"
      },
      {
        "input": "root = \\[\\]",
        "output": "\\[\\]"
      }
    ],
    "constraints": [
      "The number of nodes in the tree is in the range `[0, 2000]`.",
      "`-100 <= Node.val <= 100`"
    ],
    "companies": [
      {
        "name": "Amazon",
        "slug": "amazon",
        "frequency": 17
      },
      {
        "name": "Meta",
        "slug": "facebook",
        "frequency": 7
      },
      {
        "name": "Microsoft",
        "slug": "microsoft",
        "frequency": 6
      },
      {
        "name": "Walmart Labs",
        "slug": "walmart-labs",
        "frequency": 4
      },
      {
        "name": "Yandex",
        "slug": "yandex",
        "frequency": 4
      },
      {
        "name": "Bloomberg",
        "slug": "bloomberg",
        "frequency": 3
      },
      {
        "name": "Oracle",
        "slug": "oracle",
        "frequency": 3
      },
      {
        "name": "Citadel",
        "slug": "citadel",
        "frequency": 3
      },
      {
        "name": "Google",
        "slug": "google",
        "frequency": 2
      },
      {
        "name": "Nutanix",
        "slug": "nutanix",
        "frequency": 2
      },
      {
        "name": "TikTok",
        "slug": "tiktok",
        "frequency": 2
      },
      {
        "name": "Sigmoid",
        "slug": "sigmoid",
        "frequency": 2
      }
    ]
  },
  {
    "id": "104",
    "slug": "maximum-depth-of-binary-tree",
    "title": "Maximum Depth of Binary Tree",
    "difficulty": "Easy",
    "description": "Given the `root` of a binary tree, return _its maximum depth_. A binary tree's **maximum depth** is the number of nodes along the longest path from the root node down to the farthest leaf node.",
    "examples": [
      {
        "input": "root = \\[3,9,20,null,null,15,7\\]",
        "output": "3"
      },
      {
        "input": "root = \\[1,null,2\\]",
        "output": "2"
      }
    ],
    "constraints": [
      "The number of nodes in the tree is in the range `[0, 104]`.",
      "`-100 <= Node.val <= 100`"
    ],
    "companies": [
      {
        "name": "Amazon",
        "slug": "amazon",
        "frequency": 5
      },
      {
        "name": "LinkedIn",
        "slug": "linkedin",
        "frequency": 5
      },
      {
        "name": "Google",
        "slug": "google",
        "frequency": 4
      },
      {
        "name": "Meta",
        "slug": "facebook",
        "frequency": 4
      },
      {
        "name": "Bloomberg",
        "slug": "bloomberg",
        "frequency": 3
      },
      {
        "name": "Microsoft",
        "slug": "microsoft",
        "frequency": 3
      },
      {
        "name": "Arista Networks",
        "slug": "arista-networks",
        "frequency": 2
      },
      {
        "name": "Infosys",
        "slug": "infosys",
        "frequency": 2
      }
    ]
  },
  {
    "id": "105",
    "slug": "construct-binary-tree-from-preorder-and-inorder-traversal",
    "title": "Construct Binary Tree from Preorder and Inorder Traversal",
    "difficulty": "Medium",
    "description": "Given two integer arrays `preorder` and `inorder` where `preorder` is the preorder traversal of a binary tree and `inorder` is the inorder traversal of the same tree, construct and return _the binary tree_.",
    "examples": [
      {
        "input": "preorder = \\[3,9,20,15,7\\], inorder = \\[9,3,15,20,7\\]",
        "output": "\\[3,9,20,null,null,15,7\\]"
      },
      {
        "input": "preorder = \\[-1\\], inorder = \\[-1\\]",
        "output": "\\[-1\\]"
      }
    ],
    "constraints": [
      "`1 <= preorder.length <= 3000`",
      "`inorder.length == preorder.length`",
      "`-3000 <= preorder[i], inorder[i] <= 3000`",
      "`preorder` and `inorder` consist of unique values.",
      "Each value of `inorder` also appears in `preorder`.",
      "`preorder` is guaranteed to be the preorder traversal of the tree.",
      "`inorder` is guaranteed to be the inorder traversal of the tree."
    ],
    "companies": [
      {
        "name": "Amazon",
        "slug": "amazon",
        "frequency": 6
      },
      {
        "name": "Microsoft",
        "slug": "microsoft",
        "frequency": 6
      },
      {
        "name": "Google",
        "slug": "google",
        "frequency": 5
      },
      {
        "name": "Meta",
        "slug": "facebook",
        "frequency": 4
      },
      {
        "name": "Bloomberg",
        "slug": "bloomberg",
        "frequency": 2
      },
      {
        "name": "TikTok",
        "slug": "tiktok",
        "frequency": 2
      },
      {
        "name": "Snowflake",
        "slug": "snowflake",
        "frequency": 2
      }
    ]
  },
  {
    "id": "107",
    "slug": "binary-tree-level-order-traversal-ii",
    "title": "Binary Tree Level Order Traversal II",
    "difficulty": "Medium",
    "description": "Given the `root` of a binary tree, return _the bottom-up level order traversal of its nodes' values_. (i.e., from left to right, level by level from leaf to root).",
    "examples": [
      {
        "input": "root = \\[3,9,20,null,null,15,7\\]",
        "output": "\\[\\[15,7\\],\\[9,20\\],\\[3\\]\\]"
      },
      {
        "input": "root = \\[1\\]",
        "output": "\\[\\[1\\]\\]"
      },
      {
        "input": "root = \\[\\]",
        "output": "\\[\\]"
      }
    ],
    "constraints": [
      "The number of nodes in the tree is in the range `[0, 2000]`.",
      "`-1000 <= Node.val <= 1000`"
    ],
    "companies": []
  },
  {
    "id": "111",
    "slug": "minimum-depth-of-binary-tree",
    "title": "Minimum Depth of Binary Tree",
    "difficulty": "Easy",
    "description": "Given a binary tree, find its minimum depth. The minimum depth is the number of nodes along the shortest path from the root node down to the nearest leaf node.",
    "examples": [
      {
        "input": "root = \\[3,9,20,null,null,15,7\\]",
        "output": "2"
      },
      {
        "input": "root = \\[2,null,3,null,4,null,5,null,6\\]",
        "output": "5"
      }
    ],
    "constraints": [
      "The number of nodes in the tree is in the range `[0, 105]`.",
      "`-1000 <= Node.val <= 1000`"
    ],
    "companies": [
      {
        "name": "Meta",
        "slug": "facebook",
        "frequency": 3
      },
      {
        "name": "Google",
        "slug": "google",
        "frequency": 3
      },
      {
        "name": "Bloomberg",
        "slug": "bloomberg",
        "frequency": 2
      }
    ]
  },
  {
    "id": "112",
    "slug": "path-sum",
    "title": "Path Sum",
    "difficulty": "Easy",
    "description": "Given the `root` of a binary tree and an integer `targetSum`, return `true` if the tree has a **root-to-leaf** path such that adding up all the values along the path equals `targetSum`. A **leaf** is a node with no children.",
    "examples": [
      {
        "input": "root = \\[5,4,8,11,null,13,4,7,2,null,null,null,1\\], targetSum = 22",
        "output": "true",
        "explanation": "The root-to-leaf path with the target sum is shown."
      },
      {
        "input": "root = \\[1,2,3\\], targetSum = 5",
        "output": "false",
        "explanation": "There two root-to-leaf paths in the tree:"
      },
      {
        "input": "root = \\[\\], targetSum = 0",
        "output": "false",
        "explanation": "Since the tree is empty, there are no root-to-leaf paths."
      }
    ],
    "constraints": [
      "The number of nodes in the tree is in the range `[0, 5000]`.",
      "`-1000 <= Node.val <= 1000`",
      "`-1000 <= targetSum <= 1000`"
    ],
    "companies": [
      {
        "name": "Amazon",
        "slug": "amazon",
        "frequency": 5
      },
      {
        "name": "Microsoft",
        "slug": "microsoft",
        "frequency": 4
      },
      {
        "name": "Meta",
        "slug": "facebook",
        "frequency": 2
      },
      {
        "name": "Goldman Sachs",
        "slug": "goldman-sachs",
        "frequency": 2
      },
      {
        "name": "Google",
        "slug": "google",
        "frequency": 2
      }
    ]
  },
  {
    "id": "113",
    "slug": "path-sum-ii",
    "title": "Path Sum II",
    "difficulty": "Medium",
    "description": "Given the `root` of a binary tree and an integer `targetSum`, return _all **root-to-leaf** paths where the sum of the node values in the path equals_ `targetSum`_. Each path should be returned as a list of the node **values**, not node references_. A **root-to-leaf** path is a path starting from the root and ending at any leaf node. A **leaf** is a node with no children.",
    "examples": [
      {
        "input": "root = \\[5,4,8,11,null,13,4,7,2,null,null,5,1\\], targetSum = 22",
        "output": "\\[\\[5,4,11,2\\],\\[5,8,4,5\\]\\]",
        "explanation": "There are two paths whose sum equals targetSum:"
      },
      {
        "input": "root = \\[1,2,3\\], targetSum = 5",
        "output": "\\[\\]"
      },
      {
        "input": "root = \\[1,2\\], targetSum = 0",
        "output": "\\[\\]"
      }
    ],
    "constraints": [
      "The number of nodes in the tree is in the range `[0, 5000]`.",
      "`-1000 <= Node.val <= 1000`",
      "`-1000 <= targetSum <= 1000`"
    ],
    "companies": [
      {
        "name": "Meta",
        "slug": "facebook",
        "frequency": 3
      },
      {
        "name": "Microsoft",
        "slug": "microsoft",
        "frequency": 3
      },
      {
        "name": "Google",
        "slug": "google",
        "frequency": 3
      },
      {
        "name": "Amazon",
        "slug": "amazon",
        "frequency": 2
      },
      {
        "name": "Oracle",
        "slug": "oracle",
        "frequency": 2
      }
    ]
  },
  {
    "id": "121",
    "slug": "best-time-to-buy-and-sell-stock",
    "title": "Best Time to Buy and Sell Stock",
    "difficulty": "Easy",
    "description": "You are given an array `prices` where `prices[i]` is the price of a given stock on the `ith` day. You want to maximize your profit by choosing a **single day** to buy one stock and choosing a **different day in the future** to sell that stock. Return _the maximum profit you can achieve from this transaction_. If you cannot achieve any profit, return `0`.",
    "examples": [
      {
        "input": "prices = \\[7,1,5,3,6,4\\]",
        "output": "5",
        "explanation": "Buy on day 2 (price = 1) and sell on day 5 (price = 6), profit = 6-1 = 5."
      },
      {
        "input": "prices = \\[7,6,4,3,1\\]",
        "output": "0",
        "explanation": "In this case, no transactions are done and the max profit = 0."
      }
    ],
    "constraints": ["`1 <= prices.length <= 105`", "`0 <= prices[i] <= 104`"],
    "companies": [
      {
        "name": "Meta",
        "slug": "facebook",
        "frequency": 74
      },
      {
        "name": "Amazon",
        "slug": "amazon",
        "frequency": 60
      },
      {
        "name": "Google",
        "slug": "google",
        "frequency": 32
      },
      {
        "name": "Microsoft",
        "slug": "microsoft",
        "frequency": 18
      },
      {
        "name": "Apple",
        "slug": "apple",
        "frequency": 16
      },
      {
        "name": "Bloomberg",
        "slug": "bloomberg",
        "frequency": 13
      },
      {
        "name": "Zoho",
        "slug": "zoho",
        "frequency": 5
      },
      {
        "name": "Visa",
        "slug": "visa",
        "frequency": 4
      },
      {
        "name": "Accenture",
        "slug": "accenture",
        "frequency": 4
      },
      {
        "name": "Morgan Stanley",
        "slug": "morgan-stanley",
        "frequency": 3
      },
      {
        "name": "Nvidia",
        "slug": "nvidia",
        "frequency": 3
      },
      {
        "name": "IBM",
        "slug": "ibm",
        "frequency": 3
      },
      {
        "name": "Infosys",
        "slug": "infosys",
        "frequency": 3
      },
      {
        "name": "Agoda",
        "slug": "agoda",
        "frequency": 3
      },
      {
        "name": "Goldman Sachs",
        "slug": "goldman-sachs",
        "frequency": 3
      },
      {
        "name": "tcs",
        "slug": "tcs",
        "frequency": 3
      },
      {
        "name": "PayPal",
        "slug": "paypal",
        "frequency": 2
      },
      {
        "name": "Adobe",
        "slug": "adobe",
        "frequency": 2
      },
      {
        "name": "Zoox",
        "slug": "zoox",
        "frequency": 2
      },
      {
        "name": "Millennium",
        "slug": "millennium",
        "frequency": 2
      },
      {
        "name": "Salesforce",
        "slug": "salesforce",
        "frequency": 2
      },
      {
        "name": "Capital One",
        "slug": "capital-one",
        "frequency": 2
      },
      {
        "name": "ByteDance",
        "slug": "bytedance",
        "frequency": 2
      },
      {
        "name": "TikTok",
        "slug": "tiktok",
        "frequency": 2
      },
      {
        "name": "Bank of America",
        "slug": "bank-of-america",
        "frequency": 2
      },
      {
        "name": "Mastercard",
        "slug": "mastercard",
        "frequency": 2
      },
      {
        "name": "American Express",
        "slug": "american-express",
        "frequency": 2
      },
      {
        "name": "BlackRock",
        "slug": "blackrock",
        "frequency": 2
      },
      {
        "name": "Uber",
        "slug": "uber",
        "frequency": 2
      },
      {
        "name": "Citadel",
        "slug": "citadel",
        "frequency": 2
      },
      {
        "name": "Cisco",
        "slug": "cisco",
        "frequency": 2
      },
      {
        "name": "Deutsche Bank",
        "slug": "deutsche-bank",
        "frequency": 2
      },
      {
        "name": "Walmart Labs",
        "slug": "walmart-labs",
        "frequency": 2
      },
      {
        "name": "Atlassian",
        "slug": "atlassian",
        "frequency": 2
      },
      {
        "name": "ServiceNow",
        "slug": "servicenow",
        "frequency": 2
      },
      {
        "name": "PhonePe",
        "slug": "phonepe",
        "frequency": 2
      },
      {
        "name": "Bolt",
        "slug": "bolt",
        "frequency": 2
      },
      {
        "name": "Capgemini",
        "slug": "capgemini",
        "frequency": 2
      },
      {
        "name": "Remitly",
        "slug": "remitly",
        "frequency": 2
      },
      {
        "name": "Toast",
        "slug": "toast",
        "frequency": 2
      },
      {
        "name": "EPAM Systems",
        "slug": "epam-systems",
        "frequency": 2
      },
      {
        "name": "Squarepoint Capital",
        "slug": "squarepoint-capital",
        "frequency": 2
      },
      {
        "name": "Turing",
        "slug": "turing",
        "frequency": 2
      }
    ]
  },
  {
    "id": "124",
    "slug": "binary-tree-maximum-path-sum",
    "title": "Binary Tree Maximum Path Sum",
    "difficulty": "Hard",
    "description": "A **path** in a binary tree is a sequence of nodes where each pair of adjacent nodes in the sequence has an edge connecting them. A node can only appear in the sequence **at most once**. Note that the path does not need to pass through the root. The **path sum** of a path is the sum of the node's values in the path. Given the `root` of a binary tree, return _the maximum **path sum** of any **non-empty** path_.",
    "examples": [
      {
        "input": "root = \\[1,2,3\\]",
        "output": "6",
        "explanation": "The optimal path is 2 -> 1 -> 3 with a path sum of 2 + 1 + 3 = 6."
      },
      {
        "input": "root = \\[-10,9,20,null,null,15,7\\]",
        "output": "42",
        "explanation": "The optimal path is 15 -> 20 -> 7 with a path sum of 15 + 20 + 7 = 42."
      }
    ],
    "constraints": [
      "The number of nodes in the tree is in the range `[1, 3  104]`.",
      "`-1000 <= Node.val <= 1000`"
    ],
    "companies": [
      {
        "name": "DoorDash",
        "slug": "doordash",
        "frequency": 25
      },
      {
        "name": "Meta",
        "slug": "facebook",
        "frequency": 14
      },
      {
        "name": "Amazon",
        "slug": "amazon",
        "frequency": 10
      },
      {
        "name": "Google",
        "slug": "google",
        "frequency": 9
      },
      {
        "name": "Microsoft",
        "slug": "microsoft",
        "frequency": 5
      },
      {
        "name": "Oracle",
        "slug": "oracle",
        "frequency": 3
      },
      {
        "name": "Yandex",
        "slug": "yandex",
        "frequency": 3
      },
      {
        "name": "Salesforce",
        "slug": "salesforce",
        "frequency": 3
      },
      {
        "name": "Bloomberg",
        "slug": "bloomberg",
        "frequency": 2
      },
      {
        "name": "TikTok",
        "slug": "tiktok",
        "frequency": 2
      },
      {
        "name": "Nutanix",
        "slug": "nutanix",
        "frequency": 2
      },
      {
        "name": "tcs",
        "slug": "tcs",
        "frequency": 2
      },
      {
        "name": "Datadog",
        "slug": "datadog",
        "frequency": 2
      }
    ]
  },
  {
    "id": "128",
    "slug": "longest-consecutive-sequence",
    "title": "Longest Consecutive Sequence",
    "difficulty": "Medium",
    "description": "Given an unsorted array of integers `nums`, return _the length of the longest consecutive elements sequence._ You must write an algorithm that runs in `O(n)` time.",
    "examples": [
      {
        "input": "nums = \\[100,4,200,1,3,2\\]",
        "output": "4",
        "explanation": "The longest consecutive elements sequence is `[1, 2, 3, 4]`. Therefore its length is 4."
      },
      {
        "input": "nums = \\[0,3,7,2,5,8,4,6,0,1\\]",
        "output": "9"
      }
    ],
    "constraints": ["`0 <= nums.length <= 105`", "`-109 <= nums[i] <= 109`"],
    "companies": [
      {
        "name": "Amazon",
        "slug": "amazon",
        "frequency": 26
      },
      {
        "name": "Google",
        "slug": "google",
        "frequency": 22
      },
      {
        "name": "Bloomberg",
        "slug": "bloomberg",
        "frequency": 9
      },
      {
        "name": "Meta",
        "slug": "facebook",
        "frequency": 6
      },
      {
        "name": "IBM",
        "slug": "ibm",
        "frequency": 4
      },
      {
        "name": "Walmart Labs",
        "slug": "walmart-labs",
        "frequency": 4
      },
      {
        "name": "Microsoft",
        "slug": "microsoft",
        "frequency": 3
      },
      {
        "name": "Uber",
        "slug": "uber",
        "frequency": 3
      },
      {
        "name": "Oracle",
        "slug": "oracle",
        "frequency": 2
      },
      {
        "name": "Apple",
        "slug": "apple",
        "frequency": 2
      },
      {
        "name": "Goldman Sachs",
        "slug": "goldman-sachs",
        "frequency": 2
      },
      {
        "name": "TikTok",
        "slug": "tiktok",
        "frequency": 2
      },
      {
        "name": "PayPal",
        "slug": "paypal",
        "frequency": 2
      },
      {
        "name": "ByteDance",
        "slug": "bytedance",
        "frequency": 2
      },
      {
        "name": "Cisco",
        "slug": "cisco",
        "frequency": 2
      },
      {
        "name": "Infosys",
        "slug": "infosys",
        "frequency": 2
      },
      {
        "name": "EPAM Systems",
        "slug": "epam-systems",
        "frequency": 2
      }
    ]
  },
  {
    "id": "131",
    "slug": "palindrome-partitioning",
    "title": "Palindrome Partitioning",
    "difficulty": "Medium",
    "description": "Given a string `s`, partition `s` such that every substring of the partition is a **palindrome**. Return _all possible palindrome partitioning of_ `s`.",
    "examples": [
      {
        "input": "s = \"aab\"",
        "output": "\\[\\[\"a\",\"a\",\"b\"\\],\\[\"aa\",\"b\"\\]\\]"
      },
      {
        "input": "s = \"a\"",
        "output": "\\[\\[\"a\"\\]\\]"
      }
    ],
    "constraints": [
      "`1 <= s.length <= 16`",
      "`s` contains only lowercase English letters."
    ],
    "companies": [
      {
        "name": "Amazon",
        "slug": "amazon",
        "frequency": 10
      },
      {
        "name": "Google",
        "slug": "google",
        "frequency": 10
      },
      {
        "name": "Meta",
        "slug": "facebook",
        "frequency": 4
      },
      {
        "name": "Microsoft",
        "slug": "microsoft",
        "frequency": 2
      },
      {
        "name": "Bloomberg",
        "slug": "bloomberg",
        "frequency": 2
      }
    ]
  },
  {
    "id": "134",
    "slug": "gas-station",
    "title": "Gas Station",
    "difficulty": "Medium",
    "description": "There are `n` gas stations along a circular route, where the amount of gas at the `ith` station is `gas[i]`. You have a car with an unlimited gas tank and it costs `cost[i]` of gas to travel from the `ith` station to its next `(i + 1)th` station. You begin the journey with an empty tank at one of the gas stations. Given two integer arrays `gas` and `cost`, return _the starting gas station's index if you can travel around the circuit once in the clockwise direction, otherwise return_ `-1`. If there exists a solution, it is **guaranteed** to be **unique**",
    "examples": [
      {
        "input": "gas = \\[1,2,3,4,5\\], cost = \\[3,4,5,1,2\\]",
        "output": "3",
        "explanation": ""
      },
      {
        "input": "gas = \\[2,3,4\\], cost = \\[3,4,3\\]",
        "output": "-1",
        "explanation": ""
      }
    ],
    "constraints": [
      "`n == gas.length == cost.length`",
      "`1 <= n <= 105`",
      "`0 <= gas[i], cost[i] <= 104`"
    ],
    "companies": [
      {
        "name": "Amazon",
        "slug": "amazon",
        "frequency": 9
      },
      {
        "name": "Google",
        "slug": "google",
        "frequency": 6
      },
      {
        "name": "Bloomberg",
        "slug": "bloomberg",
        "frequency": 4
      },
      {
        "name": "Microsoft",
        "slug": "microsoft",
        "frequency": 3
      },
      {
        "name": "Oracle",
        "slug": "oracle",
        "frequency": 3
      },
      {
        "name": "BitGo",
        "slug": "bitgo",
        "frequency": 3
      },
      {
        "name": "TikTok",
        "slug": "tiktok",
        "frequency": 3
      },
      {
        "name": "Flipkart",
        "slug": "flipkart",
        "frequency": 2
      },
      {
        "name": "Meta",
        "slug": "facebook",
        "frequency": 2
      },
      {
        "name": "Adobe",
        "slug": "adobe",
        "frequency": 2
      },
      {
        "name": "Salesforce",
        "slug": "salesforce",
        "frequency": 2
      },
      {
        "name": "Freecharge",
        "slug": "freecharge",
        "frequency": 2
      },
      {
        "name": "ServiceNow",
        "slug": "servicenow",
        "frequency": 2
      }
    ]
  },
  {
    "id": "136",
    "slug": "single-number",
    "title": "Single Number",
    "difficulty": "Easy",
    "description": "Given a **non-empty** array of integers `nums`, every element appears _twice_ except for one. Find that single one. You must implement a solution with a linear runtime complexity and use only constant extra space.",
    "examples": [
      {
        "input": "nums = \\[2,2,1\\]",
        "output": "1"
      },
      {
        "input": "nums = \\[4,1,2,1,2\\]",
        "output": "4"
      },
      {
        "input": "nums = \\[1\\]",
        "output": "1"
      }
    ],
    "constraints": [
      "`1 <= nums.length <= 3  104`",
      "`-3  104 <= nums[i] <= 3  104`",
      "Each element in the array appears twice except for one element which appears only once."
    ],
    "companies": [
      {
        "name": "Google",
        "slug": "google",
        "frequency": 20
      },
      {
        "name": "Amazon",
        "slug": "amazon",
        "frequency": 8
      },
      {
        "name": "Microsoft",
        "slug": "microsoft",
        "frequency": 5
      },
      {
        "name": "Meta",
        "slug": "facebook",
        "frequency": 4
      },
      {
        "name": "tcs",
        "slug": "tcs",
        "frequency": 4
      },
      {
        "name": "Bloomberg",
        "slug": "bloomberg",
        "frequency": 3
      },
      {
        "name": "Qualcomm",
        "slug": "qualcomm",
        "frequency": 2
      },
      {
        "name": "Accenture",
        "slug": "accenture",
        "frequency": 2
      }
    ]
  },
  {
    "id": "139",
    "slug": "word-break",
    "title": "Word Break",
    "difficulty": "Medium",
    "description": "Given a string `s` and a dictionary of strings `wordDict`, return `true` if `s` can be segmented into a space-separated sequence of one or more dictionary words. **Note** that the same word in the dictionary may be reused multiple times in the segmentation.",
    "examples": [
      {
        "input": "s =  \"leetcode \", wordDict = \\[ \"leet \", \"code \"\\]",
        "output": "true",
        "explanation": "Return true because  \"leetcode \" can be segmented as  \"leet code \"."
      },
      {
        "input": "s =  \"applepenapple \", wordDict = \\[ \"apple \", \"pen \"\\]",
        "output": "true",
        "explanation": "Return true because  \"applepenapple \" can be segmented as  \"apple pen apple \"."
      },
      {
        "input": "s =  \"catsandog \", wordDict = \\[ \"cats \", \"dog \", \"sand \", \"and \", \"cat \"\\]",
        "output": "false"
      }
    ],
    "constraints": [
      "`1 <= s.length <= 300`",
      "`1 <= wordDict.length <= 1000`",
      "`1 <= wordDict[i].length <= 20`",
      "`s` and `wordDict[i]` consist of only lowercase English letters.",
      "All the strings of `wordDict` are unique."
    ],
    "companies": [
      {
        "name": "Meta",
        "slug": "facebook",
        "frequency": 21
      },
      {
        "name": "Amazon",
        "slug": "amazon",
        "frequency": 19
      },
      {
        "name": "Google",
        "slug": "google",
        "frequency": 7
      },
      {
        "name": "Microsoft",
        "slug": "microsoft",
        "frequency": 6
      },
      {
        "name": "TikTok",
        "slug": "tiktok",
        "frequency": 5
      },
      {
        "name": "Walmart Labs",
        "slug": "walmart-labs",
        "frequency": 3
      },
      {
        "name": "MongoDB",
        "slug": "mongodb",
        "frequency": 3
      },
      {
        "name": "Bloomberg",
        "slug": "bloomberg",
        "frequency": 2
      },
      {
        "name": "Netflix",
        "slug": "netflix",
        "frequency": 2
      },
      {
        "name": "LinkedIn",
        "slug": "linkedin",
        "frequency": 2
      },
      {
        "name": "Salesforce",
        "slug": "salesforce",
        "frequency": 2
      },
      {
        "name": "Nutanix",
        "slug": "nutanix",
        "frequency": 2
      },
      {
        "name": "Intuit",
        "slug": "intuit",
        "frequency": 2
      },
      {
        "name": "Grammarly",
        "slug": "grammarly",
        "frequency": 2
      },
      {
        "name": "BuyHatke",
        "slug": "buyhatke",
        "frequency": 2
      }
    ]
  },
  {
    "id": "141",
    "slug": "linked-list-cycle",
    "title": "Linked List Cycle",
    "difficulty": "Easy",
    "description": "Given `head`, the head of a linked list, determine if the linked list has a cycle in it. There is a cycle in a linked list if there is some node in the list that can be reached again by continuously following the `next` pointer. Internally, `pos` is used to denote the index of the node that tail's `next` pointer is connected to. **Note that `pos` is not passed as a parameter**. Return `true` _if there is a cycle in the linked list_. Otherwise, return `false`.",
    "examples": [
      {
        "input": "head = \\[3,2,0,-4\\], pos = 1",
        "output": "true",
        "explanation": "There is a cycle in the linked list, where the tail connects to the 1st node (0-indexed)."
      },
      {
        "input": "head = \\[1,2\\], pos = 0",
        "output": "true",
        "explanation": "There is a cycle in the linked list, where the tail connects to the 0th node."
      },
      {
        "input": "head = \\[1\\], pos = -1",
        "output": "false",
        "explanation": "There is no cycle in the linked list."
      }
    ],
    "constraints": [
      "The number of the nodes in the list is in the range `[0, 104]`.",
      "`-105 <= Node.val <= 105`",
      "`pos` is `-1` or a valid index in the linked-list.",
      "Follow up: Can you solve it using `O(1)` (i.e. constant) memory?"
    ],
    "companies": [
      {
        "name": "Google",
        "slug": "google",
        "frequency": 6
      },
      {
        "name": "Meta",
        "slug": "facebook",
        "frequency": 4
      },
      {
        "name": "Microsoft",
        "slug": "microsoft",
        "frequency": 2
      },
      {
        "name": "Amazon",
        "slug": "amazon",
        "frequency": 2
      },
      {
        "name": "Bloomberg",
        "slug": "bloomberg",
        "frequency": 2
      },
      {
        "name": "Goldman Sachs",
        "slug": "goldman-sachs",
        "frequency": 2
      },
      {
        "name": "Qualcomm",
        "slug": "qualcomm",
        "frequency": 2
      },
      {
        "name": "Cisco",
        "slug": "cisco",
        "frequency": 2
      },
      {
        "name": "Oracle",
        "slug": "oracle",
        "frequency": 2
      },
      {
        "name": "tcs",
        "slug": "tcs",
        "frequency": 2
      }
    ]
  },
  {
    "id": "142",
    "slug": "linked-list-cycle-ii",
    "title": "Linked List Cycle II",
    "difficulty": "Medium",
    "description": "Given the `head` of a linked list, return _the node where the cycle begins. If there is no cycle, return_ `null`. There is a cycle in a linked list if there is some node in the list that can be reached again by continuously following the `next` pointer. Internally, `pos` is used to denote the index of the node that tail's `next` pointer is connected to (**0-indexed**). It is `-1` if there is no cycle. **Note that** `pos` **is not passed as a parameter**. **Do not modify** the linked list.",
    "examples": [
      {
        "input": "head = \\[3,2,0,-4\\], pos = 1",
        "output": "tail connects to node index 1",
        "explanation": "There is a cycle in the linked list, where tail connects to the second node."
      },
      {
        "input": "head = \\[1,2\\], pos = 0",
        "output": "tail connects to node index 0",
        "explanation": "There is a cycle in the linked list, where tail connects to the first node."
      },
      {
        "input": "head = \\[1\\], pos = -1",
        "output": "no cycle",
        "explanation": "There is no cycle in the linked list."
      }
    ],
    "constraints": [
      "The number of the nodes in the list is in the range `[0, 104]`.",
      "`-105 <= Node.val <= 105`",
      "`pos` is `-1` or a valid index in the linked-list.",
      "Follow up: Can you solve it using `O(1)` (i.e. constant) memory?"
    ],
    "companies": [
      {
        "name": "Google",
        "slug": "google",
        "frequency": 6
      },
      {
        "name": "Amazon",
        "slug": "amazon",
        "frequency": 3
      },
      {
        "name": "Meta",
        "slug": "facebook",
        "frequency": 3
      },
      {
        "name": "Microsoft",
        "slug": "microsoft",
        "frequency": 2
      }
    ]
  },
  {
    "id": "143",
    "slug": "reorder-list",
    "title": "Reorder List",
    "difficulty": "Medium",
    "description": "You are given the head of a singly linked-list. The list can be represented as: L0 -> L1 -> ... -> Ln - 1 -> Ln _Reorder the list to be on the following form:_ L0 -> Ln -> L1 -> Ln - 1 -> L2 -> Ln - 2 -> ... You may not modify the values in the list's nodes. Only nodes themselves may be changed.",
    "examples": [
      {
        "input": "head = \\[1,2,3,4\\]",
        "output": "\\[1,4,2,3\\]"
      },
      {
        "input": "head = \\[1,2,3,4,5\\]",
        "output": "\\[1,5,2,4,3\\]"
      }
    ],
    "constraints": [
      "The number of nodes in the list is in the range `[1, 5  104]`.",
      "`1 <= Node.val <= 1000`"
    ],
    "companies": [
      {
        "name": "Google",
        "slug": "google",
        "frequency": 8
      },
      {
        "name": "Amazon",
        "slug": "amazon",
        "frequency": 7
      },
      {
        "name": "Microsoft",
        "slug": "microsoft",
        "frequency": 4
      },
      {
        "name": "TikTok",
        "slug": "tiktok",
        "frequency": 4
      },
      {
        "name": "Meta",
        "slug": "facebook",
        "frequency": 2
      },
      {
        "name": "Bloomberg",
        "slug": "bloomberg",
        "frequency": 2
      },
      {
        "name": "Arista Networks",
        "slug": "arista-networks",
        "frequency": 2
      },
      {
        "name": "Apple",
        "slug": "apple",
        "frequency": 2
      },
      {
        "name": "Goldman Sachs",
        "slug": "goldman-sachs",
        "frequency": 2
      }
    ]
  },
  {
    "id": "148",
    "slug": "sort-list",
    "title": "Sort List",
    "difficulty": "Medium",
    "description": "Given the `head` of a linked list, return _the list after sorting it in **ascending order**_.",
    "examples": [
      {
        "input": "head = \\[4,2,1,3\\]",
        "output": "\\[1,2,3,4\\]"
      },
      {
        "input": "head = \\[-1,5,3,4,0\\]",
        "output": "\\[-1,0,3,4,5\\]"
      },
      {
        "input": "head = \\[\\]",
        "output": "\\[\\]"
      }
    ],
    "constraints": [
      "The number of nodes in the list is in the range `[0, 5  104]`.",
      "`-105 <= Node.val <= 105`",
      "Follow up: Can you sort the linked list in `O(n logn)` time and `O(1)` memory (i.e. constant space)?"
    ],
    "companies": [
      {
        "name": "Google",
        "slug": "google",
        "frequency": 9
      },
      {
        "name": "Meta",
        "slug": "facebook",
        "frequency": 6
      },
      {
        "name": "Amazon",
        "slug": "amazon",
        "frequency": 3
      },
      {
        "name": "Lyft",
        "slug": "lyft",
        "frequency": 3
      },
      {
        "name": "Microsoft",
        "slug": "microsoft",
        "frequency": 2
      },
      {
        "name": "TikTok",
        "slug": "tiktok",
        "frequency": 2
      }
    ]
  },
  {
    "id": "152",
    "slug": "maximum-product-subarray",
    "title": "Maximum Product Subarray",
    "difficulty": "Medium",
    "description": "Given an integer array `nums`, find a subarray that has the largest product, and return _the product_. The test cases are generated so that the answer will fit in a **32-bit** integer.",
    "examples": [
      {
        "input": "nums = \\[2,3,-2,4\\]",
        "output": "6",
        "explanation": "\\[2,3\\] has the largest product 6."
      },
      {
        "input": "nums = \\[-2,0,-1\\]",
        "output": "0",
        "explanation": "The result cannot be 2, because \\[-2,-1\\] is not a subarray."
      }
    ],
    "constraints": [
      "`1 <= nums.length <= 2  104`",
      "`-10 <= nums[i] <= 10`",
      "The product of any prefix or suffix of `nums` is guaranteed to fit in a 32-bit integer."
    ],
    "companies": [
      {
        "name": "Google",
        "slug": "google",
        "frequency": 10
      },
      {
        "name": "Amazon",
        "slug": "amazon",
        "frequency": 8
      },
      {
        "name": "LinkedIn",
        "slug": "linkedin",
        "frequency": 7
      },
      {
        "name": "Microsoft",
        "slug": "microsoft",
        "frequency": 6
      },
      {
        "name": "Goldman Sachs",
        "slug": "goldman-sachs",
        "frequency": 4
      },
      {
        "name": "Bloomberg",
        "slug": "bloomberg",
        "frequency": 3
      },
      {
        "name": "TikTok",
        "slug": "tiktok",
        "frequency": 3
      },
      {
        "name": "Adobe",
        "slug": "adobe",
        "frequency": 2
      },
      {
        "name": "DE Shaw",
        "slug": "de-shaw",
        "frequency": 2
      },
      {
        "name": "Meta",
        "slug": "facebook",
        "frequency": 2
      },
      {
        "name": "Wayfair",
        "slug": "wayfair",
        "frequency": 2
      }
    ]
  },
  {
    "id": "153",
    "slug": "find-minimum-in-rotated-sorted-array",
    "title": "Find Minimum in Rotated Sorted Array",
    "difficulty": "Medium",
    "description": "Suppose an array of length `n` sorted in ascending order is **rotated** between `1` and `n` times. For example, the array `nums = [0,1,2,4,5,6,7]` might become: *  `[4,5,6,7,0,1,2]` if it was rotated `4` times. *  `[0,1,2,4,5,6,7]` if it was rotated `7` times. Notice that **rotating** an array `[a[0], a[1], a[2], ..., a[n-1]]` 1 time results in the array `[a[n-1], a[0], a[1], a[2], ..., a[n-2]]`. Given the sorted rotated array `nums` of **unique** elements, return _the minimum element of this array_. You must write an algorithm that runs in `O(log n) time.`",
    "examples": [
      {
        "input": "nums = \\[3,4,5,1,2\\]",
        "output": "1",
        "explanation": "The original array was \\[1,2,3,4,5\\] rotated 3 times."
      },
      {
        "input": "nums = \\[4,5,6,7,0,1,2\\]",
        "output": "0",
        "explanation": "The original array was \\[0,1,2,4,5,6,7\\] and it was rotated 4 times."
      },
      {
        "input": "nums = \\[11,13,15,17\\]",
        "output": "11",
        "explanation": "The original array was \\[11,13,15,17\\] and it was rotated 4 times."
      }
    ],
    "constraints": [
      "`n == nums.length`",
      "`1 <= n <= 5000`",
      "`-5000 <= nums[i] <= 5000`",
      "All the integers of `nums` are unique.",
      "`nums` is sorted and rotated between `1` and `n` times."
    ],
    "companies": [
      {
        "name": "Goldman Sachs",
        "slug": "goldman-sachs",
        "frequency": 6
      },
      {
        "name": "Amazon",
        "slug": "amazon",
        "frequency": 5
      },
      {
        "name": "Meta",
        "slug": "facebook",
        "frequency": 5
      },
      {
        "name": "Google",
        "slug": "google",
        "frequency": 4
      },
      {
        "name": "Microsoft",
        "slug": "microsoft",
        "frequency": 4
      },
      {
        "name": "TikTok",
        "slug": "tiktok",
        "frequency": 4
      },
      {
        "name": "Uber",
        "slug": "uber",
        "frequency": 3
      },
      {
        "name": "Bloomberg",
        "slug": "bloomberg",
        "frequency": 2
      },
      {
        "name": "Yandex",
        "slug": "yandex",
        "frequency": 2
      },
      {
        "name": "Apple",
        "slug": "apple",
        "frequency": 2
      },
      {
        "name": "Walmart Labs",
        "slug": "walmart-labs",
        "frequency": 2
      }
    ]
  },
  {
    "id": "162",
    "slug": "find-peak-element",
    "title": "Find Peak Element",
    "difficulty": "Medium",
    "description": "A peak element is an element that is strictly greater than its neighbors. Given a **0-indexed** integer array `nums`, find a peak element, and return its index. If the array contains multiple peaks, return the index to **any of the peaks**. You may imagine that `nums[-1] = nums[n] = -\u221e`. In other words, an element is always considered to be strictly greater than a neighbor that is outside the array. You must write an algorithm that runs in `O(log n)` time.",
    "examples": [
      {
        "input": "nums = \\[1,2,3,1\\]",
        "output": "2",
        "explanation": "3 is a peak element and your function should return the index number 2."
      },
      {
        "input": "nums = \\[1,2,1,3,5,6,4\\]",
        "output": "5",
        "explanation": "Your function can return either index number 1 where the peak element is 2, or index number 5 where the peak element is 6."
      }
    ],
    "constraints": [
      "`1 <= nums.length <= 1000`",
      "`-231 <= nums[i] <= 231 - 1`",
      "`nums[i] != nums[i + 1]` for all valid `i`."
    ],
    "companies": [
      {
        "name": "Meta",
        "slug": "facebook",
        "frequency": 127
      },
      {
        "name": "Google",
        "slug": "google",
        "frequency": 17
      },
      {
        "name": "Microsoft",
        "slug": "microsoft",
        "frequency": 11
      },
      {
        "name": "Bloomberg",
        "slug": "bloomberg",
        "frequency": 9
      },
      {
        "name": "Amazon",
        "slug": "amazon",
        "frequency": 9
      },
      {
        "name": "Uber",
        "slug": "uber",
        "frequency": 5
      },
      {
        "name": "Goldman Sachs",
        "slug": "goldman-sachs",
        "frequency": 2
      },
      {
        "name": "TikTok",
        "slug": "tiktok",
        "frequency": 2
      },
      {
        "name": "Visa",
        "slug": "visa",
        "frequency": 2
      },
      {
        "name": "Waymo",
        "slug": "waymo",
        "frequency": 2
      },
      {
        "name": "eBay",
        "slug": "ebay",
        "frequency": 2
      },
      {
        "name": "IXL",
        "slug": "ixl",
        "frequency": 2
      },
      {
        "name": "Flipkart",
        "slug": "flipkart",
        "frequency": 2
      },
      {
        "name": "Commvault",
        "slug": "commvault",
        "frequency": 2
      },
      {
        "name": "Oracle",
        "slug": "oracle",
        "frequency": 2
      },
      {
        "name": "Wix",
        "slug": "wix",
        "frequency": 2
      }
    ]
  },
  {
    "id": "169",
    "slug": "majority-element",
    "title": "Majority Element",
    "difficulty": "Easy",
    "description": "Given an array `nums` of size `n`, return _the majority element_. The majority element is the element that appears more than `\u230an / 2\u230b` times. You may assume that the majority element always exists in the array.",
    "examples": [
      {
        "input": "nums = \\[3,2,3\\]",
        "output": "3"
      },
      {
        "input": "nums = \\[2,2,1,1,1,2,2\\]",
        "output": "2"
      }
    ],
    "constraints": [
      "`n == nums.length`",
      "`1 <= n <= 5  104`",
      "`-109 <= nums[i] <= 109`"
    ],
    "companies": [
      {
        "name": "Google",
        "slug": "google",
        "frequency": 28
      },
      {
        "name": "Amazon",
        "slug": "amazon",
        "frequency": 17
      },
      {
        "name": "Microsoft",
        "slug": "microsoft",
        "frequency": 14
      },
      {
        "name": "Meta",
        "slug": "facebook",
        "frequency": 9
      },
      {
        "name": "Bloomberg",
        "slug": "bloomberg",
        "frequency": 8
      },
      {
        "name": "tcs",
        "slug": "tcs",
        "frequency": 4
      },
      {
        "name": "Accenture",
        "slug": "accenture",
        "frequency": 3
      },
      {
        "name": "DE Shaw",
        "slug": "de-shaw",
        "frequency": 3
      },
      {
        "name": "Oracle",
        "slug": "oracle",
        "frequency": 2
      },
      {
        "name": "Qualcomm",
        "slug": "qualcomm",
        "frequency": 2
      },
      {
        "name": "Autodesk",
        "slug": "autodesk",
        "frequency": 2
      },
      {
        "name": "Zoho",
        "slug": "zoho",
        "frequency": 2
      }
    ]
  },
  {
    "id": "198",
    "slug": "house-robber",
    "title": "House Robber",
    "difficulty": "Medium",
    "description": "You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed, the only constraint stopping you from robbing each of them is that adjacent houses have security systems connected and **it will automatically contact the police if two adjacent houses were broken into on the same night**. Given an integer array `nums` representing the amount of money of each house, return _the maximum amount of money you can rob tonight **without alerting the police**_.",
    "examples": [
      {
        "input": "nums = \\[1,2,3,1\\]",
        "output": "4",
        "explanation": "Rob house 1 (money = 1) and then rob house 3 (money = 3)."
      },
      {
        "input": "nums = \\[2,7,9,3,1\\]",
        "output": "12",
        "explanation": "Rob house 1 (money = 2), rob house 3 (money = 9) and rob house 5 (money = 1)."
      }
    ],
    "constraints": ["`1 <= nums.length <= 100`", "`0 <= nums[i] <= 400`"],
    "companies": [
      {
        "name": "Amazon",
        "slug": "amazon",
        "frequency": 26
      },
      {
        "name": "Google",
        "slug": "google",
        "frequency": 18
      },
      {
        "name": "Cisco",
        "slug": "cisco",
        "frequency": 12
      },
      {
        "name": "Databricks",
        "slug": "databricks",
        "frequency": 7
      },
      {
        "name": "Microsoft",
        "slug": "microsoft",
        "frequency": 6
      },
      {
        "name": "TikTok",
        "slug": "tiktok",
        "frequency": 6
      },
      {
        "name": "Uber",
        "slug": "uber",
        "frequency": 6
      },
      {
        "name": "Meta",
        "slug": "facebook",
        "frequency": 5
      },
      {
        "name": "PhonePe",
        "slug": "phonepe",
        "frequency": 4
      },
      {
        "name": "Bloomberg",
        "slug": "bloomberg",
        "frequency": 3
      },
      {
        "name": "Oracle",
        "slug": "oracle",
        "frequency": 3
      },
      {
        "name": "PayPal",
        "slug": "paypal",
        "frequency": 3
      },
      {
        "name": "Goldman Sachs",
        "slug": "goldman-sachs",
        "frequency": 2
      },
      {
        "name": "tcs",
        "slug": "tcs",
        "frequency": 2
      },
      {
        "name": "Adobe",
        "slug": "adobe",
        "frequency": 2
      },
      {
        "name": "Walmart Labs",
        "slug": "walmart-labs",
        "frequency": 2
      },
      {
        "name": "Flipkart",
        "slug": "flipkart",
        "frequency": 2
      },
      {
        "name": "Zoho",
        "slug": "zoho",
        "frequency": 2
      },
      {
        "name": "EPAM Systems",
        "slug": "epam-systems",
        "frequency": 2
      },
      {
        "name": "Intuit",
        "slug": "intuit",
        "frequency": 2
      },
      {
        "name": "DE Shaw",
        "slug": "de-shaw",
        "frequency": 2
      }
    ]
  },
  {
    "id": "199",
    "slug": "binary-tree-right-side-view",
    "title": "Binary Tree Right Side View",
    "difficulty": "Medium",
    "description": "Given the `root` of a binary tree, imagine yourself standing on the **right side** of it, return _the values of the nodes you can see ordered from top to bottom_.",
    "examples": [
      {
        "input": "root = \\[1,2,3,null,5,null,4\\]",
        "output": "\\[1,3,4\\]"
      },
      {
        "input": "root = \\[1,null,3\\]",
        "output": "\\[1,3\\]"
      },
      {
        "input": "root = \\[\\]",
        "output": "\\[\\]"
      }
    ],
    "constraints": [
      "The number of nodes in the tree is in the range `[0, 100]`.",
      "`-100 <= Node.val <= 100`"
    ],
    "companies": [
      {
        "name": "Meta",
        "slug": "facebook",
        "frequency": 122
      },
      {
        "name": "Amazon",
        "slug": "amazon",
        "frequency": 13
      },
      {
        "name": "Google",
        "slug": "google",
        "frequency": 5
      },
      {
        "name": "Oracle",
        "slug": "oracle",
        "frequency": 5
      },
      {
        "name": "Yandex",
        "slug": "yandex",
        "frequency": 5
      },
      {
        "name": "Bloomberg",
        "slug": "bloomberg",
        "frequency": 5
      },
      {
        "name": "Microsoft",
        "slug": "microsoft",
        "frequency": 4
      },
      {
        "name": "Walmart Labs",
        "slug": "walmart-labs",
        "frequency": 4
      },
      {
        "name": "TikTok",
        "slug": "tiktok",
        "frequency": 3
      },
      {
        "name": "Uber",
        "slug": "uber",
        "frequency": 2
      },
      {
        "name": "ServiceNow",
        "slug": "servicenow",
        "frequency": 2
      }
    ]
  },
  {
    "id": "200",
    "slug": "number-of-islands",
    "title": "Number of Islands",
    "difficulty": "Medium",
    "description": "Given an `m x n` 2D binary grid `grid` which represents a map of `'1'`s (land) and `'0'`s (water), return _the number of islands_. An **island** is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are all surrounded by water.",
    "examples": [
      {
        "input": "grid = \\[",
        "output": "1"
      },
      {
        "input": "grid = \\[",
        "output": "3"
      }
    ],
    "constraints": [
      "`m == grid.length`",
      "`n == grid[i].length`",
      "`1 <= m, n <= 300`",
      "`grid[i][j]` is `'0'` or `'1'`."
    ],
    "companies": [
      {
        "name": "Amazon",
        "slug": "amazon",
        "frequency": 88
      },
      {
        "name": "Google",
        "slug": "google",
        "frequency": 21
      },
      {
        "name": "Bloomberg",
        "slug": "bloomberg",
        "frequency": 20
      },
      {
        "name": "LinkedIn",
        "slug": "linkedin",
        "frequency": 18
      },
      {
        "name": "Meta",
        "slug": "facebook",
        "frequency": 16
      },
      {
        "name": "Uber",
        "slug": "uber",
        "frequency": 13
      },
      {
        "name": "TikTok",
        "slug": "tiktok",
        "frequency": 13
      },
      {
        "name": "Microsoft",
        "slug": "microsoft",
        "frequency": 10
      },
      {
        "name": "Oracle",
        "slug": "oracle",
        "frequency": 10
      },
      {
        "name": "Goldman Sachs",
        "slug": "goldman-sachs",
        "frequency": 8
      },
      {
        "name": "Apple",
        "slug": "apple",
        "frequency": 7
      },
      {
        "name": "Anduril",
        "slug": "anduril",
        "frequency": 6
      },
      {
        "name": "Snap",
        "slug": "snapchat",
        "frequency": 5
      },
      {
        "name": "Walmart Labs",
        "slug": "walmart-labs",
        "frequency": 5
      },
      {
        "name": "Zoho",
        "slug": "zoho",
        "frequency": 5
      },
      {
        "name": "Samsung",
        "slug": "samsung",
        "frequency": 5
      },
      {
        "name": "Salesforce",
        "slug": "salesforce",
        "frequency": 5
      },
      {
        "name": "PayPal",
        "slug": "paypal",
        "frequency": 3
      },
      {
        "name": "Visa",
        "slug": "visa",
        "frequency": 3
      },
      {
        "name": "Qualcomm",
        "slug": "qualcomm",
        "frequency": 3
      },
      {
        "name": "eBay",
        "slug": "ebay",
        "frequency": 3
      },
      {
        "name": "Tinkoff",
        "slug": "tinkoff",
        "frequency": 3
      },
      {
        "name": "SAP",
        "slug": "sap",
        "frequency": 2
      },
      {
        "name": "Nvidia",
        "slug": "nvidia",
        "frequency": 2
      },
      {
        "name": "Citadel",
        "slug": "citadel",
        "frequency": 2
      },
      {
        "name": "Tesla",
        "slug": "tesla",
        "frequency": 2
      },
      {
        "name": "Yandex",
        "slug": "yandex",
        "frequency": 2
      },
      {
        "name": "Accenture",
        "slug": "accenture",
        "frequency": 2
      },
      {
        "name": "Wix",
        "slug": "wix",
        "frequency": 2
      },
      {
        "name": "BitGo",
        "slug": "bitgo",
        "frequency": 2
      },
      {
        "name": "Grammarly",
        "slug": "grammarly",
        "frequency": 2
      },
      {
        "name": "Siemens",
        "slug": "siemens",
        "frequency": 2
      },
      {
        "name": "Barclays",
        "slug": "barclays",
        "frequency": 2
      },
      {
        "name": "DoorDash",
        "slug": "doordash",
        "frequency": 2
      },
      {
        "name": "Adobe",
        "slug": "adobe",
        "frequency": 2
      },
      {
        "name": "Nutanix",
        "slug": "nutanix",
        "frequency": 2
      },
      {
        "name": "Huawei",
        "slug": "huawei",
        "frequency": 2
      },
      {
        "name": "ByteDance",
        "slug": "bytedance",
        "frequency": 2
      },
      {
        "name": "Cloudflare",
        "slug": "cloudflare",
        "frequency": 2
      },
      {
        "name": "Squarepoint Capital",
        "slug": "squarepoint-capital",
        "frequency": 2
      },
      {
        "name": "HashedIn",
        "slug": "hashedin",
        "frequency": 2
      },
      {
        "name": "Comcast",
        "slug": "comcast",
        "frequency": 2
      }
    ]
  },
  {
    "id": "203",
    "slug": "remove-linked-list-elements",
    "title": "Remove Linked List Elements",
    "difficulty": "Easy",
    "description": "Given the `head` of a linked list and an integer `val`, remove all the nodes of the linked list that has `Node.val == val`, and return _the new head_.",
    "examples": [
      {
        "input": "head = \\[1,2,6,3,4,5,6\\], val = 6",
        "output": "\\[1,2,3,4,5\\]"
      },
      {
        "input": "head = \\[\\], val = 1",
        "output": "\\[\\]"
      },
      {
        "input": "head = \\[7,7,7,7\\], val = 7",
        "output": "\\[\\]"
      }
    ],
    "constraints": [
      "The number of nodes in the list is in the range `[0, 104]`.",
      "`1 <= Node.val <= 50`",
      "`0 <= val <= 50`"
    ],
    "companies": [
      {
        "name": "Amazon",
        "slug": "amazon",
        "frequency": 5
      },
      {
        "name": "Google",
        "slug": "google",
        "frequency": 3
      },
      {
        "name": "Meta",
        "slug": "facebook",
        "frequency": 2
      },
      {
        "name": "Microsoft",
        "slug": "microsoft",
        "frequency": 2
      }
    ]
  },
  {
    "id": "206",
    "slug": "reverse-linked-list",
    "title": "Reverse Linked List",
    "difficulty": "Easy",
    "description": "Given the `head` of a singly linked list, reverse the list, and return _the reversed list_.",
    "examples": [
      {
        "input": "head = \\[1,2,3,4,5\\]",
        "output": "\\[5,4,3,2,1\\]"
      },
      {
        "input": "head = \\[1,2\\]",
        "output": "\\[2,1\\]"
      },
      {
        "input": "head = \\[\\]",
        "output": "\\[\\]"
      }
    ],
    "constraints": [
      "The number of nodes in the list is the range `[0, 5000]`.",
      "`-5000 <= Node.val <= 5000`",
      "Follow up: A linked list can be reversed either iteratively or recursively. Could you implement both?"
    ],
    "companies": [
      {
        "name": "Microsoft",
        "slug": "microsoft",
        "frequency": 10
      },
      {
        "name": "Amazon",
        "slug": "amazon",
        "frequency": 10
      },
      {
        "name": "Google",
        "slug": "google",
        "frequency": 10
      },
      {
        "name": "Meta",
        "slug": "facebook",
        "frequency": 8
      },
      {
        "name": "Bloomberg",
        "slug": "bloomberg",
        "frequency": 7
      },
      {
        "name": "Apple",
        "slug": "apple",
        "frequency": 4
      },
      {
        "name": "Oracle",
        "slug": "oracle",
        "frequency": 3
      },
      {
        "name": "Visa",
        "slug": "visa",
        "frequency": 3
      },
      {
        "name": "TikTok",
        "slug": "tiktok",
        "frequency": 3
      },
      {
        "name": "Nvidia",
        "slug": "nvidia",
        "frequency": 3
      },
      {
        "name": "SAP",
        "slug": "sap",
        "frequency": 3
      },
      {
        "name": "Qualcomm",
        "slug": "qualcomm",
        "frequency": 2
      },
      {
        "name": "Adobe",
        "slug": "adobe",
        "frequency": 2
      },
      {
        "name": "Goldman Sachs",
        "slug": "goldman-sachs",
        "frequency": 2
      }
    ]
  },
  {
    "id": "207",
    "slug": "course-schedule",
    "title": "Course Schedule",
    "difficulty": "Medium",
    "description": "There are a total of `numCourses` courses you have to take, labeled from `0` to `numCourses - 1`. You are given an array `prerequisites` where `prerequisites[i] = [ai, bi]` indicates that you **must** take course `bi` first if you want to take course `ai`. *  For example, the pair `[0, 1]`, indicates that to take course `0` you have to first take course `1`. Return `true` if you can finish all courses. Otherwise, return `false`.",
    "examples": [
      {
        "input": "numCourses = 2, prerequisites = \\[\\[1,0\\]\\]",
        "output": "true",
        "explanation": "There are a total of 2 courses to take."
      },
      {
        "input": "numCourses = 2, prerequisites = \\[\\[1,0\\],\\[0,1\\]\\]",
        "output": "false",
        "explanation": "There are a total of 2 courses to take."
      }
    ],
    "constraints": [
      "`1 <= numCourses <= 2000`",
      "`0 <= prerequisites.length <= 5000`",
      "`prerequisites[i].length == 2`",
      "`0 <= ai, bi < numCourses`",
      "All the pairs prerequisites\\[i\\] are unique."
    ],
    "companies": [
      {
        "name": "Amazon",
        "slug": "amazon",
        "frequency": 53
      },
      {
        "name": "Meta",
        "slug": "facebook",
        "frequency": 34
      },
      {
        "name": "Google",
        "slug": "google",
        "frequency": 14
      },
      {
        "name": "TikTok",
        "slug": "tiktok",
        "frequency": 8
      },
      {
        "name": "Microsoft",
        "slug": "microsoft",
        "frequency": 5
      },
      {
        "name": "Visa",
        "slug": "visa",
        "frequency": 4
      },
      {
        "name": "Bloomberg",
        "slug": "bloomberg",
        "frequency": 3
      },
      {
        "name": "Apple",
        "slug": "apple",
        "frequency": 3
      },
      {
        "name": "Anduril",
        "slug": "anduril",
        "frequency": 3
      },
      {
        "name": "Nordstrom",
        "slug": "nordstrom",
        "frequency": 3
      },
      {
        "name": "ByteDance",
        "slug": "bytedance",
        "frequency": 3
      },
      {
        "name": "Oracle",
        "slug": "oracle",
        "frequency": 2
      },
      {
        "name": "Coupang",
        "slug": "coupang",
        "frequency": 2
      },
      {
        "name": "Adobe",
        "slug": "adobe",
        "frequency": 2
      },
      {
        "name": "DoorDash",
        "slug": "doordash",
        "frequency": 2
      },
      {
        "name": "Snowflake",
        "slug": "snowflake",
        "frequency": 2
      },
      {
        "name": "Swiggy",
        "slug": "swiggy",
        "frequency": 2
      },
      {
        "name": "IXL",
        "slug": "ixl",
        "frequency": 2
      },
      {
        "name": "Uber",
        "slug": "uber",
        "frequency": 2
      }
    ]
  },
  {
    "id": "208",
    "slug": "implement-trie-prefix-tree",
    "title": "Implement Trie (Prefix Tree)",
    "difficulty": "Medium",
    "description": "A [**trie**](https://en.wikipedia.org/wiki/Trie) (pronounced as \"try \") or **prefix tree** is a tree data structure used to efficiently store and retrieve keys in a dataset of strings. There are various applications of this data structure, such as autocomplete and spellchecker. Implement the Trie class: *  `Trie()` Initializes the trie object. *  `void insert(String word)` Inserts the string `word` into the trie. *  `boolean search(String word)` Returns `true` if the string `word` is in the trie (i.e., was inserted before), and `false` otherwise. *  `boolean startsWith(String prefix)` Returns `true` if there is a previously inserted string `word` that has the prefix `prefix`, and `false` otherwise.",
    "examples": [],
    "constraints": [
      "`1 <= word.length, prefix.length <= 2000`",
      "`word` and `prefix` consist only of lowercase English letters.",
      "At most `3  104` calls in total will be made to `insert`, `search`, and `startsWith`."
    ],
    "companies": [
      {
        "name": "Amazon",
        "slug": "amazon",
        "frequency": 7
      },
      {
        "name": "DoorDash",
        "slug": "doordash",
        "frequency": 7
      },
      {
        "name": "Microsoft",
        "slug": "microsoft",
        "frequency": 6
      },
      {
        "name": "Apple",
        "slug": "apple",
        "frequency": 4
      },
      {
        "name": "Docusign",
        "slug": "docusign",
        "frequency": 4
      },
      {
        "name": "Google",
        "slug": "google",
        "frequency": 4
      },
      {
        "name": "Oracle",
        "slug": "oracle",
        "frequency": 2
      },
      {
        "name": "Snowflake",
        "slug": "snowflake",
        "frequency": 2
      },
      {
        "name": "Roblox",
        "slug": "roblox",
        "frequency": 2
      },
      {
        "name": "Meta",
        "slug": "facebook",
        "frequency": 2
      },
      {
        "name": "Citadel",
        "slug": "citadel",
        "frequency": 2
      },
      {
        "name": "instabase",
        "slug": "instabase",
        "frequency": 2
      },
      {
        "name": "Grammarly",
        "slug": "grammarly",
        "frequency": 2
      }
    ]
  },
  {
    "id": "209",
    "slug": "minimum-size-subarray-sum",
    "title": "Minimum Size Subarray Sum",
    "difficulty": "Medium",
    "description": "Given an array of positive integers `nums` and a positive integer `target`, return _the **minimal length** of a_ _subarray_ _whose sum is greater than or equal to_ `target`. If there is no such subarray, return `0` instead.",
    "examples": [
      {
        "input": "target = 7, nums = \\[2,3,1,2,4,3\\]",
        "output": "2",
        "explanation": "The subarray \\[4,3\\] has the minimal length under the problem constraint."
      },
      {
        "input": "target = 4, nums = \\[1,4,4\\]",
        "output": "1"
      },
      {
        "input": "target = 11, nums = \\[1,1,1,1,1,1,1,1\\]",
        "output": "0"
      }
    ],
    "constraints": [
      "`1 <= target <= 109`",
      "`1 <= nums.length <= 105`",
      "`1 <= nums[i] <= 104`",
      "Follow up: If you have figured out the `O(n)` solution, try coding another solution of which the time complexity is `O(n log(n))`."
    ],
    "companies": [
      {
        "name": "Google",
        "slug": "google",
        "frequency": 6
      },
      {
        "name": "Meta",
        "slug": "facebook",
        "frequency": 5
      },
      {
        "name": "Amazon",
        "slug": "amazon",
        "frequency": 5
      },
      {
        "name": "Microsoft",
        "slug": "microsoft",
        "frequency": 4
      },
      {
        "name": "DoorDash",
        "slug": "doordash",
        "frequency": 4
      },
      {
        "name": "TikTok",
        "slug": "tiktok",
        "frequency": 3
      },
      {
        "name": "Bloomberg",
        "slug": "bloomberg",
        "frequency": 2
      },
      {
        "name": "Goldman Sachs",
        "slug": "goldman-sachs",
        "frequency": 2
      },
      {
        "name": "Nvidia",
        "slug": "nvidia",
        "frequency": 2
      },
      {
        "name": "Oracle",
        "slug": "oracle",
        "frequency": 2
      }
    ]
  },
  {
    "id": "210",
    "slug": "course-schedule-ii",
    "title": "Course Schedule II",
    "difficulty": "Medium",
    "description": "There are a total of `numCourses` courses you have to take, labeled from `0` to `numCourses - 1`. You are given an array `prerequisites` where `prerequisites[i] = [ai, bi]` indicates that you **must** take course `bi` first if you want to take course `ai`. *  For example, the pair `[0, 1]`, indicates that to take course `0` you have to first take course `1`. Return _the ordering of courses you should take to finish all courses_. If there are many valid answers, return **any** of them. If it is impossible to finish all courses, return **an empty array**.",
    "examples": [
      {
        "input": "numCourses = 2, prerequisites = \\[\\[1,0\\]\\]",
        "output": "\\[0,1\\]",
        "explanation": "There are a total of 2 courses to take. To take course 1 you should have finished course 0. So the correct course order is \\[0,1\\]."
      },
      {
        "input": "numCourses = 4, prerequisites = \\[\\[1,0\\],\\[2,0\\],\\[3,1\\],\\[3,2\\]\\]",
        "output": "\\[0,2,1,3\\]",
        "explanation": "There are a total of 4 courses to take. To take course 3 you should have finished both courses 1 and 2. Both courses 1 and 2 should be taken after you finished course 0."
      },
      {
        "input": "numCourses = 1, prerequisites = \\[\\]",
        "output": "\\[0\\]"
      }
    ],
    "constraints": [
      "`1 <= numCourses <= 2000`",
      "`0 <= prerequisites.length <= numCourses  (numCourses - 1)`",
      "`prerequisites[i].length == 2`",
      "`0 <= ai, bi < numCourses`",
      "`ai != bi`",
      "All the pairs `[ai, bi]` are distinct."
    ],
    "companies": [
      {
        "name": "Amazon",
        "slug": "amazon",
        "frequency": 48
      },
      {
        "name": "Uber",
        "slug": "uber",
        "frequency": 11
      },
      {
        "name": "TikTok",
        "slug": "tiktok",
        "frequency": 9
      },
      {
        "name": "Snowflake",
        "slug": "snowflake",
        "frequency": 9
      },
      {
        "name": "Meta",
        "slug": "facebook",
        "frequency": 6
      },
      {
        "name": "Google",
        "slug": "google",
        "frequency": 6
      },
      {
        "name": "Salesforce",
        "slug": "salesforce",
        "frequency": 5
      },
      {
        "name": "Snap",
        "slug": "snapchat",
        "frequency": 5
      },
      {
        "name": "Intuit",
        "slug": "intuit",
        "frequency": 5
      },
      {
        "name": "DoorDash",
        "slug": "doordash",
        "frequency": 5
      },
      {
        "name": "Microsoft",
        "slug": "microsoft",
        "frequency": 4
      },
      {
        "name": "Apple",
        "slug": "apple",
        "frequency": 4
      },
      {
        "name": "Anduril",
        "slug": "anduril",
        "frequency": 4
      },
      {
        "name": "Nvidia",
        "slug": "nvidia",
        "frequency": 3
      },
      {
        "name": "LinkedIn",
        "slug": "linkedin",
        "frequency": 3
      },
      {
        "name": "Oracle",
        "slug": "oracle",
        "frequency": 2
      },
      {
        "name": "Bloomberg",
        "slug": "bloomberg",
        "frequency": 2
      },
      {
        "name": "Flipkart",
        "slug": "flipkart",
        "frequency": 2
      },
      {
        "name": "Qualcomm",
        "slug": "qualcomm",
        "frequency": 2
      },
      {
        "name": "Remitly",
        "slug": "remitly",
        "frequency": 2
      },
      {
        "name": "Walmart Labs",
        "slug": "walmart-labs",
        "frequency": 2
      },
      {
        "name": "Arista Networks",
        "slug": "arista-networks",
        "frequency": 2
      }
    ]
  },
  {
    "id": "212",
    "slug": "word-search-ii",
    "title": "Word Search II",
    "difficulty": "Hard",
    "description": "Given an `m x n` `board` of characters and a list of strings `words`, return _all words on the board_. Each word must be constructed from letters of sequentially adjacent cells, where **adjacent cells** are horizontally or vertically neighboring. The same letter cell may not be used more than once in a word.",
    "examples": [
      {
        "input": "board = \\[\\[ \"o \", \"a \", \"a \", \"n \"\\],\\[ \"e \", \"t \", \"a \", \"e \"\\],\\[ \"i \", \"h \", \"k \", \"r \"\\],\\[ \"i \", \"f \", \"l \", \"v \"\\]\\], words = \\[ \"oath \", \"pea \", \"eat \", \"rain \"\\]",
        "output": "\\[ \"eat \", \"oath \"\\]"
      },
      {
        "input": "board = \\[\\[ \"a \", \"b \"\\],\\[ \"c \", \"d \"\\]\\], words = \\[ \"abcb \"\\]",
        "output": "\\[\\]"
      }
    ],
    "constraints": [
      "`m == board.length`",
      "`n == board[i].length`",
      "`1 <= m, n <= 12`",
      "`board[i][j]` is a lowercase English letter.",
      "`1 <= words.length <= 3  104`",
      "`1 <= words[i].length <= 10`",
      "`words[i]` consists of lowercase English letters.",
      "All the strings of `words` are unique."
    ],
    "companies": [
      {
        "name": "Amazon",
        "slug": "amazon",
        "frequency": 15
      },
      {
        "name": "Uber",
        "slug": "uber",
        "frequency": 7
      },
      {
        "name": "TikTok",
        "slug": "tiktok",
        "frequency": 5
      },
      {
        "name": "Snowflake",
        "slug": "snowflake",
        "frequency": 5
      },
      {
        "name": "Two Sigma",
        "slug": "two-sigma",
        "frequency": 4
      },
      {
        "name": "DoorDash",
        "slug": "doordash",
        "frequency": 4
      },
      {
        "name": "Cisco",
        "slug": "cisco",
        "frequency": 4
      },
      {
        "name": "Wix",
        "slug": "wix",
        "frequency": 4
      },
      {
        "name": "Google",
        "slug": "google",
        "frequency": 3
      },
      {
        "name": "Meta",
        "slug": "facebook",
        "frequency": 2
      },
      {
        "name": "Microsoft",
        "slug": "microsoft",
        "frequency": 2
      },
      {
        "name": "Snap",
        "slug": "snapchat",
        "frequency": 2
      },
      {
        "name": "Aurora",
        "slug": "aurora",
        "frequency": 2
      }
    ]
  },
  {
    "id": "213",
    "slug": "house-robber-ii",
    "title": "House Robber II",
    "difficulty": "Medium",
    "description": "You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed. All houses at this place are **arranged in a circle.** That means the first house is the neighbor of the last one. Meanwhile, adjacent houses have a security system connected, and **it will automatically contact the police if two adjacent houses were broken into on the same night**. Given an integer array `nums` representing the amount of money of each house, return _the maximum amount of money you can rob tonight **without alerting the police**_.",
    "examples": [
      {
        "input": "nums = \\[2,3,2\\]",
        "output": "3",
        "explanation": "You cannot rob house 1 (money = 2) and then rob house 3 (money = 2), because they are adjacent houses."
      },
      {
        "input": "nums = \\[1,2,3,1\\]",
        "output": "4",
        "explanation": "Rob house 1 (money = 1) and then rob house 3 (money = 3)."
      },
      {
        "input": "nums = \\[1,2,3\\]",
        "output": "3"
      }
    ],
    "constraints": ["`1 <= nums.length <= 100`", "`0 <= nums[i] <= 1000`"],
    "companies": [
      {
        "name": "Databricks",
        "slug": "databricks",
        "frequency": 7
      },
      {
        "name": "Microsoft",
        "slug": "microsoft",
        "frequency": 7
      },
      {
        "name": "Google",
        "slug": "google",
        "frequency": 5
      },
      {
        "name": "Meta",
        "slug": "facebook",
        "frequency": 3
      },
      {
        "name": "Apple",
        "slug": "apple",
        "frequency": 3
      },
      {
        "name": "Amazon",
        "slug": "amazon",
        "frequency": 2
      },
      {
        "name": "Docusign",
        "slug": "docusign",
        "frequency": 2
      },
      {
        "name": "TikTok",
        "slug": "tiktok",
        "frequency": 2
      },
      {
        "name": "Uber",
        "slug": "uber",
        "frequency": 2
      },
      {
        "name": "Visa",
        "slug": "visa",
        "frequency": 2
      }
    ]
  },
  {
    "id": "215",
    "slug": "kth-largest-element-in-an-array",
    "title": "Kth Largest Element in an Array",
    "difficulty": "Medium",
    "description": "Given an integer array `nums` and an integer `k`, return _the_ `kth` _largest element in the array_. Note that it is the `kth` largest element in the sorted order, not the `kth` distinct element. You must solve it in `O(n)` time complexity.",
    "examples": [
      {
        "input": "nums = \\[3,2,1,5,6,4\\], k = 2",
        "output": "5"
      },
      {
        "input": "nums = \\[3,2,3,1,2,4,5,5,6\\], k = 4",
        "output": "4"
      }
    ],
    "constraints": [
      "`1 <= k <= nums.length <= 105`",
      "`-104 <= nums[i] <= 104`"
    ],
    "companies": [
      {
        "name": "Meta",
        "slug": "facebook",
        "frequency": 205
      },
      {
        "name": "Amazon",
        "slug": "amazon",
        "frequency": 20
      },
      {
        "name": "Google",
        "slug": "google",
        "frequency": 14
      },
      {
        "name": "Microsoft",
        "slug": "microsoft",
        "frequency": 7
      },
      {
        "name": "Apple",
        "slug": "apple",
        "frequency": 6
      },
      {
        "name": "LinkedIn",
        "slug": "linkedin",
        "frequency": 6
      },
      {
        "name": "Spotify",
        "slug": "spotify",
        "frequency": 5
      },
      {
        "name": "Bloomberg",
        "slug": "bloomberg",
        "frequency": 4
      },
      {
        "name": "TikTok",
        "slug": "tiktok",
        "frequency": 4
      },
      {
        "name": "Oracle",
        "slug": "oracle",
        "frequency": 4
      },
      {
        "name": "Goldman Sachs",
        "slug": "goldman-sachs",
        "frequency": 3
      },
      {
        "name": "ServiceNow",
        "slug": "servicenow",
        "frequency": 3
      },
      {
        "name": "Walmart Labs",
        "slug": "walmart-labs",
        "frequency": 3
      },
      {
        "name": "Salesforce",
        "slug": "salesforce",
        "frequency": 2
      },
      {
        "name": "Nvidia",
        "slug": "nvidia",
        "frequency": 2
      },
      {
        "name": "PayPal",
        "slug": "paypal",
        "frequency": 2
      },
      {
        "name": "Morgan Stanley",
        "slug": "morgan-stanley",
        "frequency": 2
      },
      {
        "name": "ByteDance",
        "slug": "bytedance",
        "frequency": 2
      },
      {
        "name": "Intuit",
        "slug": "intuit",
        "frequency": 2
      },
      {
        "name": "Turing",
        "slug": "turing",
        "frequency": 2
      }
    ]
  },
  {
    "id": "216",
    "slug": "combination-sum-iii",
    "title": "Combination Sum III",
    "difficulty": "Medium",
    "description": "Find all valid combinations of `k` numbers that sum up to `n` such that the following conditions are true: *  Only numbers `1` through `9` are used. *  Each number is used **at most once**. Return _a list of all possible valid combinations_. The list must not contain the same combination twice, and the combinations may be returned in any order.",
    "examples": [
      {
        "input": "k = 3, n = 7",
        "output": "\\[\\[1,2,4\\]\\]",
        "explanation": ""
      },
      {
        "input": "k = 3, n = 9",
        "output": "\\[\\[1,2,6\\],\\[1,3,5\\],\\[2,3,4\\]\\]",
        "explanation": ""
      },
      {
        "input": "k = 4, n = 1",
        "output": "\\[\\]",
        "explanation": "There are no valid combinations."
      }
    ],
    "constraints": ["`2 <= k <= 9`", "`1 <= n <= 60`"],
    "companies": [
      {
        "name": "Amazon",
        "slug": "amazon",
        "frequency": 3
      },
      {
        "name": "Bloomberg",
        "slug": "bloomberg",
        "frequency": 3
      },
      {
        "name": "Google",
        "slug": "google",
        "frequency": 2
      }
    ]
  },
  {
    "id": "217",
    "slug": "contains-duplicate",
    "title": "Contains Duplicate",
    "difficulty": "Easy",
    "description": "Given an integer array `nums`, return `true` if any value appears **at least twice** in the array, and return `false` if every element is distinct.",
    "examples": [
      {
        "input": "nums = \\[1,2,3,1\\]",
        "output": "true"
      },
      {
        "input": "nums = \\[1,2,3,4\\]",
        "output": "false"
      },
      {
        "input": "nums = \\[1,1,1,3,3,4,3,2,4,2\\]",
        "output": "true"
      }
    ],
    "constraints": ["`1 <= nums.length <= 105`", "`-109 <= nums[i] <= 109`"],
    "companies": [
      {
        "name": "Google",
        "slug": "google",
        "frequency": 9
      },
      {
        "name": "Bloomberg",
        "slug": "bloomberg",
        "frequency": 6
      },
      {
        "name": "Microsoft",
        "slug": "microsoft",
        "frequency": 6
      },
      {
        "name": "Meta",
        "slug": "facebook",
        "frequency": 5
      },
      {
        "name": "Amazon",
        "slug": "amazon",
        "frequency": 4
      },
      {
        "name": "tcs",
        "slug": "tcs",
        "frequency": 2
      },
      {
        "name": "Netflix",
        "slug": "netflix",
        "frequency": 2
      },
      {
        "name": "Oracle",
        "slug": "oracle",
        "frequency": 2
      }
    ]
  },
  {
    "id": "226",
    "slug": "invert-binary-tree",
    "title": "Invert Binary Tree",
    "difficulty": "Easy",
    "description": "Given the `root` of a binary tree, invert the tree, and return _its root_.",
    "examples": [
      {
        "input": "root = \\[4,2,7,1,3,6,9\\]",
        "output": "\\[4,7,2,9,6,3,1\\]"
      },
      {
        "input": "root = \\[2,1,3\\]",
        "output": "\\[2,3,1\\]"
      },
      {
        "input": "root = \\[\\]",
        "output": "\\[\\]"
      }
    ],
    "constraints": [
      "The number of nodes in the tree is in the range `[0, 100]`.",
      "`-100 <= Node.val <= 100`"
    ],
    "companies": [
      {
        "name": "Google",
        "slug": "google",
        "frequency": 8
      },
      {
        "name": "Amazon",
        "slug": "amazon",
        "frequency": 6
      },
      {
        "name": "Meta",
        "slug": "facebook",
        "frequency": 2
      }
    ]
  },
  {
    "id": "230",
    "slug": "kth-smallest-element-in-a-bst",
    "title": "Kth Smallest Element in a BST",
    "difficulty": "Medium",
    "description": "Given the `root` of a binary search tree, and an integer `k`, return _the_ `kth` _smallest value (**1-indexed**) of all the values of the nodes in the tree_.",
    "examples": [
      {
        "input": "root = \\[3,1,4,null,2\\], k = 1",
        "output": "1"
      },
      {
        "input": "root = \\[5,3,6,2,4,null,null,1\\], k = 3",
        "output": "3"
      }
    ],
    "constraints": [
      "The number of nodes in the tree is `n`.",
      "`1 <= k <= n <= 104`",
      "`0 <= Node.val <= 104`",
      "Follow up: If the BST is modified often (i.e., we can do insert and delete operations) and you need to find the kth smallest frequently, how would you optimize?"
    ],
    "companies": [
      {
        "name": "Uber",
        "slug": "uber",
        "frequency": 8
      },
      {
        "name": "Amazon",
        "slug": "amazon",
        "frequency": 7
      },
      {
        "name": "Google",
        "slug": "google",
        "frequency": 4
      },
      {
        "name": "Meta",
        "slug": "facebook",
        "frequency": 4
      },
      {
        "name": "Oracle",
        "slug": "oracle",
        "frequency": 3
      },
      {
        "name": "Bloomberg",
        "slug": "bloomberg",
        "frequency": 2
      },
      {
        "name": "Microsoft",
        "slug": "microsoft",
        "frequency": 2
      },
      {
        "name": "LinkedIn",
        "slug": "linkedin",
        "frequency": 2
      },
      {
        "name": "Cisco",
        "slug": "cisco",
        "frequency": 2
      }
    ]
  },
  {
    "id": "234",
    "slug": "palindrome-linked-list",
    "title": "Palindrome Linked List",
    "difficulty": "Easy",
    "description": "Given the `head` of a singly linked list, return `true` _if it is a_ _palindrome_ _or_ `false` _otherwise_.",
    "examples": [
      {
        "input": "head = \\[1,2,2,1\\]",
        "output": "true"
      },
      {
        "input": "head = \\[1,2\\]",
        "output": "false"
      }
    ],
    "constraints": [
      "The number of nodes in the list is in the range `[1, 105]`.",
      "`0 <= Node.val <= 9`",
      "Follow up: Could you do it in `O(n)` time and `O(1)` space?"
    ],
    "companies": [
      {
        "name": "Google",
        "slug": "google",
        "frequency": 13
      },
      {
        "name": "Meta",
        "slug": "facebook",
        "frequency": 6
      },
      {
        "name": "Amazon",
        "slug": "amazon",
        "frequency": 6
      },
      {
        "name": "Bloomberg",
        "slug": "bloomberg",
        "frequency": 5
      },
      {
        "name": "Microsoft",
        "slug": "microsoft",
        "frequency": 3
      },
      {
        "name": "ServiceNow",
        "slug": "servicenow",
        "frequency": 2
      },
      {
        "name": "Yandex",
        "slug": "yandex",
        "frequency": 2
      }
    ]
  },
  {
    "id": "235",
    "slug": "lowest-common-ancestor-of-a-binary-search-tree",
    "title": "Lowest Common Ancestor of a Binary Search Tree",
    "difficulty": "Medium",
    "description": "Given a binary search tree (BST), find the lowest common ancestor (LCA) node of two given nodes in the BST. According to the [definition of LCA on Wikipedia](https://en.wikipedia.org/wiki/Lowest_common_ancestor): \"The lowest common ancestor is defined between two nodes `p` and `q` as the lowest node in `T` that has both `p` and `q` as descendants (where we allow **a node to be a descendant of itself**).\"",
    "examples": [
      {
        "input": "root = \\[6,2,8,0,4,7,9,null,null,3,5\\], p = 2, q = 8",
        "output": "6",
        "explanation": "The LCA of nodes 2 and 8 is 6."
      },
      {
        "input": "root = \\[6,2,8,0,4,7,9,null,null,3,5\\], p = 2, q = 4",
        "output": "2",
        "explanation": "The LCA of nodes 2 and 4 is 2, since a node can be a descendant of itself according to the LCA definition."
      },
      {
        "input": "root = \\[2,1\\], p = 2, q = 1",
        "output": "2"
      }
    ],
    "constraints": [
      "The number of nodes in the tree is in the range `[2, 105]`.",
      "`-109 <= Node.val <= 109`",
      "All `Node.val` are unique.",
      "`p != q`",
      "`p` and `q` will exist in the BST."
    ],
    "companies": [
      {
        "name": "Meta",
        "slug": "facebook",
        "frequency": 11
      },
      {
        "name": "Amazon",
        "slug": "amazon",
        "frequency": 6
      },
      {
        "name": "LinkedIn",
        "slug": "linkedin",
        "frequency": 5
      },
      {
        "name": "Microsoft",
        "slug": "microsoft",
        "frequency": 5
      },
      {
        "name": "Bloomberg",
        "slug": "bloomberg",
        "frequency": 2
      },
      {
        "name": "Google",
        "slug": "google",
        "frequency": 2
      }
    ]
  },
  {
    "id": "236",
    "slug": "lowest-common-ancestor-of-a-binary-tree",
    "title": "Lowest Common Ancestor of a Binary Tree",
    "difficulty": "Medium",
    "description": "Given a binary tree, find the lowest common ancestor (LCA) of two given nodes in the tree. According to the [definition of LCA on Wikipedia](https://en.wikipedia.org/wiki/Lowest_common_ancestor): \"The lowest common ancestor is defined between two nodes `p` and `q` as the lowest node in `T` that has both `p` and `q` as descendants (where we allow **a node to be a descendant of itself**).\"",
    "examples": [
      {
        "input": "root = \\[3,5,1,6,2,0,8,null,null,7,4\\], p = 5, q = 1",
        "output": "3",
        "explanation": "The LCA of nodes 5 and 1 is 3."
      },
      {
        "input": "root = \\[3,5,1,6,2,0,8,null,null,7,4\\], p = 5, q = 4",
        "output": "5",
        "explanation": "The LCA of nodes 5 and 4 is 5, since a node can be a descendant of itself according to the LCA definition."
      },
      {
        "input": "root = \\[1,2\\], p = 1, q = 2",
        "output": "1"
      }
    ],
    "constraints": [
      "The number of nodes in the tree is in the range `[2, 105]`.",
      "`-109 <= Node.val <= 109`",
      "All `Node.val` are unique.",
      "`p != q`",
      "`p` and `q` will exist in the tree."
    ],
    "companies": [
      {
        "name": "Meta",
        "slug": "facebook",
        "frequency": 141
      },
      {
        "name": "Amazon",
        "slug": "amazon",
        "frequency": 29
      },
      {
        "name": "Atlassian",
        "slug": "atlassian",
        "frequency": 6
      },
      {
        "name": "Google",
        "slug": "google",
        "frequency": 5
      },
      {
        "name": "Microsoft",
        "slug": "microsoft",
        "frequency": 5
      },
      {
        "name": "Apple",
        "slug": "apple",
        "frequency": 3
      },
      {
        "name": "LinkedIn",
        "slug": "linkedin",
        "frequency": 3
      },
      {
        "name": "Oracle",
        "slug": "oracle",
        "frequency": 3
      },
      {
        "name": "Bloomberg",
        "slug": "bloomberg",
        "frequency": 2
      },
      {
        "name": "Yandex",
        "slug": "yandex",
        "frequency": 2
      },
      {
        "name": "TikTok",
        "slug": "tiktok",
        "frequency": 2
      },
      {
        "name": "Intuit",
        "slug": "intuit",
        "frequency": 2
      },
      {
        "name": "Adobe",
        "slug": "adobe",
        "frequency": 2
      }
    ]
  },
  {
    "id": "238",
    "slug": "product-of-array-except-self",
    "title": "Product of Array Except Self",
    "difficulty": "Medium",
    "description": "Given an integer array `nums`, return _an array_ `answer` _such that_ `answer[i]` _is equal to the product of all the elements of_ `nums` _except_ `nums[i]`. The product of any prefix or suffix of `nums` is **guaranteed** to fit in a **32-bit** integer. You must write an algorithm that runs in `O(n)` time and without using the division operation.",
    "examples": [
      {
        "input": "nums = \\[1,2,3,4\\]",
        "output": "\\[24,12,8,6\\]"
      },
      {
        "input": "nums = \\[-1,1,0,-3,3\\]",
        "output": "\\[0,0,9,0,0\\]"
      }
    ],
    "constraints": [
      "`2 <= nums.length <= 105`",
      "`-30 <= nums[i] <= 30`",
      "The product of any prefix or suffix of `nums` is guaranteed to fit in a 32-bit integer.",
      "Follow up: Can you solve the problem in `O(1)` extra space complexity? (The output array does not count as extra space for space complexity analysis.)"
    ],
    "companies": [
      {
        "name": "Amazon",
        "slug": "amazon",
        "frequency": 28
      },
      {
        "name": "Google",
        "slug": "google",
        "frequency": 7
      },
      {
        "name": "Meta",
        "slug": "facebook",
        "frequency": 6
      },
      {
        "name": "Uber",
        "slug": "uber",
        "frequency": 6
      },
      {
        "name": "Microsoft",
        "slug": "microsoft",
        "frequency": 5
      },
      {
        "name": "Asana",
        "slug": "asana",
        "frequency": 5
      },
      {
        "name": "Goldman Sachs",
        "slug": "goldman-sachs",
        "frequency": 4
      },
      {
        "name": "PayPal",
        "slug": "paypal",
        "frequency": 3
      },
      {
        "name": "Bloomberg",
        "slug": "bloomberg",
        "frequency": 3
      },
      {
        "name": "Apple",
        "slug": "apple",
        "frequency": 2
      },
      {
        "name": "Adobe",
        "slug": "adobe",
        "frequency": 2
      },
      {
        "name": "Nvidia",
        "slug": "nvidia",
        "frequency": 2
      },
      {
        "name": "Fractal Analytics",
        "slug": "fractal-analytics",
        "frequency": 2
      },
      {
        "name": "ZS Associates",
        "slug": "zs-associates",
        "frequency": 2
      },
      {
        "name": "Yahoo",
        "slug": "yahoo",
        "frequency": 2
      },
      {
        "name": "Oracle",
        "slug": "oracle",
        "frequency": 2
      },
      {
        "name": "Intuit",
        "slug": "intuit",
        "frequency": 2
      },
      {
        "name": "Salesforce",
        "slug": "salesforce",
        "frequency": 2
      },
      {
        "name": "Flipkart",
        "slug": "flipkart",
        "frequency": 2
      },
      {
        "name": "Yandex",
        "slug": "yandex",
        "frequency": 2
      },
      {
        "name": "Accenture",
        "slug": "accenture",
        "frequency": 2
      },
      {
        "name": "IBM",
        "slug": "ibm",
        "frequency": 2
      },
      {
        "name": "Turing",
        "slug": "turing",
        "frequency": 2
      },
      {
        "name": "Autodesk",
        "slug": "autodesk",
        "frequency": 2
      },
      {
        "name": "Sigmoid",
        "slug": "sigmoid",
        "frequency": 2
      },
      {
        "name": "Infosys",
        "slug": "infosys",
        "frequency": 2
      }
    ]
  },
  {
    "id": "239",
    "slug": "sliding-window-maximum",
    "title": "Sliding Window Maximum",
    "difficulty": "Hard",
    "description": "You are given an array of integers `nums`, there is a sliding window of size `k` which is moving from the very left of the array to the very right. You can only see the `k` numbers in the window. Each time the sliding window moves right by one position. Return _the max sliding window_.",
    "examples": [
      {
        "input": "nums = \\[1,3,-1,-3,5,3,6,7\\], k = 3",
        "output": "\\[3,3,5,5,6,7\\]",
        "explanation": ""
      },
      {
        "input": "nums = \\[1\\], k = 1",
        "output": "\\[1\\]"
      }
    ],
    "constraints": [
      "`1 <= nums.length <= 105`",
      "`-104 <= nums[i] <= 104`",
      "`1 <= k <= nums.length`"
    ],
    "companies": [
      {
        "name": "Amazon",
        "slug": "amazon",
        "frequency": 20
      },
      {
        "name": "Meta",
        "slug": "facebook",
        "frequency": 12
      },
      {
        "name": "Google",
        "slug": "google",
        "frequency": 11
      },
      {
        "name": "Oracle",
        "slug": "oracle",
        "frequency": 8
      },
      {
        "name": "Apple",
        "slug": "apple",
        "frequency": 4
      },
      {
        "name": "Microsoft",
        "slug": "microsoft",
        "frequency": 3
      },
      {
        "name": "Juspay",
        "slug": "juspay",
        "frequency": 3
      },
      {
        "name": "LINE",
        "slug": "line",
        "frequency": 3
      },
      {
        "name": "Uber",
        "slug": "uber",
        "frequency": 3
      },
      {
        "name": "tcs",
        "slug": "tcs",
        "frequency": 3
      },
      {
        "name": "Bloomberg",
        "slug": "bloomberg",
        "frequency": 2
      },
      {
        "name": "Goldman Sachs",
        "slug": "goldman-sachs",
        "frequency": 2
      },
      {
        "name": "TikTok",
        "slug": "tiktok",
        "frequency": 2
      },
      {
        "name": "Palo Alto Networks",
        "slug": "palo-alto-networks",
        "frequency": 2
      },
      {
        "name": "Adobe",
        "slug": "adobe",
        "frequency": 2
      },
      {
        "name": "Nutanix",
        "slug": "nutanix",
        "frequency": 2
      },
      {
        "name": "Booking.com",
        "slug": "bookingcom",
        "frequency": 2
      },
      {
        "name": "DE Shaw",
        "slug": "de-shaw",
        "frequency": 2
      },
      {
        "name": "Gameskraft",
        "slug": "gameskraft",
        "frequency": 2
      },
      {
        "name": "MongoDB",
        "slug": "mongodb",
        "frequency": 2
      }
    ]
  },
  {
    "id": "240",
    "slug": "search-a-2d-matrix-ii",
    "title": "Search a 2D Matrix II",
    "difficulty": "Medium",
    "description": "Write an efficient algorithm that searches for a value `target` in an `m x n` integer matrix `matrix`. This matrix has the following properties: *  Integers in each row are sorted in ascending from left to right. *  Integers in each column are sorted in ascending from top to bottom.",
    "examples": [
      {
        "input": "matrix = \\[\\[1,4,7,11,15\\],\\[2,5,8,12,19\\],\\[3,6,9,16,22\\],\\[10,13,14,17,24\\],\\[18,21,23,26,30\\]\\], target = 5",
        "output": "true"
      },
      {
        "input": "matrix = \\[\\[1,4,7,11,15\\],\\[2,5,8,12,19\\],\\[3,6,9,16,22\\],\\[10,13,14,17,24\\],\\[18,21,23,26,30\\]\\], target = 20",
        "output": "false"
      }
    ],
    "constraints": [
      "`m == matrix.length`",
      "`n == matrix[i].length`",
      "`1 <= n, m <= 300`",
      "`-109 <= matrix[i][j] <= 109`",
      "All the integers in each row are sorted in ascending order.",
      "All the integers in each column are sorted in ascending order.",
      "`-109 <= target <= 109`"
    ],
    "companies": [
      {
        "name": "Google",
        "slug": "google",
        "frequency": 8
      },
      {
        "name": "Amazon",
        "slug": "amazon",
        "frequency": 5
      },
      {
        "name": "Meta",
        "slug": "facebook",
        "frequency": 5
      },
      {
        "name": "Microsoft",
        "slug": "microsoft",
        "frequency": 3
      },
      {
        "name": "Oracle",
        "slug": "oracle",
        "frequency": 3
      },
      {
        "name": "PayPal",
        "slug": "paypal",
        "frequency": 2
      }
    ]
  },
  {
    "id": "252",
    "slug": "meeting-rooms",
    "title": "Meeting Rooms",
    "difficulty": "Easy",
    "description": "Given an array of meeting time `intervals` where `intervals[i] = [starti, endi]`, determine if a person could attend all meetings.",
    "examples": [
      {
        "input": "intervals = \\[\\[0,30\\],\\[5,10\\],\\[15,20\\]\\]",
        "output": "false"
      },
      {
        "input": "intervals = \\[\\[7,10\\],\\[2,4\\]\\]",
        "output": "true"
      }
    ],
    "constraints": [
      "`0 <= intervals.length <= 104`",
      "`intervals[i].length == 2`",
      "`0 <= starti < endi <= 106`"
    ],
    "companies": [
      {
        "name": "Amazon",
        "slug": "amazon",
        "frequency": 3
      },
      {
        "name": "Meta",
        "slug": "facebook",
        "frequency": 3
      },
      {
        "name": "TikTok",
        "slug": "tiktok",
        "frequency": 3
      },
      {
        "name": "Microsoft",
        "slug": "microsoft",
        "frequency": 2
      },
      {
        "name": "Google",
        "slug": "google",
        "frequency": 2
      },
      {
        "name": "Oracle",
        "slug": "oracle",
        "frequency": 2
      }
    ]
  },
  {
    "id": "253",
    "slug": "meeting-rooms-ii",
    "title": "Meeting Rooms II",
    "difficulty": "Medium",
    "description": "Given an array of meeting time intervals `intervals` where `intervals[i] = [starti, endi]`, return _the minimum number of conference rooms required_.",
    "examples": [
      {
        "input": "intervals = \\[\\[0,30\\],\\[5,10\\],\\[15,20\\]\\]",
        "output": "2"
      },
      {
        "input": "intervals = \\[\\[7,10\\],\\[2,4\\]\\]",
        "output": "1"
      }
    ],
    "constraints": [
      "`1 <= intervals.length <= 104`",
      "`0 <= starti < endi <= 106`"
    ],
    "companies": [
      {
        "name": "Amazon",
        "slug": "amazon",
        "frequency": 26
      },
      {
        "name": "Google",
        "slug": "google",
        "frequency": 20
      },
      {
        "name": "Meta",
        "slug": "facebook",
        "frequency": 17
      },
      {
        "name": "Bloomberg",
        "slug": "bloomberg",
        "frequency": 10
      },
      {
        "name": "TikTok",
        "slug": "tiktok",
        "frequency": 7
      },
      {
        "name": "Uber",
        "slug": "uber",
        "frequency": 7
      },
      {
        "name": "Atlassian",
        "slug": "atlassian",
        "frequency": 6
      },
      {
        "name": "Microsoft",
        "slug": "microsoft",
        "frequency": 5
      },
      {
        "name": "Apple",
        "slug": "apple",
        "frequency": 3
      },
      {
        "name": "Oracle",
        "slug": "oracle",
        "frequency": 2
      },
      {
        "name": "Cisco",
        "slug": "cisco",
        "frequency": 2
      },
      {
        "name": "Netflix",
        "slug": "netflix",
        "frequency": 2
      },
      {
        "name": "Hubspot",
        "slug": "hubspot",
        "frequency": 2
      },
      {
        "name": "Lime",
        "slug": "lime",
        "frequency": 2
      },
      {
        "name": "WorldQuant",
        "slug": "worldquant",
        "frequency": 2
      },
      {
        "name": "Salesforce",
        "slug": "salesforce",
        "frequency": 2
      },
      {
        "name": "Splunk",
        "slug": "splunk",
        "frequency": 2
      },
      {
        "name": "Capital One",
        "slug": "capital-one",
        "frequency": 2
      },
      {
        "name": "Two Sigma",
        "slug": "two-sigma",
        "frequency": 2
      }
    ]
  },
  {
    "id": "254",
    "slug": "factor-combinations",
    "title": "Factor Combinations",
    "difficulty": "Medium",
    "description": "Numbers can be regarded as the product of their factors. *  For example, `8 = 2 x 2 x 2 = 2 x 4`. Given an integer `n`, return _all possible combinations of its factors_. You may return the answer in **any order**. **Note** that the factors should be in the range `[2, n - 1]`.",
    "examples": [
      {
        "input": "n = 1",
        "output": "\\[\\]"
      },
      {
        "input": "n = 12",
        "output": "\\[\\[2,6\\],\\[3,4\\],\\[2,2,3\\]\\]"
      },
      {
        "input": "n = 37",
        "output": "\\[\\]"
      }
    ],
    "constraints": ["`1 <= n <= 107`"],
    "companies": [
      {
        "name": "LinkedIn",
        "slug": "linkedin",
        "frequency": 3
      }
    ]
  },
  {
    "id": "257",
    "slug": "binary-tree-paths",
    "title": "Binary Tree Paths",
    "difficulty": "Easy",
    "description": "Given the `root` of a binary tree, return _all root-to-leaf paths in **any order**_. A **leaf** is a node with no children.",
    "examples": [
      {
        "input": "root = \\[1,2,3,null,5\\]",
        "output": "\\[ \"1->2->5 \", \"1->3 \"\\]"
      },
      {
        "input": "root = \\[1\\]",
        "output": "\\[ \"1 \"\\]"
      }
    ],
    "constraints": [
      "The number of nodes in the tree is in the range `[1, 100]`.",
      "`-100 <= Node.val <= 100`"
    ],
    "companies": [
      {
        "name": "Meta",
        "slug": "facebook",
        "frequency": 3
      }
    ]
  },
  {
    "id": "261",
    "slug": "graph-valid-tree",
    "title": "Graph Valid Tree",
    "difficulty": "Medium",
    "description": "You have a graph of `n` nodes labeled from `0` to `n - 1`. You are given an integer n and a list of `edges` where `edges[i] = [ai, bi]` indicates that there is an undirected edge between nodes `ai` and `bi` in the graph. Return `true` _if the edges of the given graph make up a valid tree, and_ `false` _otherwise_.",
    "examples": [
      {
        "input": "n = 5, edges = \\[\\[0,1\\],\\[0,2\\],\\[0,3\\],\\[1,4\\]\\]",
        "output": "true"
      },
      {
        "input": "n = 5, edges = \\[\\[0,1\\],\\[1,2\\],\\[2,3\\],\\[1,3\\],\\[1,4\\]\\]",
        "output": "false"
      }
    ],
    "constraints": [
      "`1 <= n <= 2000`",
      "`0 <= edges.length <= 5000`",
      "`edges[i].length == 2`",
      "`0 <= ai, bi < n`",
      "`ai != bi`",
      "There are no self-loops or repeated edges."
    ],
    "companies": [
      {
        "name": "LinkedIn",
        "slug": "linkedin",
        "frequency": 4
      },
      {
        "name": "Microsoft",
        "slug": "microsoft",
        "frequency": 3
      },
      {
        "name": "Meta",
        "slug": "facebook",
        "frequency": 2
      },
      {
        "name": "Google",
        "slug": "google",
        "frequency": 2
      },
      {
        "name": "Amazon",
        "slug": "amazon",
        "frequency": 2
      }
    ]
  },
  {
    "id": "268",
    "slug": "missing-number",
    "title": "Missing Number",
    "difficulty": "Easy",
    "description": "Given an array `nums` containing `n` distinct numbers in the range `[0, n]`, return _the only number in the range that is missing from the array._",
    "examples": [
      {
        "input": "nums = \\[3,0,1\\]",
        "output": "2",
        "explanation": "n = 3 since there are 3 numbers, so all numbers are in the range \\[0,3\\]. 2 is the missing number in the range since it does not appear in nums."
      },
      {
        "input": "nums = \\[0,1\\]",
        "output": "2",
        "explanation": "n = 2 since there are 2 numbers, so all numbers are in the range \\[0,2\\]. 2 is the missing number in the range since it does not appear in nums."
      },
      {
        "input": "nums = \\[9,6,4,2,3,5,7,0,1\\]",
        "output": "8",
        "explanation": "n = 9 since there are 9 numbers, so all numbers are in the range \\[0,9\\]. 8 is the missing number in the range since it does not appear in nums."
      }
    ],
    "constraints": [
      "`n == nums.length`",
      "`1 <= n <= 104`",
      "`0 <= nums[i] <= n`",
      "All the numbers of `nums` are unique.",
      "Follow up: Could you implement a solution using only `O(1)` extra space complexity and `O(n)` runtime complexity?"
    ],
    "companies": [
      {
        "name": "Amazon",
        "slug": "amazon",
        "frequency": 9
      },
      {
        "name": "Google",
        "slug": "google",
        "frequency": 5
      },
      {
        "name": "Meta",
        "slug": "facebook",
        "frequency": 5
      },
      {
        "name": "Nvidia",
        "slug": "nvidia",
        "frequency": 3
      },
      {
        "name": "Microsoft",
        "slug": "microsoft",
        "frequency": 2
      },
      {
        "name": "Goldman Sachs",
        "slug": "goldman-sachs",
        "frequency": 2
      },
      {
        "name": "IBM",
        "slug": "ibm",
        "frequency": 2
      }
    ]
  },
  {
    "id": "269",
    "slug": "alien-dictionary",
    "title": "Alien Dictionary",
    "difficulty": "Hard",
    "description": "There is a new alien language that uses the English alphabet. However, the order among the letters is unknown to you. You are given a list of strings `words` from the alien language's dictionary, where the strings in `words` are **sorted lexicographically** by the rules of this new language. Return _a string of the unique letters in the new alien language sorted in **lexicographically increasing order** by the new language's rules._ If there is no solution, return `\" \"`_._ If there are multiple solutions, return _**any of them**_.",
    "examples": [
      {
        "input": "words = \\[ \"wrt \", \"wrf \", \"er \", \"ett \", \"rftt \"\\]",
        "output": "\"wertf \""
      },
      {
        "input": "words = \\[ \"z \", \"x \"\\]",
        "output": "\"zx \""
      },
      {
        "input": "words = \\[ \"z \", \"x \", \"z \"\\]",
        "output": "\" \"",
        "explanation": "The order is invalid, so return ` \" \"`."
      }
    ],
    "constraints": [
      "`1 <= words.length <= 100`",
      "`1 <= words[i].length <= 100`",
      "`words[i]` consists of only lowercase English letters."
    ],
    "companies": [
      {
        "name": "Uber",
        "slug": "uber",
        "frequency": 22
      },
      {
        "name": "Meta",
        "slug": "facebook",
        "frequency": 14
      },
      {
        "name": "Amazon",
        "slug": "amazon",
        "frequency": 8
      },
      {
        "name": "Google",
        "slug": "google",
        "frequency": 6
      },
      {
        "name": "Microsoft",
        "slug": "microsoft",
        "frequency": 5
      },
      {
        "name": "TikTok",
        "slug": "tiktok",
        "frequency": 4
      }
    ]
  },
  {
    "id": "283",
    "slug": "move-zeroes",
    "title": "Move Zeroes",
    "difficulty": "Easy",
    "description": "Given an integer array `nums`, move all `0`'s to the end of it while maintaining the relative order of the non-zero elements. **Note** that you must do this in-place without making a copy of the array.",
    "examples": [
      {
        "input": "nums = \\[0,1,0,3,12\\]",
        "output": "\\[1,3,12,0,0\\]"
      },
      {
        "input": "nums = \\[0\\]",
        "output": "\\[0\\]"
      }
    ],
    "constraints": [
      "`1 <= nums.length <= 104`",
      "`-231 <= nums[i] <= 231 - 1`",
      "Follow up: Could you minimize the total number of operations done?"
    ],
    "companies": [
      {
        "name": "Google",
        "slug": "google",
        "frequency": 22
      },
      {
        "name": "Microsoft",
        "slug": "microsoft",
        "frequency": 10
      },
      {
        "name": "Amazon",
        "slug": "amazon",
        "frequency": 8
      },
      {
        "name": "Apple",
        "slug": "apple",
        "frequency": 6
      },
      {
        "name": "Meta",
        "slug": "facebook",
        "frequency": 5
      },
      {
        "name": "Bloomberg",
        "slug": "bloomberg",
        "frequency": 5
      },
      {
        "name": "Yandex",
        "slug": "yandex",
        "frequency": 4
      },
      {
        "name": "Oracle",
        "slug": "oracle",
        "frequency": 4
      },
      {
        "name": "josh technology",
        "slug": "josh-technology",
        "frequency": 4
      },
      {
        "name": "ServiceNow",
        "slug": "servicenow",
        "frequency": 3
      },
      {
        "name": "Nvidia",
        "slug": "nvidia",
        "frequency": 3
      },
      {
        "name": "TikTok",
        "slug": "tiktok",
        "frequency": 3
      },
      {
        "name": "PayPal",
        "slug": "paypal",
        "frequency": 2
      },
      {
        "name": "Goldman Sachs",
        "slug": "goldman-sachs",
        "frequency": 2
      },
      {
        "name": "NetApp",
        "slug": "netapp",
        "frequency": 2
      },
      {
        "name": "SAP",
        "slug": "sap",
        "frequency": 2
      },
      {
        "name": "Uber",
        "slug": "uber",
        "frequency": 2
      },
      {
        "name": "Adobe",
        "slug": "adobe",
        "frequency": 2
      },
      {
        "name": "Walmart Labs",
        "slug": "walmart-labs",
        "frequency": 2
      },
      {
        "name": "Cisco",
        "slug": "cisco",
        "frequency": 2
      },
      {
        "name": "tcs",
        "slug": "tcs",
        "frequency": 2
      },
      {
        "name": "JTG",
        "slug": "jtg",
        "frequency": 2
      },
      {
        "name": "Anduril",
        "slug": "anduril",
        "frequency": 2
      }
    ]
  },
  {
    "id": "287",
    "slug": "find-the-duplicate-number",
    "title": "Find the Duplicate Number",
    "difficulty": "Medium",
    "description": "Given an array of integers `nums` containing `n + 1` integers where each integer is in the range `[1, n]` inclusive. There is only **one repeated number** in `nums`, return _this repeated number_. You must solve the problem **without** modifying the array `nums` and uses only constant extra space.",
    "examples": [
      {
        "input": "nums = \\[1,3,4,2,2\\]",
        "output": "2"
      },
      {
        "input": "nums = \\[3,1,3,4,2\\]",
        "output": "3"
      }
    ],
    "constraints": [
      "`1 <= n <= 105`",
      "`nums.length == n + 1`",
      "`1 <= nums[i] <= n`",
      "All the integers in `nums` appear only once except for precisely one integer which appears two or more times.",
      "Follow up:",
      "How can we prove that at least one duplicate number must exist in `nums`?",
      "Can you solve the problem in linear runtime complexity?"
    ],
    "companies": [
      {
        "name": "Amazon",
        "slug": "amazon",
        "frequency": 8
      },
      {
        "name": "Google",
        "slug": "google",
        "frequency": 7
      },
      {
        "name": "Microsoft",
        "slug": "microsoft",
        "frequency": 4
      },
      {
        "name": "Citadel",
        "slug": "citadel",
        "frequency": 3
      },
      {
        "name": "Bloomberg",
        "slug": "bloomberg",
        "frequency": 2
      },
      {
        "name": "TikTok",
        "slug": "tiktok",
        "frequency": 2
      },
      {
        "name": "Nvidia",
        "slug": "nvidia",
        "frequency": 2
      },
      {
        "name": "Anduril",
        "slug": "anduril",
        "frequency": 2
      }
    ]
  },
  {
    "id": "295",
    "slug": "find-median-from-data-stream",
    "title": "Find Median from Data Stream",
    "difficulty": "Hard",
    "description": "The **median** is the middle value in an ordered integer list. If the size of the list is even, there is no middle value, and the median is the mean of the two middle values. *  For example, for `arr = [2,3,4]`, the median is `3`. *  For example, for `arr = [2,3]`, the median is `(2 + 3) / 2 = 2.5`. Implement the MedianFinder class: *  `MedianFinder()` initializes the `MedianFinder` object. *  `void addNum(int num)` adds the integer `num` from the data stream to the data structure. *  `double findMedian()` returns the median of all elements so far. Answers within `10-5` of the actual answer will be accepted.",
    "examples": [],
    "constraints": [
      "`-105 <= num <= 105`",
      "There will be at least one element in the data structure before calling `findMedian`.",
      "At most `5  104` calls will be made to `addNum` and `findMedian`.",
      "Follow up:",
      "If all integer numbers from the stream are in the range `[0, 100]`, how would you optimize your solution?",
      "If `99%` of all integer numbers from the stream are in the range `[0, 100]`, how would you optimize your solution?"
    ],
    "companies": [
      {
        "name": "Amazon",
        "slug": "amazon",
        "frequency": 26
      },
      {
        "name": "Meta",
        "slug": "facebook",
        "frequency": 18
      },
      {
        "name": "Google",
        "slug": "google",
        "frequency": 16
      },
      {
        "name": "Pinterest",
        "slug": "pinterest",
        "frequency": 8
      },
      {
        "name": "Apple",
        "slug": "apple",
        "frequency": 4
      },
      {
        "name": "Oracle",
        "slug": "oracle",
        "frequency": 3
      },
      {
        "name": "Nvidia",
        "slug": "nvidia",
        "frequency": 3
      },
      {
        "name": "Tinder",
        "slug": "tinder",
        "frequency": 3
      },
      {
        "name": "Docusign",
        "slug": "docusign",
        "frequency": 3
      },
      {
        "name": "Bloomberg",
        "slug": "bloomberg",
        "frequency": 2
      },
      {
        "name": "Microsoft",
        "slug": "microsoft",
        "frequency": 2
      },
      {
        "name": "Walmart Labs",
        "slug": "walmart-labs",
        "frequency": 2
      },
      {
        "name": "Splunk",
        "slug": "splunk",
        "frequency": 2
      },
      {
        "name": "TikTok",
        "slug": "tiktok",
        "frequency": 2
      },
      {
        "name": "Anduril",
        "slug": "anduril",
        "frequency": 2
      },
      {
        "name": "KLA",
        "slug": "kla",
        "frequency": 2
      },
      {
        "name": "Coupang",
        "slug": "coupang",
        "frequency": 2
      },
      {
        "name": "Uber",
        "slug": "uber",
        "frequency": 2
      },
      {
        "name": "IXL",
        "slug": "ixl",
        "frequency": 2
      },
      {
        "name": "PayPal",
        "slug": "paypal",
        "frequency": 2
      },
      {
        "name": "Snowflake",
        "slug": "snowflake",
        "frequency": 2
      },
      {
        "name": "Okta",
        "slug": "okta",
        "frequency": 2
      }
    ]
  },
  {
    "id": "297",
    "slug": "serialize-and-deserialize-binary-tree",
    "title": "Serialize and Deserialize Binary Tree",
    "difficulty": "Hard",
    "description": "Serialization is the process of converting a data structure or object into a sequence of bits so that it can be stored in a file or memory buffer, or transmitted across a network connection link to be reconstructed later in the same or another computer environment. Design an algorithm to serialize and deserialize a binary tree. There is no restriction on how your serialization/deserialization algorithm should work. You just need to ensure that a binary tree can be serialized to a string and this string can be deserialized to the original tree structure. **Clarification:** The input/output format is the same as [how LeetCode serializes a binary tree](https://support.leetcode.com/hc/en-us/articles/360011883654-What-does-1-null-2-3-mean-in-binary-tree-representation-). You do not necessarily need to follow this format, so please be creative and come up with different approaches yourself.",
    "examples": [
      {
        "input": "root = \\[1,2,3,null,null,4,5\\]",
        "output": "\\[1,2,3,null,null,4,5\\]"
      },
      {
        "input": "root = \\[\\]",
        "output": "\\[\\]"
      }
    ],
    "constraints": [
      "The number of nodes in the tree is in the range `[0, 104]`.",
      "`-1000 <= Node.val <= 1000`"
    ],
    "companies": [
      {
        "name": "Amazon",
        "slug": "amazon",
        "frequency": 14
      },
      {
        "name": "Meta",
        "slug": "facebook",
        "frequency": 7
      },
      {
        "name": "LinkedIn",
        "slug": "linkedin",
        "frequency": 6
      },
      {
        "name": "Microsoft",
        "slug": "microsoft",
        "frequency": 6
      },
      {
        "name": "Google",
        "slug": "google",
        "frequency": 5
      },
      {
        "name": "Apple",
        "slug": "apple",
        "frequency": 3
      },
      {
        "name": "DoorDash",
        "slug": "doordash",
        "frequency": 3
      },
      {
        "name": "TikTok",
        "slug": "tiktok",
        "frequency": 3
      },
      {
        "name": "Uber",
        "slug": "uber",
        "frequency": 2
      },
      {
        "name": "Nvidia",
        "slug": "nvidia",
        "frequency": 2
      },
      {
        "name": "Citadel",
        "slug": "citadel",
        "frequency": 2
      },
      {
        "name": "Qualcomm",
        "slug": "qualcomm",
        "frequency": 2
      }
    ]
  },
  {
    "id": "300",
    "slug": "longest-increasing-subsequence",
    "title": "Longest Increasing Subsequence",
    "difficulty": "Medium",
    "description": "Given an integer array `nums`, return _the length of the longest **strictly increasing**_ _**subsequence**_.",
    "examples": [
      {
        "input": "nums = \\[10,9,2,5,3,7,101,18\\]",
        "output": "4",
        "explanation": "The longest increasing subsequence is \\[2,3,7,101\\], therefore the length is 4."
      },
      {
        "input": "nums = \\[0,1,0,3,2,3\\]",
        "output": "4"
      },
      {
        "input": "nums = \\[7,7,7,7,7,7,7\\]",
        "output": "1"
      }
    ],
    "constraints": [
      "`1 <= nums.length <= 2500`",
      "`-104 <= nums[i] <= 104`",
      "Follow up: Can you come up with an algorithm that runs in `O(n log(n))` time complexity?"
    ],
    "companies": [
      {
        "name": "Google",
        "slug": "google",
        "frequency": 17
      },
      {
        "name": "TikTok",
        "slug": "tiktok",
        "frequency": 15
      },
      {
        "name": "Amazon",
        "slug": "amazon",
        "frequency": 12
      },
      {
        "name": "Meta",
        "slug": "facebook",
        "frequency": 7
      },
      {
        "name": "PayPal",
        "slug": "paypal",
        "frequency": 4
      },
      {
        "name": "Bloomberg",
        "slug": "bloomberg",
        "frequency": 3
      },
      {
        "name": "Squarepoint Capital",
        "slug": "squarepoint-capital",
        "frequency": 3
      },
      {
        "name": "Walmart Labs",
        "slug": "walmart-labs",
        "frequency": 3
      },
      {
        "name": "Splunk",
        "slug": "splunk",
        "frequency": 3
      },
      {
        "name": "Microsoft",
        "slug": "microsoft",
        "frequency": 2
      },
      {
        "name": "Oracle",
        "slug": "oracle",
        "frequency": 2
      },
      {
        "name": "Yandex",
        "slug": "yandex",
        "frequency": 2
      },
      {
        "name": "Flexport",
        "slug": "flexport",
        "frequency": 2
      }
    ]
  },
  {
    "id": "303",
    "slug": "range-sum-query-immutable",
    "title": "Range Sum Query - Immutable",
    "difficulty": "Easy",
    "description": "Given an integer array `nums`, handle multiple queries of the following type: 1. Calculate the **sum** of the elements of `nums` between indices `left` and `right` **inclusive** where `left <= right`. Implement the `NumArray` class: *  `NumArray(int[] nums)` Initializes the object with the integer array `nums`. *  `int sumRange(int left, int right)` Returns the **sum** of the elements of `nums` between indices `left` and `right` **inclusive** (i.e. `nums[left] + nums[left + 1] + ... + nums[right]`).",
    "examples": [],
    "constraints": [
      "`1 <= nums.length <= 104`",
      "`-105 <= nums[i] <= 105`",
      "`0 <= left <= right < nums.length`",
      "At most `104` calls will be made to `sumRange`."
    ],
    "companies": [
      {
        "name": "Meta",
        "slug": "facebook",
        "frequency": 9
      },
      {
        "name": "Google",
        "slug": "google",
        "frequency": 4
      },
      {
        "name": "Amazon",
        "slug": "amazon",
        "frequency": 4
      },
      {
        "name": "Bloomberg",
        "slug": "bloomberg",
        "frequency": 2
      }
    ]
  },
  {
    "id": "309",
    "slug": "best-time-to-buy-and-sell-stock-with-cooldown",
    "title": "Best Time to Buy and Sell Stock with Cooldown",
    "difficulty": "Medium",
    "description": "You are given an array `prices` where `prices[i]` is the price of a given stock on the `ith` day. Find the maximum profit you can achieve. You may complete as many transactions as you like (i.e., buy one and sell one share of the stock multiple times) with the following restrictions: *  After you sell your stock, you cannot buy stock on the next day (i.e., cooldown one day).",
    "examples": [
      {
        "input": "prices = \\[1,2,3,0,2\\]",
        "output": "3",
        "explanation": "transactions = \\[buy, sell, cooldown, buy, sell\\]"
      },
      {
        "input": "prices = \\[1\\]",
        "output": "0"
      }
    ],
    "constraints": ["`1 <= prices.length <= 5000`", "`0 <= prices[i] <= 1000`"],
    "companies": [
      {
        "name": "TikTok",
        "slug": "tiktok",
        "frequency": 2
      },
      {
        "name": "Google",
        "slug": "google",
        "frequency": 2
      }
    ]
  },
  {
    "id": "310",
    "slug": "minimum-height-trees",
    "title": "Minimum Height Trees",
    "difficulty": "Medium",
    "description": "A tree is an undirected graph in which any two vertices are connected by _exactly_ one path. In other words, any connected graph without simple cycles is a tree. Given a tree of `n` nodes labelled from `0` to `n - 1`, and an array of `n - 1` `edges` where `edges[i] = [ai, bi]` indicates that there is an undirected edge between the two nodes `ai` and `bi` in the tree, you can choose any node of the tree as the root. When you select a node `x` as the root, the result tree has height `h`. Among all possible rooted trees, those with minimum height (i.e. `min(h)`) are called **minimum height trees** (MHTs). Return _a list of all **MHTs'** root labels_. You can return the answer in **any order**. The **height** of a rooted tree is the number of edges on the longest downward path between the root and a leaf.",
    "examples": [
      {
        "input": "n = 4, edges = \\[\\[1,0\\],\\[1,2\\],\\[1,3\\]\\]",
        "output": "\\[1\\]",
        "explanation": "As shown, the height of the tree is 1 when the root is the node with label 1 which is the only MHT."
      },
      {
        "input": "n = 6, edges = \\[\\[3,0\\],\\[3,1\\],\\[3,2\\],\\[3,4\\],\\[5,4\\]\\]",
        "output": "\\[3,4\\]"
      }
    ],
    "constraints": [
      "`1 <= n <= 2  104`",
      "`edges.length == n - 1`",
      "`0 <= ai, bi < n`",
      "`ai != bi`",
      "All the pairs `(ai, bi)` are distinct.",
      "The given input is guaranteed to be a tree and there will be no repeated edges."
    ],
    "companies": [
      {
        "name": "Google",
        "slug": "google",
        "frequency": 3
      },
      {
        "name": "Splunk",
        "slug": "splunk",
        "frequency": 2
      }
    ]
  },
  {
    "id": "320",
    "slug": "generalized-abbreviation",
    "title": "Generalized Abbreviation",
    "difficulty": "Medium",
    "description": "A word's **generalized abbreviation** can be constructed by taking any number of **non-overlapping** and **non-adjacent** substrings and replacing them with their respective lengths. *  For example, `\"abcde \"` can be abbreviated into: *  `\"a3e \"` ( `\"bcd \"` turned into `\"3 \"`) *  `\"1bcd1 \"` ( `\"a \"` and `\"e \"` both turned into `\"1 \"`) *  `\"5 \"` ( `\"abcde \"` turned into `\"5 \"`) *  `\"abcde \"` (no substrings replaced) *  However, these abbreviations are **invalid**: *  `\"23 \"` ( `\"ab \"` turned into `\"2 \"` and `\"cde \"` turned into `\"3 \"`) is invalid as the substrings chosen are adjacent. *  `\"22de \"` ( `\"ab \"` turned into `\"2 \"` and `\"bc \"` turned into `\"2 \"`) is invalid as the substring chosen overlap. Given a string `word`, return _a list of all the possible **generalized abbreviations** of_ `word`. Return the answer in **any order**.",
    "examples": [
      {
        "input": "word = \"word\"",
        "output": "\\[\"4\",\"3d\",\"2r1\",\"2rd\",\"1o2\",\"1o1d\",\"1or1\",\"1ord\",\"w3\",\"w2d\",\"w1r1\",\"w1rd\",\"wo2\",\"wo1d\",\"wor1\",\"word\"\\]"
      },
      {
        "input": "word = \"a\"",
        "output": "\\[\"1\",\"a\"\\]"
      }
    ],
    "constraints": [
      "`1 <= word.length <= 15`",
      "`word` consists of only lowercase English letters."
    ],
    "companies": []
  },
  {
    "id": "322",
    "slug": "coin-change",
    "title": "Coin Change",
    "difficulty": "Medium",
    "description": "You are given an integer array `coins` representing coins of different denominations and an integer `amount` representing a total amount of money. Return _the fewest number of coins that you need to make up that amount_. If that amount of money cannot be made up by any combination of the coins, return `-1`. You may assume that you have an infinite number of each kind of coin.",
    "examples": [
      {
        "input": "coins = \\[1,2,5\\], amount = 11",
        "output": "3",
        "explanation": "11 = 5 + 5 + 1"
      },
      {
        "input": "coins = \\[2\\], amount = 3",
        "output": "-1"
      },
      {
        "input": "coins = \\[1\\], amount = 0",
        "output": "0"
      }
    ],
    "constraints": [
      "`1 <= coins.length <= 12`",
      "`1 <= coins[i] <= 231 - 1`",
      "`0 <= amount <= 104`"
    ],
    "companies": [
      {
        "name": "Amazon",
        "slug": "amazon",
        "frequency": 24
      },
      {
        "name": "Google",
        "slug": "google",
        "frequency": 9
      },
      {
        "name": "Bloomberg",
        "slug": "bloomberg",
        "frequency": 8
      },
      {
        "name": "PayPal",
        "slug": "paypal",
        "frequency": 5
      },
      {
        "name": "Oracle",
        "slug": "oracle",
        "frequency": 5
      },
      {
        "name": "Pinterest",
        "slug": "pinterest",
        "frequency": 4
      },
      {
        "name": "Microsoft",
        "slug": "microsoft",
        "frequency": 3
      },
      {
        "name": "Walmart Labs",
        "slug": "walmart-labs",
        "frequency": 3
      },
      {
        "name": "Intuit",
        "slug": "intuit",
        "frequency": 3
      },
      {
        "name": "Datadog",
        "slug": "datadog",
        "frequency": 3
      },
      {
        "name": "Meta",
        "slug": "facebook",
        "frequency": 3
      },
      {
        "name": "Affirm",
        "slug": "affirm",
        "frequency": 3
      },
      {
        "name": "Infosys",
        "slug": "infosys",
        "frequency": 3
      },
      {
        "name": "Goldman Sachs",
        "slug": "goldman-sachs",
        "frequency": 2
      },
      {
        "name": "Salesforce",
        "slug": "salesforce",
        "frequency": 2
      },
      {
        "name": "TikTok",
        "slug": "tiktok",
        "frequency": 2
      },
      {
        "name": "Apple",
        "slug": "apple",
        "frequency": 2
      },
      {
        "name": "Accenture",
        "slug": "accenture",
        "frequency": 2
      }
    ]
  },
  {
    "id": "323",
    "slug": "number-of-connected-components-in-an-undirected-graph",
    "title": "Number of Connected Components in an Undirected Graph",
    "difficulty": "Medium",
    "description": "You have a graph of `n` nodes. You are given an integer `n` and an array `edges` where `edges[i] = [ai, bi]` indicates that there is an edge between `ai` and `bi` in the graph. Return _the number of connected components in the graph_.",
    "examples": [
      {
        "input": "n = 5, edges = \\[\\[0,1\\],\\[1,2\\],\\[3,4\\]\\]",
        "output": "2"
      },
      {
        "input": "n = 5, edges = \\[\\[0,1\\],\\[1,2\\],\\[2,3\\],\\[3,4\\]\\]",
        "output": "1"
      }
    ],
    "constraints": [
      "`1 <= n <= 2000`",
      "`1 <= edges.length <= 5000`",
      "`edges[i].length == 2`",
      "`0 <= ai <= bi < n`",
      "`ai != bi`",
      "There are no repeated edges."
    ],
    "companies": [
      {
        "name": "Amazon",
        "slug": "amazon",
        "frequency": 7
      },
      {
        "name": "General Motors",
        "slug": "general-motors",
        "frequency": 7
      },
      {
        "name": "Google",
        "slug": "google",
        "frequency": 4
      },
      {
        "name": "LinkedIn",
        "slug": "linkedin",
        "frequency": 3
      },
      {
        "name": "Meta",
        "slug": "facebook",
        "frequency": 2
      },
      {
        "name": "TikTok",
        "slug": "tiktok",
        "frequency": 2
      }
    ]
  },
  {
    "id": "327",
    "slug": "count-of-range-sum",
    "title": "Count of Range Sum",
    "difficulty": "Hard",
    "description": "Given an integer array `nums` and two integers `lower` and `upper`, return _the number of range sums that lie in_ `[lower, upper]` _inclusive_. Range sum `S(i, j)` is defined as the sum of the elements in `nums` between indices `i` and `j` inclusive, where `i <= j`.",
    "examples": [
      {
        "input": "nums = \\[-2,5,-1\\], lower = -2, upper = 2",
        "output": "3",
        "explanation": "The three ranges are: \\[0,0\\], \\[2,2\\], and \\[0,2\\] and their respective sums are: -2, -1, 2."
      },
      {
        "input": "nums = \\[0\\], lower = 0, upper = 0",
        "output": "1"
      }
    ],
    "constraints": [
      "`1 <= nums.length <= 105`",
      "`-231 <= nums[i] <= 231 - 1`",
      "`-105 <= lower <= upper <= 105`",
      "The answer is guaranteed to fit in a 32-bit integer."
    ],
    "companies": [
      {
        "name": "Amazon",
        "slug": "amazon",
        "frequency": 4
      },
      {
        "name": "Oracle",
        "slug": "oracle",
        "frequency": 2
      }
    ]
  },
  {
    "id": "328",
    "slug": "odd-even-linked-list",
    "title": "Odd Even Linked List",
    "difficulty": "Medium",
    "description": "Given the `head` of a singly linked list, group all the nodes with odd indices together followed by the nodes with even indices, and return _the reordered list_. The **first** node is considered **odd**, and the **second** node is **even**, and so on. Note that the relative order inside both the even and odd groups should remain as it was in the input. You must solve the problem in `O(1)` extra space complexity and `O(n)` time complexity.",
    "examples": [
      {
        "input": "head = \\[1,2,3,4,5\\]",
        "output": "\\[1,3,5,2,4\\]"
      },
      {
        "input": "head = \\[2,1,3,5,6,4,7\\]",
        "output": "\\[2,3,6,7,1,5,4\\]"
      }
    ],
    "constraints": [
      "The number of nodes in the linked list is in the range `[0, 104]`.",
      "`-106 <= Node.val <= 106`"
    ],
    "companies": [
      {
        "name": "Google",
        "slug": "google",
        "frequency": 8
      },
      {
        "name": "Amazon",
        "slug": "amazon",
        "frequency": 7
      },
      {
        "name": "Meta",
        "slug": "facebook",
        "frequency": 5
      },
      {
        "name": "Bloomberg",
        "slug": "bloomberg",
        "frequency": 2
      },
      {
        "name": "Zoho",
        "slug": "zoho",
        "frequency": 2
      }
    ]
  },
  {
    "id": "336",
    "slug": "palindrome-pairs",
    "title": "Palindrome Pairs",
    "difficulty": "Hard",
    "description": "You are given a **0-indexed** array of **unique** strings `words`. A **palindrome pair** is a pair of integers `(i, j)` such that: *  `0 <= i, j < words.length`, *  `i != j`, and *  `words[i] + words[j]` (the concatenation of the two strings) is a palindrome. Return _an array of all the **palindrome pairs** of_ `words`.",
    "examples": [
      {
        "input": "words = \\[ \"abcd \", \"dcba \", \"lls \", \"s \", \"sssll \"\\]",
        "output": "\\[\\[0,1\\],\\[1,0\\],\\[3,2\\],\\[2,4\\]\\]",
        "explanation": "The palindromes are \\[ \"abcddcba \", \"dcbaabcd \", \"slls \", \"llssssll \"\\]"
      },
      {
        "input": "words = \\[ \"bat \", \"tab \", \"cat \"\\]",
        "output": "\\[\\[0,1\\],\\[1,0\\]\\]",
        "explanation": "The palindromes are \\[ \"battab \", \"tabbat \"\\]"
      },
      {
        "input": "words = \\[ \"a \", \" \"\\]",
        "output": "\\[\\[0,1\\],\\[1,0\\]\\]",
        "explanation": "The palindromes are \\[ \"a \", \"a \"\\]"
      }
    ],
    "constraints": [
      "`1 <= words.length <= 5000`",
      "`0 <= words[i].length <= 300`",
      "`words[i]` consists of lowercase English letters."
    ],
    "companies": [
      {
        "name": "Amazon",
        "slug": "amazon",
        "frequency": 3
      },
      {
        "name": "Airbnb",
        "slug": "airbnb",
        "frequency": 2
      },
      {
        "name": "Goldman Sachs",
        "slug": "goldman-sachs",
        "frequency": 2
      },
      {
        "name": "Google",
        "slug": "google",
        "frequency": 2
      }
    ]
  },
  {
    "id": "338",
    "slug": "counting-bits",
    "title": "Counting Bits",
    "difficulty": "Easy",
    "description": "Given an integer `n`, return _an array_ `ans` _of length_ `n + 1` _such that for each_ `i` (`0 <= i <= n`)_,_ `ans[i]` _is the **number of**_ `1`_**'s** in the binary representation of_ `i`.",
    "examples": [
      {
        "input": "n = 2",
        "output": "\\[0,1,1\\]",
        "explanation": ""
      },
      {
        "input": "n = 5",
        "output": "\\[0,1,1,2,1,2\\]",
        "explanation": ""
      }
    ],
    "constraints": [
      "`0 <= n <= 105`",
      "Follow up:",
      "It is very easy to come up with a solution with a runtime of `O(n log n)`. Can you do it in linear time `O(n)` and possibly in a single pass?",
      "Can you do it without using any built-in function (i.e., like `__builtin_popcount` in C++)?"
    ],
    "companies": [
      {
        "name": "Microsoft",
        "slug": "microsoft",
        "frequency": 4
      },
      {
        "name": "Amazon",
        "slug": "amazon",
        "frequency": 4
      },
      {
        "name": "Google",
        "slug": "google",
        "frequency": 3
      },
      {
        "name": "Meta",
        "slug": "facebook",
        "frequency": 2
      }
    ]
  },
  {
    "id": "347",
    "slug": "top-k-frequent-elements",
    "title": "Top K Frequent Elements",
    "difficulty": "Medium",
    "description": "Given an integer array `nums` and an integer `k`, return _the_ `k` _most frequent elements_. You may return the answer in **any order**.",
    "examples": [
      {
        "input": "nums = \\[1,1,1,2,2,3\\], k = 2",
        "output": "\\[1,2\\]"
      },
      {
        "input": "nums = \\[1\\], k = 1",
        "output": "\\[1\\]"
      }
    ],
    "constraints": [
      "`1 <= nums.length <= 105`",
      "`-104 <= nums[i] <= 104`",
      "`k` is in the range `[1, the number of unique elements in the array]`.",
      "It is guaranteed that the answer is unique.",
      "Follow up: Your algorithm's time complexity must be better than `O(n log n)`, where n is the array's size."
    ],
    "companies": [
      {
        "name": "Meta",
        "slug": "facebook",
        "frequency": 103
      },
      {
        "name": "Amazon",
        "slug": "amazon",
        "frequency": 42
      },
      {
        "name": "Google",
        "slug": "google",
        "frequency": 19
      },
      {
        "name": "Apple",
        "slug": "apple",
        "frequency": 12
      },
      {
        "name": "Microsoft",
        "slug": "microsoft",
        "frequency": 6
      },
      {
        "name": "Oracle",
        "slug": "oracle",
        "frequency": 6
      },
      {
        "name": "Avito",
        "slug": "avito",
        "frequency": 4
      },
      {
        "name": "Bloomberg",
        "slug": "bloomberg",
        "frequency": 3
      },
      {
        "name": "Uber",
        "slug": "uber",
        "frequency": 3
      },
      {
        "name": "Adobe",
        "slug": "adobe",
        "frequency": 3
      },
      {
        "name": "Goldman Sachs",
        "slug": "goldman-sachs",
        "frequency": 3
      },
      {
        "name": "Salesforce",
        "slug": "salesforce",
        "frequency": 3
      },
      {
        "name": "Intuit",
        "slug": "intuit",
        "frequency": 3
      },
      {
        "name": "Atlassian",
        "slug": "atlassian",
        "frequency": 2
      },
      {
        "name": "ByteDance",
        "slug": "bytedance",
        "frequency": 2
      },
      {
        "name": "TikTok",
        "slug": "tiktok",
        "frequency": 2
      },
      {
        "name": "Nutanix",
        "slug": "nutanix",
        "frequency": 2
      },
      {
        "name": "Twilio",
        "slug": "twilio",
        "frequency": 2
      },
      {
        "name": "Pinterest",
        "slug": "pinterest",
        "frequency": 2
      },
      {
        "name": "Microstrategy",
        "slug": "microstrategy",
        "frequency": 2
      }
    ]
  },
  {
    "id": "358",
    "slug": "rearrange-string-k-distance-apart",
    "title": "Rearrange String k Distance Apart",
    "difficulty": "Hard",
    "description": "Given a string `s` and an integer `k`, rearrange `s` such that the same characters are **at least** distance `k` from each other. If it is not possible to rearrange the string, return an empty string `\" \"`.",
    "examples": [
      {
        "input": "s =  \"aabbcc \", k = 3",
        "output": "\"abcabc \"",
        "explanation": "The same letters are at least a distance of 3 from each other."
      },
      {
        "input": "s =  \"aaabc \", k = 3",
        "output": "\" \"",
        "explanation": "It is not possible to rearrange the string."
      },
      {
        "input": "s =  \"aaadbbcc \", k = 2",
        "output": "\"abacabcd \"",
        "explanation": "The same letters are at least a distance of 2 from each other."
      }
    ],
    "constraints": [
      "`1 <= s.length <= 3  105`",
      "`s` consists of only lowercase English letters.",
      "`0 <= k <= s.length`"
    ],
    "companies": [
      {
        "name": "Amazon",
        "slug": "amazon",
        "frequency": 5
      },
      {
        "name": "TikTok",
        "slug": "tiktok",
        "frequency": 2
      }
    ]
  },
  {
    "id": "373",
    "slug": "find-k-pairs-with-smallest-sums",
    "title": "Find K Pairs with Smallest Sums",
    "difficulty": "Medium",
    "description": "You are given two integer arrays `nums1` and `nums2` sorted in **ascending order** and an integer `k`. Define a pair `(u, v)` which consists of one element from the first array and one element from the second array. Return _the_ `k` _pairs_ `(u1, v1), (u2, v2), ..., (uk, vk)` _with the smallest sums_.",
    "examples": [
      {
        "input": "nums1 = \\[1,7,11\\], nums2 = \\[2,4,6\\], k = 3",
        "output": "\\[\\[1,2\\],\\[1,4\\],\\[1,6\\]\\]",
        "explanation": "The first 3 pairs are returned from the sequence: \\[1,2\\],\\[1,4\\],\\[1,6\\],\\[7,2\\],\\[7,4\\],\\[11,2\\],\\[7,6\\],\\[11,4\\],\\[11,6\\]"
      },
      {
        "input": "nums1 = \\[1,1,2\\], nums2 = \\[1,2,3\\], k = 2",
        "output": "\\[\\[1,1\\],\\[1,1\\]\\]",
        "explanation": "The first 2 pairs are returned from the sequence: \\[1,1\\],\\[1,1\\],\\[1,2\\],\\[2,1\\],\\[1,2\\],\\[2,2\\],\\[1,3\\],\\[1,3\\],\\[2,3\\]"
      },
      {
        "input": "nums1 = \\[1,2\\], nums2 = \\[3\\], k = 3",
        "output": "\\[\\[1,3\\],\\[2,3\\]\\]",
        "explanation": "All possible pairs are returned from the sequence: \\[1,3\\],\\[2,3\\]"
      }
    ],
    "constraints": [
      "`1 <= nums1.length, nums2.length <= 105`",
      "`-109 <= nums1[i], nums2[i] <= 109`",
      "`nums1` and `nums2` both are sorted in ascending order.",
      "`1 <= k <= 104`"
    ],
    "companies": [
      {
        "name": "LinkedIn",
        "slug": "linkedin",
        "frequency": 8
      },
      {
        "name": "Amazon",
        "slug": "amazon",
        "frequency": 6
      },
      {
        "name": "Google",
        "slug": "google",
        "frequency": 2
      },
      {
        "name": "Meta",
        "slug": "facebook",
        "frequency": 2
      },
      {
        "name": "Microsoft",
        "slug": "microsoft",
        "frequency": 2
      },
      {
        "name": "Walmart Labs",
        "slug": "walmart-labs",
        "frequency": 2
      },
      {
        "name": "Flipkart",
        "slug": "flipkart",
        "frequency": 2
      }
    ]
  },
  {
    "id": "377",
    "slug": "combination-sum-iv",
    "title": "Combination Sum IV",
    "difficulty": "Medium",
    "description": "Given an array of **distinct** integers `nums` and a target integer `target`, return _the number of possible combinations that add up to_ `target`. The test cases are generated so that the answer can fit in a **32-bit** integer.",
    "examples": [
      {
        "input": "nums = \\[1,2,3\\], target = 4",
        "output": "7",
        "explanation": ""
      },
      {
        "input": "nums = \\[9\\], target = 3",
        "output": "0"
      }
    ],
    "constraints": [
      "`1 <= nums.length <= 200`",
      "`1 <= nums[i] <= 1000`",
      "All the elements of `nums` are unique.",
      "`1 <= target <= 1000`",
      "Follow up: What if negative numbers are allowed in the given array? How does it change the problem? What limitation we need to add to the question to allow negative numbers?"
    ],
    "companies": [
      {
        "name": "Google",
        "slug": "google",
        "frequency": 4
      },
      {
        "name": "Meta",
        "slug": "facebook",
        "frequency": 2
      },
      {
        "name": "TikTok",
        "slug": "tiktok",
        "frequency": 2
      }
    ]
  },
  {
    "id": "378",
    "slug": "kth-smallest-element-in-a-sorted-matrix",
    "title": "Kth Smallest Element in a Sorted Matrix",
    "difficulty": "Medium",
    "description": "Given an `n x n` `matrix` where each of the rows and columns is sorted in ascending order, return _the_ `kth` _smallest element in the matrix_. Note that it is the `kth` smallest element **in the sorted order**, not the `kth` **distinct** element. You must find a solution with a memory complexity better than `O(n2)`.",
    "examples": [
      {
        "input": "matrix = \\[\\[1,5,9\\],\\[10,11,13\\],\\[12,13,15\\]\\], k = 8",
        "output": "13",
        "explanation": "The elements in the matrix are \\[1,5,9,10,11,12,13,**13**,15\\], and the 8th smallest number is 13"
      },
      {
        "input": "matrix = \\[\\[-5\\]\\], k = 1",
        "output": "-5"
      }
    ],
    "constraints": [
      "`n == matrix.length == matrix[i].length`",
      "`1 <= n <= 300`",
      "`-109 <= matrix[i][j] <= 109`",
      "All the rows and columns of `matrix` are guaranteed to be sorted in non-decreasing order.",
      "`1 <= k <= n2`",
      "Follow up:",
      "Could you solve the problem with a constant memory (i.e., `O(1)` memory complexity)?",
      "Could you solve the problem in `O(n)` time complexity? The solution may be too advanced for an interview but you may find reading [this paper](http://www.cse.yorku.ca/~andy/pubs/X+Y.pdf) fun."
    ],
    "companies": [
      {
        "name": "Meta",
        "slug": "facebook",
        "frequency": 18
      },
      {
        "name": "Amazon",
        "slug": "amazon",
        "frequency": 8
      },
      {
        "name": "TikTok",
        "slug": "tiktok",
        "frequency": 4
      },
      {
        "name": "PhonePe",
        "slug": "phonepe",
        "frequency": 3
      },
      {
        "name": "Apple",
        "slug": "apple",
        "frequency": 2
      }
    ]
  },
  {
    "id": "392",
    "slug": "is-subsequence",
    "title": "Is Subsequence",
    "difficulty": "Easy",
    "description": "Given two strings `s` and `t`, return `true` _if_ `s` _is a **subsequence** of_ `t`_, or_ `false` _otherwise_. A **subsequence** of a string is a new string that is formed from the original string by deleting some (can be none) of the characters without disturbing the relative positions of the remaining characters. (i.e., `\"ace \"` is a subsequence of `\"abcde \"` while `\"aec \"` is not).",
    "examples": [
      {
        "input": "s = \"abc\", t = \"ahbgdc\"",
        "output": "true"
      },
      {
        "input": "s = \"axc\", t = \"ahbgdc\"",
        "output": "false"
      }
    ],
    "constraints": [
      "`0 <= s.length <= 100`",
      "`0 <= t.length <= 104`",
      "`s` and `t` consist only of lowercase English letters.",
      "Follow up: Suppose there are lots of incoming `s`, say `s1, s2, ..., sk` where `k >= 109`, and you want to check one by one to see if `t` has its subsequence. In this scenario, how would you change your code?"
    ],
    "companies": [
      {
        "name": "Amazon",
        "slug": "amazon",
        "frequency": 6
      },
      {
        "name": "Google",
        "slug": "google",
        "frequency": 4
      },
      {
        "name": "Yandex",
        "slug": "yandex",
        "frequency": 4
      },
      {
        "name": "Meta",
        "slug": "facebook",
        "frequency": 3
      },
      {
        "name": "Microsoft",
        "slug": "microsoft",
        "frequency": 2
      },
      {
        "name": "Pinterest",
        "slug": "pinterest",
        "frequency": 2
      }
    ]
  },
  {
    "id": "416",
    "slug": "partition-equal-subset-sum",
    "title": "Partition Equal Subset Sum",
    "difficulty": "Medium",
    "description": "Given an integer array `nums`, return `true` _if you can partition the array into two subsets such that the sum of the elements in both subsets is equal or_ `false` _otherwise_.",
    "examples": [
      {
        "input": "nums = \\[1,5,11,5\\]",
        "output": "true",
        "explanation": "The array can be partitioned as \\[1, 5, 5\\] and \\[11\\]."
      },
      {
        "input": "nums = \\[1,2,3,5\\]",
        "output": "false",
        "explanation": "The array cannot be partitioned into equal sum subsets."
      }
    ],
    "constraints": ["`1 <= nums.length <= 200`", "`1 <= nums[i] <= 100`"],
    "companies": [
      {
        "name": "Google",
        "slug": "google",
        "frequency": 11
      },
      {
        "name": "Amazon",
        "slug": "amazon",
        "frequency": 8
      },
      {
        "name": "Meta",
        "slug": "facebook",
        "frequency": 5
      },
      {
        "name": "Bloomberg",
        "slug": "bloomberg",
        "frequency": 3
      },
      {
        "name": "Microsoft",
        "slug": "microsoft",
        "frequency": 2
      },
      {
        "name": "tcs",
        "slug": "tcs",
        "frequency": 2
      },
      {
        "name": "TikTok",
        "slug": "tiktok",
        "frequency": 2
      },
      {
        "name": "Zoho",
        "slug": "zoho",
        "frequency": 2
      },
      {
        "name": "EPAM Systems",
        "slug": "epam-systems",
        "frequency": 2
      }
    ]
  },
  {
    "id": "417",
    "slug": "pacific-atlantic-water-flow",
    "title": "Pacific Atlantic Water Flow",
    "difficulty": "Medium",
    "description": "There is an `m x n` rectangular island that borders both the **Pacific Ocean** and **Atlantic Ocean**. The **Pacific Ocean** touches the island's left and top edges, and the **Atlantic Ocean** touches the island's right and bottom edges. The island is partitioned into a grid of square cells. You are given an `m x n` integer matrix `heights` where `heights[r][c]` represents the **height above sea level** of the cell at coordinate `(r, c)`. The island receives a lot of rain, and the rain water can flow to neighboring cells directly north, south, east, and west if the neighboring cell's height is **less than or equal to** the current cell's height. Water can flow from any cell adjacent to an ocean into the ocean. Return _a **2D list** of grid coordinates_ `result` _where_ `result[i] = [ri, ci]` _denotes that rain water can flow from cell_ `(ri, ci)` _to **both** the Pacific and Atlantic oceans_.",
    "examples": [
      {
        "input": "heights = \\[\\[1,2,2,3,5\\],\\[3,2,3,4,4\\],\\[2,4,5,3,1\\],\\[6,7,1,4,5\\],\\[5,1,1,2,4\\]\\]",
        "output": "\\[\\[0,4\\],\\[1,3\\],\\[1,4\\],\\[2,2\\],\\[3,0\\],\\[3,1\\],\\[4,0\\]\\]",
        "explanation": "The following cells can flow to the Pacific and Atlantic oceans, as shown below:"
      },
      {
        "input": "heights = \\[\\[1\\]\\]",
        "output": "\\[\\[0,0\\]\\]",
        "explanation": "The water can flow from the only cell to the Pacific and Atlantic oceans."
      }
    ],
    "constraints": [
      "`m == heights.length`",
      "`n == heights[r].length`",
      "`1 <= m, n <= 200`",
      "`0 <= heights[r][c] <= 105`"
    ],
    "companies": [
      {
        "name": "Google",
        "slug": "google",
        "frequency": 9
      },
      {
        "name": "Amazon",
        "slug": "amazon",
        "frequency": 8
      },
      {
        "name": "ServiceNow",
        "slug": "servicenow",
        "frequency": 2
      }
    ]
  },
  {
    "id": "421",
    "slug": "maximum-xor-of-two-numbers-in-an-array",
    "title": "Maximum XOR of Two Numbers in an Array",
    "difficulty": "Medium",
    "description": "Given an integer array `nums`, return _the maximum result of_ `nums[i] XOR nums[j]`, where `0 <= i <= j < n`.",
    "examples": [
      {
        "input": "nums = \\[3,10,5,25,2,8\\]",
        "output": "28",
        "explanation": "The maximum result is 5 XOR 25 = 28."
      },
      {
        "input": "nums = \\[14,70,53,83,49,91,36,80,92,51,66,70\\]",
        "output": "127"
      }
    ],
    "constraints": [
      "`1 <= nums.length <= 2  105`",
      "`0 <= nums[i] <= 231 - 1`"
    ],
    "companies": [
      {
        "name": "Google",
        "slug": "google",
        "frequency": 3
      },
      {
        "name": "Goldman Sachs",
        "slug": "goldman-sachs",
        "frequency": 3
      }
    ]
  },
  {
    "id": "424",
    "slug": "longest-repeating-character-replacement",
    "title": "Longest Repeating Character Replacement",
    "difficulty": "Medium",
    "description": "You are given a string `s` and an integer `k`. You can choose any character of the string and change it to any other uppercase English character. You can perform this operation at most `k` times. Return _the length of the longest substring containing the same letter you can get after performing the above operations_.",
    "examples": [
      {
        "input": "s =  \"ABAB \", k = 2",
        "output": "4",
        "explanation": "Replace the two 'A's with two 'B's or vice versa."
      },
      {
        "input": "s =  \"AABABBA \", k = 1",
        "output": "4",
        "explanation": "Replace the one 'A' in the middle with 'B' and form  \"AABBBBA \"."
      }
    ],
    "constraints": [
      "`1 <= s.length <= 105`",
      "`s` consists of only uppercase English letters.",
      "`0 <= k <= s.length`"
    ],
    "companies": [
      {
        "name": "Google",
        "slug": "google",
        "frequency": 14
      },
      {
        "name": "Amazon",
        "slug": "amazon",
        "frequency": 10
      },
      {
        "name": "Bloomberg",
        "slug": "bloomberg",
        "frequency": 8
      },
      {
        "name": "Meta",
        "slug": "facebook",
        "frequency": 6
      },
      {
        "name": "Uber",
        "slug": "uber",
        "frequency": 4
      },
      {
        "name": "Adobe",
        "slug": "adobe",
        "frequency": 2
      },
      {
        "name": "Goldman Sachs",
        "slug": "goldman-sachs",
        "frequency": 2
      },
      {
        "name": "ByteDance",
        "slug": "bytedance",
        "frequency": 2
      },
      {
        "name": "UiPath",
        "slug": "uipath",
        "frequency": 2
      },
      {
        "name": "Microsoft",
        "slug": "microsoft",
        "frequency": 2
      },
      {
        "name": "Apple",
        "slug": "apple",
        "frequency": 2
      },
      {
        "name": "Yandex",
        "slug": "yandex",
        "frequency": 2
      },
      {
        "name": "Flipkart",
        "slug": "flipkart",
        "frequency": 2
      }
    ]
  },
  {
    "id": "425",
    "slug": "word-squares",
    "title": "Word Squares",
    "difficulty": "Hard",
    "description": "Given an array of **unique** strings `words`, return _all the_ **[word squares](https://en.wikipedia.org/wiki/Word_square)** _you can build from_ `words`. The same word from `words` can be used **multiple times**. You can return the answer in **any order**. A sequence of strings forms a valid **word square** if the `kth` row and column read the same string, where `0 <= k < max(numRows, numColumns)`. *  For example, the word sequence `[ \"ball \", \"area \", \"lead \", \"lady \"]` forms a word square because each word reads the same both horizontally and vertically.",
    "examples": [
      {
        "input": "words = \\[ \"area \", \"lead \", \"wall \", \"lady \", \"ball \"\\]",
        "output": "\\[\\[ \"ball \", \"area \", \"lead \", \"lady \"\\],\\[ \"wall \", \"area \", \"lead \", \"lady \"\\]\\]",
        "explanation": ""
      },
      {
        "input": "words = \\[ \"abat \", \"baba \", \"atan \", \"atal \"\\]",
        "output": "\\[\\[ \"baba \", \"abat \", \"baba \", \"atal \"\\],\\[ \"baba \", \"abat \", \"baba \", \"atan \"\\]\\]",
        "explanation": ""
      }
    ],
    "constraints": [
      "`1 <= words.length <= 1000`",
      "`1 <= words[i].length <= 4`",
      "All `words[i]` have the same length.",
      "`words[i]` consists of only lowercase English letters.",
      "All `words[i]` are unique."
    ],
    "companies": []
  },
  {
    "id": "435",
    "slug": "non-overlapping-intervals",
    "title": "Non-overlapping Intervals",
    "difficulty": "Medium",
    "description": "Given an array of intervals `intervals` where `intervals[i] = [starti, endi]`, return _the minimum number of intervals you need to remove to make the rest of the intervals non-overlapping_.",
    "examples": [
      {
        "input": "intervals = \\[\\[1,2\\],\\[2,3\\],\\[3,4\\],\\[1,3\\]\\]",
        "output": "1",
        "explanation": "\\[1,3\\] can be removed and the rest of the intervals are non-overlapping."
      },
      {
        "input": "intervals = \\[\\[1,2\\],\\[1,2\\],\\[1,2\\]\\]",
        "output": "2",
        "explanation": "You need to remove two \\[1,2\\] to make the rest of the intervals non-overlapping."
      },
      {
        "input": "intervals = \\[\\[1,2\\],\\[2,3\\]\\]",
        "output": "0",
        "explanation": "You don't need to remove any of the intervals since they're already non-overlapping."
      }
    ],
    "constraints": [
      "`1 <= intervals.length <= 105`",
      "`intervals[i].length == 2`",
      "`-5  104 <= starti < endi <= 5  104`"
    ],
    "companies": [
      {
        "name": "Amazon",
        "slug": "amazon",
        "frequency": 6
      },
      {
        "name": "Zoho",
        "slug": "zoho",
        "frequency": 4
      },
      {
        "name": "Google",
        "slug": "google",
        "frequency": 3
      },
      {
        "name": "Meta",
        "slug": "facebook",
        "frequency": 3
      },
      {
        "name": "Microsoft",
        "slug": "microsoft",
        "frequency": 3
      },
      {
        "name": "Verkada",
        "slug": "verkada",
        "frequency": 2
      },
      {
        "name": "Goldman Sachs",
        "slug": "goldman-sachs",
        "frequency": 2
      },
      {
        "name": "J.P. Morgan",
        "slug": "jpmorgan",
        "frequency": 2
      },
      {
        "name": "Capital One",
        "slug": "capital-one",
        "frequency": 2
      },
      {
        "name": "Snowflake",
        "slug": "snowflake",
        "frequency": 2
      }
    ]
  },
  {
    "id": "437",
    "slug": "path-sum-iii",
    "title": "Path Sum III",
    "difficulty": "Medium",
    "description": "Given the `root` of a binary tree and an integer `targetSum`, return _the number of paths where the sum of the values along the path equals_ `targetSum`. The path does not need to start or end at the root or a leaf, but it must go downwards (i.e., traveling only from parent nodes to child nodes).",
    "examples": [
      {
        "input": "root = \\[10,5,-3,3,2,null,11,3,-2,null,1\\], targetSum = 8",
        "output": "3",
        "explanation": "The paths that sum to 8 are shown."
      },
      {
        "input": "root = \\[5,4,8,11,null,13,4,7,2,null,null,5,1\\], targetSum = 22",
        "output": "3"
      }
    ],
    "constraints": [
      "The number of nodes in the tree is in the range `[0, 1000]`.",
      "`-109 <= Node.val <= 109`",
      "`-1000 <= targetSum <= 1000`"
    ],
    "companies": [
      {
        "name": "Microsoft",
        "slug": "microsoft",
        "frequency": 3
      },
      {
        "name": "Bloomberg",
        "slug": "bloomberg",
        "frequency": 3
      },
      {
        "name": "Meta",
        "slug": "facebook",
        "frequency": 2
      },
      {
        "name": "Amazon",
        "slug": "amazon",
        "frequency": 2
      },
      {
        "name": "Salesforce",
        "slug": "salesforce",
        "frequency": 2
      },
      {
        "name": "Google",
        "slug": "google",
        "frequency": 2
      }
    ]
  },
  {
    "id": "442",
    "slug": "find-all-duplicates-in-an-array",
    "title": "Find All Duplicates in an Array",
    "difficulty": "Medium",
    "description": "Given an integer array `nums` of length `n` where all the integers of `nums` are in the range `[1, n]` and each integer appears **once** or **twice**, return _an array of all the integers that appears **twice**_. You must write an algorithm that runs in `O(n)` time and uses only constant extra space.",
    "examples": [
      {
        "input": "nums = \\[4,3,2,7,8,2,3,1\\]",
        "output": "\\[2,3\\]"
      },
      {
        "input": "nums = \\[1,1,2\\]",
        "output": "\\[1\\]"
      },
      {
        "input": "nums = \\[1\\]",
        "output": "\\[\\]"
      }
    ],
    "constraints": [
      "`n == nums.length`",
      "`1 <= n <= 105`",
      "`1 <= nums[i] <= n`",
      "Each element in `nums` appears once or twice."
    ],
    "companies": [
      {
        "name": "Google",
        "slug": "google",
        "frequency": 8
      },
      {
        "name": "Amazon",
        "slug": "amazon",
        "frequency": 7
      },
      {
        "name": "TikTok",
        "slug": "tiktok",
        "frequency": 4
      },
      {
        "name": "Microsoft",
        "slug": "microsoft",
        "frequency": 3
      },
      {
        "name": "Meta",
        "slug": "facebook",
        "frequency": 2
      },
      {
        "name": "Oracle",
        "slug": "oracle",
        "frequency": 2
      }
    ]
  },
  {
    "id": "444",
    "slug": "sequence-reconstruction",
    "title": "Sequence Reconstruction",
    "difficulty": "Medium",
    "description": "You are given an integer array `nums` of length `n` where `nums` is a permutation of the integers in the range `[1, n]`. You are also given a 2D integer array `sequences` where `sequences[i]` is a subsequence of `nums`. Check if `nums` is the shortest possible and the only **supersequence**. The shortest **supersequence** is a sequence **with the shortest length** and has all `sequences[i]` as subsequences. There could be multiple valid **supersequences** for the given array `sequences`. *  For example, for `sequences = [[1,2],[1,3]]`, there are two shortest **supersequences**, `[1,2,3]` and `[1,3,2]`. *  While for `sequences = [[1,2],[1,3],[1,2,3]]`, the only shortest **supersequence** possible is `[1,2,3]`. `[1,2,3,4]` is a possible supersequence but not the shortest. Return `true` _if_ `nums` _is the only shortest **supersequence** for_ `sequences`_, or_ `false` _otherwise_. A **subsequence** is a sequence that can be derived from another sequence by deleting some or no elements without changing the order of the remaining elements.",
    "examples": [
      {
        "input": "nums = \\[1,2,3\\], sequences = \\[\\[1,2\\],\\[1,3\\]\\]",
        "output": "false",
        "explanation": "There are two possible supersequences: \\[1,2,3\\] and \\[1,3,2\\]."
      },
      {
        "input": "nums = \\[1,2,3\\], sequences = \\[\\[1,2\\]\\]",
        "output": "false",
        "explanation": "The shortest possible supersequence is \\[1,2\\]."
      },
      {
        "input": "nums = \\[1,2,3\\], sequences = \\[\\[1,2\\],\\[1,3\\],\\[2,3\\]\\]",
        "output": "true",
        "explanation": "The shortest possible supersequence is \\[1,2,3\\]."
      }
    ],
    "constraints": [
      "`n == nums.length`",
      "`1 <= n <= 104`",
      "`nums` is a permutation of all the integers in the range `[1, n]`.",
      "`1 <= sequences.length <= 104`",
      "`1 <= sequences[i].length <= 104`",
      "`1 <= sum(sequences[i].length) <= 105`",
      "`1 <= sequences[i][j] <= n`",
      "All the arrays of `sequences` are unique.",
      "`sequences[i]` is a subsequence of `nums`."
    ],
    "companies": [
      {
        "name": "Google",
        "slug": "google",
        "frequency": 2
      }
    ]
  },
  {
    "id": "448",
    "slug": "find-all-numbers-disappeared-in-an-array",
    "title": "Find All Numbers Disappeared in an Array",
    "difficulty": "Easy",
    "description": "Given an array `nums` of `n` integers where `nums[i]` is in the range `[1, n]`, return _an array of all the integers in the range_ `[1, n]` _that do not appear in_ `nums`.",
    "examples": [
      {
        "input": "nums = \\[4,3,2,7,8,2,3,1\\]",
        "output": "\\[5,6\\]"
      },
      {
        "input": "nums = \\[1,1\\]",
        "output": "\\[2\\]"
      }
    ],
    "constraints": [
      "`n == nums.length`",
      "`1 <= n <= 105`",
      "`1 <= nums[i] <= n`",
      "Follow up: Could you do it without extra space and in `O(n)` runtime? You may assume the returned list does not count as extra space."
    ],
    "companies": [
      {
        "name": "Google",
        "slug": "google",
        "frequency": 4
      },
      {
        "name": "Amazon",
        "slug": "amazon",
        "frequency": 3
      },
      {
        "name": "Tinkoff",
        "slug": "tinkoff",
        "frequency": 2
      }
    ]
  },
  {
    "id": "451",
    "slug": "sort-characters-by-frequency",
    "title": "Sort Characters By Frequency",
    "difficulty": "Medium",
    "description": "Given a string `s`, sort it in **decreasing order** based on the **frequency** of the characters. The **frequency** of a character is the number of times it appears in the string. Return _the sorted string_. If there are multiple answers, return _any of them_.",
    "examples": [
      {
        "input": "s =  \"tree \"",
        "output": "\"eert \"",
        "explanation": "'e' appears twice while 'r' and 't' both appear once."
      },
      {
        "input": "s =  \"cccaaa \"",
        "output": "\"aaaccc \"",
        "explanation": "Both 'c' and 'a' appear three times, so both  \"cccaaa \" and  \"aaaccc \" are valid answers."
      },
      {
        "input": "s =  \"Aabb \"",
        "output": "\"bbAa \"",
        "explanation": "\"bbaA \" is also a valid answer, but  \"Aabb \" is incorrect."
      }
    ],
    "constraints": [
      "`1 <= s.length <= 5  105`",
      "`s` consists of uppercase and lowercase English letters and digits."
    ],
    "companies": [
      {
        "name": "Bloomberg",
        "slug": "bloomberg",
        "frequency": 4
      },
      {
        "name": "Amazon",
        "slug": "amazon",
        "frequency": 3
      },
      {
        "name": "Microsoft",
        "slug": "microsoft",
        "frequency": 3
      },
      {
        "name": "Meta",
        "slug": "facebook",
        "frequency": 3
      },
      {
        "name": "Google",
        "slug": "google",
        "frequency": 3
      },
      {
        "name": "IBM",
        "slug": "ibm",
        "frequency": 2
      },
      {
        "name": "tcs",
        "slug": "tcs",
        "frequency": 2
      },
      {
        "name": "Zoho",
        "slug": "zoho",
        "frequency": 2
      }
    ]
  },
  {
    "id": "452",
    "slug": "minimum-number-of-arrows-to-burst-balloons",
    "title": "Minimum Number of Arrows to Burst Balloons",
    "difficulty": "Medium",
    "description": "There are some spherical balloons taped onto a flat wall that represents the XY-plane. The balloons are represented as a 2D integer array `points` where `points[i] = [xstart, xend]` denotes a balloon whose **horizontal diameter** stretches between `xstart` and `xend`. You do not know the exact y-coordinates of the balloons. Arrows can be shot up **directly vertically** (in the positive y-direction) from different points along the x-axis. A balloon with `xstart` and `xend` is **burst** by an arrow shot at `x` if `xstart <= x <= xend`. There is **no limit** to the number of arrows that can be shot. A shot arrow keeps traveling up infinitely, bursting any balloons in its path. Given the array `points`, return _the **minimum** number of arrows that must be shot to burst all balloons_.",
    "examples": [
      {
        "input": "points = \\[\\[10,16\\],\\[2,8\\],\\[1,6\\],\\[7,12\\]\\]",
        "output": "2",
        "explanation": "The balloons can be burst by 2 arrows:"
      },
      {
        "input": "points = \\[\\[1,2\\],\\[3,4\\],\\[5,6\\],\\[7,8\\]\\]",
        "output": "4",
        "explanation": "One arrow needs to be shot for each balloon for a total of 4 arrows."
      },
      {
        "input": "points = \\[\\[1,2\\],\\[2,3\\],\\[3,4\\],\\[4,5\\]\\]",
        "output": "2",
        "explanation": "The balloons can be burst by 2 arrows:"
      }
    ],
    "constraints": [
      "`1 <= points.length <= 105`",
      "`points[i].length == 2`",
      "`-231 <= xstart < xend <= 231 - 1`"
    ],
    "companies": [
      {
        "name": "TikTok",
        "slug": "tiktok",
        "frequency": 3
      },
      {
        "name": "Amazon",
        "slug": "amazon",
        "frequency": 2
      },
      {
        "name": "Goldman Sachs",
        "slug": "goldman-sachs",
        "frequency": 2
      }
    ]
  },
  {
    "id": "472",
    "slug": "concatenated-words",
    "title": "Concatenated Words",
    "difficulty": "Hard",
    "description": "Given an array of strings `words` (**without duplicates**), return _all the **concatenated words** in the given list of_ `words`. A **concatenated word** is defined as a string that is comprised entirely of at least two shorter words (not necesssarily distinct) in the given array.",
    "examples": [
      {
        "input": "words = \\[ \"cat \", \"cats \", \"catsdogcats \", \"dog \", \"dogcatsdog \", \"hippopotamuses \", \"rat \", \"ratcatdogcat \"\\]",
        "output": "\\[ \"catsdogcats \", \"dogcatsdog \", \"ratcatdogcat \"\\]",
        "explanation": "\"catsdogcats \" can be concatenated by  \"cats \",  \"dog \" and  \"cats \";"
      },
      {
        "input": "words = \\[ \"cat \", \"dog \", \"catdog \"\\]",
        "output": "\\[ \"catdog \"\\]"
      }
    ],
    "constraints": [
      "`1 <= words.length <= 104`",
      "`1 <= words[i].length <= 30`",
      "`words[i]` consists of only lowercase English letters.",
      "All the strings of `words` are unique.",
      "`1 <= sum(words[i].length) <= 105`"
    ],
    "companies": [
      {
        "name": "Amazon",
        "slug": "amazon",
        "frequency": 24
      },
      {
        "name": "Salesforce",
        "slug": "salesforce",
        "frequency": 2
      },
      {
        "name": "eBay",
        "slug": "ebay",
        "frequency": 2
      },
      {
        "name": "TikTok",
        "slug": "tiktok",
        "frequency": 2
      }
    ]
  },
  {
    "id": "480",
    "slug": "sliding-window-median",
    "title": "Sliding Window Median",
    "difficulty": "Hard",
    "description": "The **median** is the middle value in an ordered integer list. If the size of the list is even, there is no middle value. So the median is the mean of the two middle values. *  For examples, if `arr = [2,3,4]`, the median is `3`. *  For examples, if `arr = [1,2,3,4]`, the median is `(2 + 3) / 2 = 2.5`. You are given an integer array `nums` and an integer `k`. There is a sliding window of size `k` which is moving from the very left of the array to the very right. You can only see the `k` numbers in the window. Each time the sliding window moves right by one position. Return _the median array for each window in the original array_. Answers within `10-5` of the actual value will be accepted.",
    "examples": [
      {
        "input": "nums = \\[1,3,-1,-3,5,3,6,7\\], k = 3",
        "output": "\\[1.00000,-1.00000,-1.00000,3.00000,5.00000,6.00000\\]",
        "explanation": ""
      },
      {
        "input": "nums = \\[1,2,3,4,2,3,1,4,2\\], k = 3",
        "output": "\\[2.00000,3.00000,3.00000,3.00000,2.00000,3.00000,2.00000\\]"
      }
    ],
    "constraints": [
      "`1 <= k <= nums.length <= 105`",
      "`-231 <= nums[i] <= 231 - 1`"
    ],
    "companies": [
      {
        "name": "Meta",
        "slug": "facebook",
        "frequency": 24
      },
      {
        "name": "Amazon",
        "slug": "amazon",
        "frequency": 2
      },
      {
        "name": "Datadog",
        "slug": "datadog",
        "frequency": 2
      }
    ]
  },
  {
    "id": "494",
    "slug": "target-sum",
    "title": "Target Sum",
    "difficulty": "Medium",
    "description": "You are given an integer array `nums` and an integer `target`. You want to build an **expression** out of nums by adding one of the symbols `'+'` and `'-'` before each integer in nums and then concatenate all the integers. *  For example, if `nums = [2, 1]`, you can add a `'+'` before `2` and a `'-'` before `1` and concatenate them to build the expression `\"+2-1 \"`. Return the number of different **expressions** that you can build, which evaluates to `target`.",
    "examples": [
      {
        "input": "nums = \\[1,1,1,1,1\\], target = 3",
        "output": "5",
        "explanation": "There are 5 ways to assign symbols to make the sum of nums be target 3."
      },
      {
        "input": "nums = \\[1\\], target = 1",
        "output": "1"
      }
    ],
    "constraints": [
      "`1 <= nums.length <= 20`",
      "`0 <= nums[i] <= 1000`",
      "`0 <= sum(nums[i]) <= 1000`",
      "`-1000 <= target <= 1000`"
    ],
    "companies": [
      {
        "name": "Google",
        "slug": "google",
        "frequency": 8
      },
      {
        "name": "Amazon",
        "slug": "amazon",
        "frequency": 8
      },
      {
        "name": "Meta",
        "slug": "facebook",
        "frequency": 4
      },
      {
        "name": "Microsoft",
        "slug": "microsoft",
        "frequency": 3
      },
      {
        "name": "Pinterest",
        "slug": "pinterest",
        "frequency": 3
      },
      {
        "name": "Bloomberg",
        "slug": "bloomberg",
        "frequency": 2
      },
      {
        "name": "Myntra",
        "slug": "myntra",
        "frequency": 2
      },
      {
        "name": "Salesforce",
        "slug": "salesforce",
        "frequency": 2
      }
    ]
  },
  {
    "id": "543",
    "slug": "diameter-of-binary-tree",
    "title": "Diameter of Binary Tree",
    "difficulty": "Easy",
    "description": "Given the `root` of a binary tree, return _the length of the **diameter** of the tree_. The **diameter** of a binary tree is the **length** of the longest path between any two nodes in a tree. This path may or may not pass through the `root`. The **length** of a path between two nodes is represented by the number of edges between them.",
    "examples": [
      {
        "input": "root = \\[1,2,3,4,5\\]",
        "output": "3",
        "explanation": "3 is the length of the path \\[4,2,1,3\\] or \\[5,2,1,3\\]."
      },
      {
        "input": "root = \\[1,2\\]",
        "output": "1"
      }
    ],
    "constraints": [
      "The number of nodes in the tree is in the range `[1, 104]`.",
      "`-100 <= Node.val <= 100`"
    ],
    "companies": [
      {
        "name": "Meta",
        "slug": "facebook",
        "frequency": 129
      },
      {
        "name": "Google",
        "slug": "google",
        "frequency": 9
      },
      {
        "name": "Amazon",
        "slug": "amazon",
        "frequency": 8
      },
      {
        "name": "Bloomberg",
        "slug": "bloomberg",
        "frequency": 2
      },
      {
        "name": "Microsoft",
        "slug": "microsoft",
        "frequency": 2
      },
      {
        "name": "Verkada",
        "slug": "verkada",
        "frequency": 2
      },
      {
        "name": "Visa",
        "slug": "visa",
        "frequency": 2
      },
      {
        "name": "TikTok",
        "slug": "tiktok",
        "frequency": 2
      }
    ]
  },
  {
    "id": "567",
    "slug": "permutation-in-string",
    "title": "Permutation in String",
    "difficulty": "Medium",
    "description": "Given two strings `s1` and `s2`, return `true` _if_ `s2` _contains a permutation of_ `s1`_, or_ `false` _otherwise_. In other words, return `true` if one of `s1`'s permutations is the substring of `s2`.",
    "examples": [
      {
        "input": "s1 =  \"ab \", s2 =  \"eidbaooo \"",
        "output": "true",
        "explanation": "s2 contains one permutation of s1 ( \"ba \")."
      },
      {
        "input": "s1 =  \"ab \", s2 =  \"eidboaoo \"",
        "output": "false"
      }
    ],
    "constraints": [
      "`1 <= s1.length, s2.length <= 104`",
      "`s1` and `s2` consist of lowercase English letters."
    ],
    "companies": [
      {
        "name": "Amazon",
        "slug": "amazon",
        "frequency": 9
      },
      {
        "name": "Google",
        "slug": "google",
        "frequency": 7
      },
      {
        "name": "Microsoft",
        "slug": "microsoft",
        "frequency": 3
      },
      {
        "name": "Yandex",
        "slug": "yandex",
        "frequency": 3
      },
      {
        "name": "Bloomberg",
        "slug": "bloomberg",
        "frequency": 3
      },
      {
        "name": "Oracle",
        "slug": "oracle",
        "frequency": 3
      },
      {
        "name": "TikTok",
        "slug": "tiktok",
        "frequency": 3
      },
      {
        "name": "Goldman Sachs",
        "slug": "goldman-sachs",
        "frequency": 3
      },
      {
        "name": "Meta",
        "slug": "facebook",
        "frequency": 2
      },
      {
        "name": "Cisco",
        "slug": "cisco",
        "frequency": 2
      }
    ]
  },
  {
    "id": "572",
    "slug": "subtree-of-another-tree",
    "title": "Subtree of Another Tree",
    "difficulty": "Easy",
    "description": "Given the roots of two binary trees `root` and `subRoot`, return `true` if there is a subtree of `root` with the same structure and node values of `subRoot` and `false` otherwise. A subtree of a binary tree `tree` is a tree that consists of a node in `tree` and all of this node's descendants. The tree `tree` could also be considered as a subtree of itself.",
    "examples": [
      {
        "input": "root = \\[3,4,5,1,2\\], subRoot = \\[4,1,2\\]",
        "output": "true"
      },
      {
        "input": "root = \\[3,4,5,1,2,null,null,null,null,0\\], subRoot = \\[4,1,2\\]",
        "output": "false"
      }
    ],
    "constraints": [
      "The number of nodes in the `root` tree is in the range `[1, 2000]`.",
      "The number of nodes in the `subRoot` tree is in the range `[1, 1000]`.",
      "`-104 <= root.val <= 104`",
      "`-104 <= subRoot.val <= 104`"
    ],
    "companies": [
      {
        "name": "Amazon",
        "slug": "amazon",
        "frequency": 4
      },
      {
        "name": "Google",
        "slug": "google",
        "frequency": 3
      },
      {
        "name": "Meta",
        "slug": "facebook",
        "frequency": 2
      },
      {
        "name": "Microsoft",
        "slug": "microsoft",
        "frequency": 2
      }
    ]
  },
  {
    "id": "617",
    "slug": "merge-two-binary-trees",
    "title": "Merge Two Binary Trees",
    "difficulty": "Easy",
    "description": "You are given two binary trees `root1` and `root2`. Imagine that when you put one of them to cover the other, some nodes of the two trees are overlapped while the others are not. You need to merge the two trees into a new binary tree. The merge rule is that if two nodes overlap, then sum node values up as the new value of the merged node. Otherwise, the NOT null node will be used as the node of the new tree. Return _the merged tree_.",
    "examples": [
      {
        "input": "root1 = \\[1,3,2,5\\], root2 = \\[2,1,3,null,4,null,7\\]",
        "output": "\\[3,4,5,5,4,null,7\\]"
      },
      {
        "input": "root1 = \\[1\\], root2 = \\[1,2\\]",
        "output": "\\[2,2\\]"
      }
    ],
    "constraints": [
      "The number of nodes in both trees is in the range `[0, 2000]`.",
      "`-104 <= Node.val <= 104`"
    ],
    "companies": [
      {
        "name": "Amazon",
        "slug": "amazon",
        "frequency": 2
      }
    ]
  },
  {
    "id": "621",
    "slug": "task-scheduler",
    "title": "Task Scheduler",
    "difficulty": "Medium",
    "description": "Given a characters array `tasks`, representing the tasks a CPU needs to do, where each letter represents a different task. Tasks could be done in any order. Each task is done in one unit of time. For each unit of time, the CPU could complete either one task or just be idle. However, there is a non-negative integer `n` that represents the cooldown period between two **same tasks** (the same letter in the array), that is that there must be at least `n` units of time between any two same tasks. Return _the least number of units of times that the CPU will take to finish all the given tasks_.",
    "examples": [
      {
        "input": "tasks = \\[ \"A \", \"A \", \"A \", \"B \", \"B \", \"B \"\\], n = 2",
        "output": "8",
        "explanation": ""
      },
      {
        "input": "tasks = \\[ \"A \", \"A \", \"A \", \"B \", \"B \", \"B \"\\], n = 0",
        "output": "6",
        "explanation": "On this case any permutation of size 6 would work since n = 0."
      },
      {
        "input": "tasks = \\[ \"A \", \"A \", \"A \", \"A \", \"A \", \"A \", \"B \", \"C \", \"D \", \"E \", \"F \", \"G \"\\], n = 2",
        "output": "16",
        "explanation": ""
      }
    ],
    "constraints": [
      "`1 <= task.length <= 104`",
      "`tasks[i]` is upper-case English letter.",
      "The integer `n` is in the range `[0, 100]`."
    ],
    "companies": [
      {
        "name": "Amazon",
        "slug": "amazon",
        "frequency": 16
      },
      {
        "name": "Roblox",
        "slug": "roblox",
        "frequency": 8
      },
      {
        "name": "Google",
        "slug": "google",
        "frequency": 7
      },
      {
        "name": "Snowflake",
        "slug": "snowflake",
        "frequency": 4
      },
      {
        "name": "Microsoft",
        "slug": "microsoft",
        "frequency": 4
      },
      {
        "name": "Apple",
        "slug": "apple",
        "frequency": 3
      },
      {
        "name": "Oracle",
        "slug": "oracle",
        "frequency": 3
      },
      {
        "name": "Meta",
        "slug": "facebook",
        "frequency": 3
      },
      {
        "name": "Rubrik",
        "slug": "rubrik",
        "frequency": 3
      },
      {
        "name": "Uber",
        "slug": "uber",
        "frequency": 2
      },
      {
        "name": "LinkedIn",
        "slug": "linkedin",
        "frequency": 2
      },
      {
        "name": "Nvidia",
        "slug": "nvidia",
        "frequency": 2
      }
    ]
  },
  {
    "id": "630",
    "slug": "course-schedule-iii",
    "title": "Course Schedule III",
    "difficulty": "Hard",
    "description": "There are `n` different online courses numbered from `1` to `n`. You are given an array `courses` where `courses[i] = [durationi, lastDayi]` indicate that the `ith` course should be taken **continuously** for `durationi` days and must be finished before or on `lastDayi`. You will start on the `1st` day and you cannot take two or more courses simultaneously. Return _the maximum number of courses that you can take_.",
    "examples": [
      {
        "input": "courses = \\[\\[100,200\\],\\[200,1300\\],\\[1000,1250\\],\\[2000,3200\\]\\]",
        "output": "3"
      },
      {
        "input": "courses = \\[\\[1,2\\]\\]",
        "output": "1"
      },
      {
        "input": "courses = \\[\\[3,2\\],\\[4,3\\]\\]",
        "output": "0"
      }
    ],
    "constraints": [
      "`1 <= courses.length <= 104`",
      "`1 <= durationi, lastDayi <= 104`"
    ],
    "companies": []
  },
  {
    "id": "632",
    "slug": "smallest-range-covering-elements-from-k-lists",
    "title": "Smallest Range Covering Elements from K Lists",
    "difficulty": "Hard",
    "description": "You have `k` lists of sorted integers in **non-decreasing order**. Find the **smallest** range that includes at least one number from each of the `k` lists. We define the range `[a, b]` is smaller than range `[c, d]` if `b - a < d - c` **or** `a < c` if `b - a == d - c`.",
    "examples": [
      {
        "input": "nums = \\[\\[4,10,15,24,26\\],\\[0,9,12,20\\],\\[5,18,22,30\\]\\]",
        "output": "\\[20,24\\]",
        "explanation": ""
      },
      {
        "input": "nums = \\[\\[1,2,3\\],\\[1,2,3\\],\\[1,2,3\\]\\]",
        "output": "\\[1,1\\]"
      }
    ],
    "constraints": [
      "`nums.length == k`",
      "`1 <= k <= 3500`",
      "`1 <= nums[i].length <= 50`",
      "`-105 <= nums[i][j] <= 105`",
      "`nums[i]` is sorted in non-decreasing order."
    ],
    "companies": [
      {
        "name": "Amazon",
        "slug": "amazon",
        "frequency": 8
      },
      {
        "name": "PhonePe",
        "slug": "phonepe",
        "frequency": 6
      },
      {
        "name": "Google",
        "slug": "google",
        "frequency": 4
      },
      {
        "name": "Microsoft",
        "slug": "microsoft",
        "frequency": 3
      },
      {
        "name": "Meta",
        "slug": "facebook",
        "frequency": 2
      }
    ]
  },
  {
    "id": "637",
    "slug": "average-of-levels-in-binary-tree",
    "title": "Average of Levels in Binary Tree",
    "difficulty": "Easy",
    "description": "Given the `root` of a binary tree, return _the average value of the nodes on each level in the form of an array_. Answers within `10-5` of the actual answer will be accepted.",
    "examples": [
      {
        "input": "root = \\[3,9,20,null,null,15,7\\]",
        "output": "\\[3.00000,14.50000,11.00000\\]"
      },
      {
        "input": "root = \\[3,9,20,15,7\\]",
        "output": "\\[3.00000,14.50000,11.00000\\]"
      }
    ],
    "constraints": [
      "The number of nodes in the tree is in the range `[1, 104]`.",
      "`-231 <= Node.val <= 231 - 1`"
    ],
    "companies": [
      {
        "name": "Google",
        "slug": "google",
        "frequency": 2
      }
    ]
  },
  {
    "id": "642",
    "slug": "design-search-autocomplete-system",
    "title": "Design Search Autocomplete System",
    "difficulty": "Hard",
    "description": "Design a search autocomplete system for a search engine. Users may input a sentence (at least one word and end with a special character `'#'`). You are given a string array `sentences` and an integer array `times` both of length `n` where `sentences[i]` is a previously typed sentence and `times[i]` is the corresponding number of times the sentence was typed. For each input character except `'#'`, return the top `3` historical hot sentences that have the same prefix as the part of the sentence already typed. Here are the specific rules: *  The hot degree for a sentence is defined as the number of times a user typed the exactly same sentence before. *  The returned top `3` hot sentences should be sorted by hot degree (The first is the hottest one). If several sentences have the same hot degree, use ASCII-code order (smaller one appears first). *  If less than `3` hot sentences exist, return as many as you can. *  When the input is a special character, it means the sentence ends, and in this case, you need to return an empty list. Implement the `AutocompleteSystem` class: *  `AutocompleteSystem(String[] sentences, int[] times)` Initializes the object with the `sentences` and `times` arrays. *  `List input(char c)` This indicates that the user typed the character `c`. *  Returns an empty array `[]` if `c == '#'` and stores the inputted sentence in the system. *  Returns the top `3` historical hot sentences that have the same prefix as the part of the sentence already typed. If there are fewer than `3` matches, return them all.",
    "examples": [],
    "constraints": [
      "`n == sentences.length`",
      "`n == times.length`",
      "`1 <= n <= 100`",
      "`1 <= sentences[i].length <= 100`",
      "`1 <= times[i] <= 50`",
      "`c` is a lowercase English letter, a hash `'#'`, or space `' '`.",
      "Each tested sentence will be a sequence of characters `c` that end with the character `'#'`.",
      "Each tested sentence will have a length in the range `[1, 200]`.",
      "The words in each input sentence are separated by single spaces.",
      "At most `5000` calls will be made to `input`."
    ],
    "companies": [
      {
        "name": "Amazon",
        "slug": "amazon",
        "frequency": 4
      },
      {
        "name": "Pinterest",
        "slug": "pinterest",
        "frequency": 3
      },
      {
        "name": "Google",
        "slug": "google",
        "frequency": 2
      },
      {
        "name": "Microsoft",
        "slug": "microsoft",
        "frequency": 2
      },
      {
        "name": "Bloomberg",
        "slug": "bloomberg",
        "frequency": 2
      },
      {
        "name": "Uber",
        "slug": "uber",
        "frequency": 2
      },
      {
        "name": "Apple",
        "slug": "apple",
        "frequency": 2
      },
      {
        "name": "TikTok",
        "slug": "tiktok",
        "frequency": 2
      }
    ]
  },
  {
    "id": "643",
    "slug": "maximum-average-subarray-i",
    "title": "Maximum Average Subarray I",
    "difficulty": "Easy",
    "description": "You are given an integer array `nums` consisting of `n` elements, and an integer `k`. Find a contiguous subarray whose **length is equal to** `k` that has the maximum average value and return _this value_. Any answer with a calculation error less than `10-5` will be accepted.",
    "examples": [
      {
        "input": "nums = \\[1,12,-5,-6,50,3\\], k = 4",
        "output": "12.75000",
        "explanation": "Maximum average is (12 - 5 - 6 + 50) / 4 = 51 / 4 = 12.75"
      },
      {
        "input": "nums = \\[5\\], k = 1",
        "output": "5.00000"
      }
    ],
    "constraints": [
      "`n == nums.length`",
      "`1 <= k <= n <= 105`",
      "`-104 <= nums[i] <= 104`"
    ],
    "companies": [
      {
        "name": "Meta",
        "slug": "facebook",
        "frequency": 13
      },
      {
        "name": "Google",
        "slug": "google",
        "frequency": 7
      },
      {
        "name": "Amazon",
        "slug": "amazon",
        "frequency": 4
      }
    ]
  },
  {
    "id": "647",
    "slug": "palindromic-substrings",
    "title": "Palindromic Substrings",
    "difficulty": "Medium",
    "description": "Given a string `s`, return _the number of **palindromic substrings** in it_. A string is a **palindrome** when it reads the same backward as forward. A **substring** is a contiguous sequence of characters within the string.",
    "examples": [
      {
        "input": "s =  \"abc \"",
        "output": "3",
        "explanation": "Three palindromic strings:  \"a \",  \"b \",  \"c \"."
      },
      {
        "input": "s =  \"aaa \"",
        "output": "6",
        "explanation": "Six palindromic strings:  \"a \",  \"a \",  \"a \",  \"aa \",  \"aa \",  \"aaa \"."
      }
    ],
    "constraints": [
      "`1 <= s.length <= 1000`",
      "`s` consists of lowercase English letters."
    ],
    "companies": [
      {
        "name": "Meta",
        "slug": "facebook",
        "frequency": 30
      },
      {
        "name": "Pure Storage",
        "slug": "pure-storage",
        "frequency": 8
      },
      {
        "name": "Citadel",
        "slug": "citadel",
        "frequency": 8
      },
      {
        "name": "Google",
        "slug": "google",
        "frequency": 6
      },
      {
        "name": "Goldman Sachs",
        "slug": "goldman-sachs",
        "frequency": 5
      },
      {
        "name": "Amazon",
        "slug": "amazon",
        "frequency": 3
      },
      {
        "name": "Oracle",
        "slug": "oracle",
        "frequency": 3
      },
      {
        "name": "Salesforce",
        "slug": "salesforce",
        "frequency": 2
      },
      {
        "name": "PayPal",
        "slug": "paypal",
        "frequency": 2
      },
      {
        "name": "Epic Systems",
        "slug": "epic-systems",
        "frequency": 2
      },
      {
        "name": "Netskope",
        "slug": "netskope",
        "frequency": 2
      },
      {
        "name": "Microsoft",
        "slug": "microsoft",
        "frequency": 2
      },
      {
        "name": "Apple",
        "slug": "apple",
        "frequency": 2
      },
      {
        "name": "Cisco",
        "slug": "cisco",
        "frequency": 2
      },
      {
        "name": "Arista Networks",
        "slug": "arista-networks",
        "frequency": 2
      }
    ]
  },
  {
    "id": "654",
    "slug": "maximum-binary-tree",
    "title": "Maximum Binary Tree",
    "difficulty": "Medium",
    "description": "You are given an integer array `nums` with no duplicates. A **maximum binary tree** can be built recursively from `nums` using the following algorithm: 1. Create a root node whose value is the maximum value in `nums`. 2. Recursively build the left subtree on the **subarray prefix** to the **left** of the maximum value. 3. Recursively build the right subtree on the **subarray suffix** to the **right** of the maximum value. Return _the **maximum binary tree** built from_ `nums`.",
    "examples": [
      {
        "input": "nums = \\[3,2,1,6,0,5\\]",
        "output": "\\[6,3,5,null,2,0,null,null,1\\]",
        "explanation": "The recursive calls are as follow:"
      },
      {
        "input": "nums = \\[3,2,1\\]",
        "output": "\\[3,null,2,null,1\\]"
      }
    ],
    "constraints": [
      "`1 <= nums.length <= 1000`",
      "`0 <= nums[i] <= 1000`",
      "All integers in `nums` are unique."
    ],
    "companies": []
  },
  {
    "id": "658",
    "slug": "find-k-closest-elements",
    "title": "Find K Closest Elements",
    "difficulty": "Medium",
    "description": "Given a **sorted** integer array `arr`, two integers `k` and `x`, return the `k` closest integers to `x` in the array. The result should also be sorted in ascending order. An integer `a` is closer to `x` than an integer `b` if: *  `|a - x| < |b - x|`, or *  `|a - x| == |b - x|` and `a < b`",
    "examples": [
      {
        "input": "arr = \\[1,2,3,4,5\\], k = 4, x = 3",
        "output": "\\[1,2,3,4\\]"
      },
      {
        "input": "arr = \\[1,2,3,4,5\\], k = 4, x = -1",
        "output": "\\[1,2,3,4\\]"
      }
    ],
    "constraints": [
      "`1 <= k <= arr.length`",
      "`1 <= arr.length <= 104`",
      "`arr` is sorted in ascending order.",
      "`-104 <= arr[i], x <= 104`"
    ],
    "companies": [
      {
        "name": "Meta",
        "slug": "facebook",
        "frequency": 11
      },
      {
        "name": "Yandex",
        "slug": "yandex",
        "frequency": 11
      },
      {
        "name": "Amazon",
        "slug": "amazon",
        "frequency": 10
      },
      {
        "name": "Google",
        "slug": "google",
        "frequency": 7
      },
      {
        "name": "LinkedIn",
        "slug": "linkedin",
        "frequency": 4
      },
      {
        "name": "Apple",
        "slug": "apple",
        "frequency": 4
      },
      {
        "name": "Coupang",
        "slug": "coupang",
        "frequency": 4
      },
      {
        "name": "DoorDash",
        "slug": "doordash",
        "frequency": 4
      },
      {
        "name": "Bloomberg",
        "slug": "bloomberg",
        "frequency": 3
      },
      {
        "name": "Microsoft",
        "slug": "microsoft",
        "frequency": 2
      },
      {
        "name": "TikTok",
        "slug": "tiktok",
        "frequency": 2
      }
    ]
  },
  {
    "id": "662",
    "slug": "maximum-width-of-binary-tree",
    "title": "Maximum Width of Binary Tree",
    "difficulty": "Medium",
    "description": "Given the `root` of a binary tree, return _the **maximum width** of the given tree_. The **maximum width** of a tree is the maximum **width** among all levels. The **width** of one level is defined as the length between the end-nodes (the leftmost and rightmost non-null nodes), where the null nodes between the end-nodes that would be present in a complete binary tree extending down to that level are also counted into the length calculation. It is **guaranteed** that the answer will in the range of a **32-bit** signed integer.",
    "examples": [
      {
        "input": "root = \\[1,3,2,5,3,null,9\\]",
        "output": "4",
        "explanation": "The maximum width exists in the third level with length 4 (5,3,null,9)."
      },
      {
        "input": "root = \\[1,3,2,5,null,null,9,6,null,7\\]",
        "output": "7",
        "explanation": "The maximum width exists in the fourth level with length 7 (6,null,null,null,null,null,7)."
      },
      {
        "input": "root = \\[1,3,2,5\\]",
        "output": "2",
        "explanation": "The maximum width exists in the second level with length 2 (3,2)."
      }
    ],
    "constraints": [
      "The number of nodes in the tree is in the range `[1, 3000]`.",
      "`-100 <= Node.val <= 100`"
    ],
    "companies": [
      {
        "name": "Google",
        "slug": "google",
        "frequency": 4
      },
      {
        "name": "Amazon",
        "slug": "amazon",
        "frequency": 4
      },
      {
        "name": "TikTok",
        "slug": "tiktok",
        "frequency": 2
      }
    ]
  },
  {
    "id": "673",
    "slug": "number-of-longest-increasing-subsequence",
    "title": "Number of Longest Increasing Subsequence",
    "difficulty": "Medium",
    "description": "Given an integer array `nums`, return _the number of longest increasing subsequences._ **Notice** that the sequence has to be **strictly** increasing.",
    "examples": [
      {
        "input": "nums = \\[1,3,5,4,7\\]",
        "output": "2",
        "explanation": "The two longest increasing subsequences are \\[1, 3, 4, 7\\] and \\[1, 3, 5, 7\\]."
      },
      {
        "input": "nums = \\[2,2,2,2,2\\]",
        "output": "5",
        "explanation": "The length of the longest increasing subsequence is 1, and there are 5 increasing subsequences of length 1, so output 5."
      }
    ],
    "constraints": ["`1 <= nums.length <= 2000`", "`-106 <= nums[i] <= 106`"],
    "companies": [
      {
        "name": "Meta",
        "slug": "facebook",
        "frequency": 2
      },
      {
        "name": "TikTok",
        "slug": "tiktok",
        "frequency": 2
      },
      {
        "name": "Intuit",
        "slug": "intuit",
        "frequency": 2
      }
    ]
  },
  {
    "id": "698",
    "slug": "partition-to-k-equal-sum-subsets",
    "title": "Partition to K Equal Sum Subsets",
    "difficulty": "Medium",
    "description": "Given an integer array `nums` and an integer `k`, return `true` if it is possible to divide this array into `k` non-empty subsets whose sums are all equal.",
    "examples": [
      {
        "input": "nums = \\[4,3,2,3,5,2,1\\], k = 4",
        "output": "true",
        "explanation": "It is possible to divide it into 4 subsets (5), (1, 4), (2,3), (2,3) with equal sums."
      },
      {
        "input": "nums = \\[1,2,3,4\\], k = 3",
        "output": "false"
      }
    ],
    "constraints": [
      "`1 <= k <= nums.length <= 16`",
      "`1 <= nums[i] <= 104`",
      "The frequency of each element is in the range `[1, 4]`."
    ],
    "companies": [
      {
        "name": "LinkedIn",
        "slug": "linkedin",
        "frequency": 7
      },
      {
        "name": "Meta",
        "slug": "facebook",
        "frequency": 2
      }
    ]
  },
  {
    "id": "704",
    "slug": "binary-search",
    "title": "Binary Search",
    "difficulty": "Easy",
    "description": "Given an array of integers `nums` which is sorted in ascending order, and an integer `target`, write a function to search `target` in `nums`. If `target` exists, then return its index. Otherwise, return `-1`. You must write an algorithm with `O(log n)` runtime complexity.",
    "examples": [
      {
        "input": "nums = \\[-1,0,3,5,9,12\\], target = 9",
        "output": "4",
        "explanation": "9 exists in nums and its index is 4"
      },
      {
        "input": "nums = \\[-1,0,3,5,9,12\\], target = 2",
        "output": "-1",
        "explanation": "2 does not exist in nums so return -1"
      }
    ],
    "constraints": [
      "`1 <= nums.length <= 104`",
      "`-104 < nums[i], target < 104`",
      "All the integers in `nums` are unique.",
      "`nums` is sorted in ascending order."
    ],
    "companies": [
      {
        "name": "Google",
        "slug": "google",
        "frequency": 7
      },
      {
        "name": "Meta",
        "slug": "facebook",
        "frequency": 5
      },
      {
        "name": "Bloomberg",
        "slug": "bloomberg",
        "frequency": 3
      },
      {
        "name": "Amazon",
        "slug": "amazon",
        "frequency": 2
      },
      {
        "name": "Microsoft",
        "slug": "microsoft",
        "frequency": 2
      },
      {
        "name": "Oracle",
        "slug": "oracle",
        "frequency": 2
      }
    ]
  },
  {
    "id": "713",
    "slug": "subarray-product-less-than-k",
    "title": "Subarray Product Less Than K",
    "difficulty": "Medium",
    "description": "Given an array of integers `nums` and an integer `k`, return _the number of contiguous subarrays where the product of all the elements in the subarray is strictly less than_ `k`.",
    "examples": [
      {
        "input": "nums = \\[10,5,2,6\\], k = 100",
        "output": "8",
        "explanation": "The 8 subarrays that have product less than 100 are:"
      },
      {
        "input": "nums = \\[1,2,3\\], k = 0",
        "output": "0"
      }
    ],
    "constraints": [
      "`1 <= nums.length <= 3  104`",
      "`1 <= nums[i] <= 1000`",
      "`0 <= k <= 106`"
    ],
    "companies": [
      {
        "name": "Salesforce",
        "slug": "salesforce",
        "frequency": 11
      },
      {
        "name": "Amazon",
        "slug": "amazon",
        "frequency": 4
      },
      {
        "name": "Squarepoint Capital",
        "slug": "squarepoint-capital",
        "frequency": 4
      },
      {
        "name": "Airbnb",
        "slug": "airbnb",
        "frequency": 3
      },
      {
        "name": "Meta",
        "slug": "facebook",
        "frequency": 3
      },
      {
        "name": "Google",
        "slug": "google",
        "frequency": 2
      },
      {
        "name": "Apple",
        "slug": "apple",
        "frequency": 2
      },
      {
        "name": "Samsung",
        "slug": "samsung",
        "frequency": 2
      },
      {
        "name": "Flexport",
        "slug": "flexport",
        "frequency": 2
      },
      {
        "name": "Agoda",
        "slug": "agoda",
        "frequency": 2
      }
    ]
  },
  {
    "id": "720",
    "slug": "longest-word-in-dictionary",
    "title": "Longest Word in Dictionary",
    "difficulty": "Medium",
    "description": "Given an array of strings `words` representing an English Dictionary, return _the longest word in_ `words` _that can be built one character at a time by other words in_ `words`. If there is more than one possible answer, return the longest word with the smallest lexicographical order. If there is no answer, return the empty string. Note that the word should be built from left to right with each additional character being added to the end of a previous word.",
    "examples": [
      {
        "input": "words = \\[ \"w \", \"wo \", \"wor \", \"worl \", \"world \"\\]",
        "output": "\"world \"",
        "explanation": "The word  \"world \" can be built one character at a time by  \"w \",  \"wo \",  \"wor \", and  \"worl \"."
      },
      {
        "input": "words = \\[ \"a \", \"banana \", \"app \", \"appl \", \"ap \", \"apply \", \"apple \"\\]",
        "output": "\"apple \"",
        "explanation": "Both  \"apply \" and  \"apple \" can be built from other words in the dictionary. However,  \"apple \" is lexicographically smaller than  \"apply \"."
      }
    ],
    "constraints": [
      "`1 <= words.length <= 1000`",
      "`1 <= words[i].length <= 30`",
      "`words[i]` consists of lowercase English letters."
    ],
    "companies": [
      {
        "name": "Google",
        "slug": "google",
        "frequency": 2
      }
    ]
  },
  {
    "id": "744",
    "slug": "find-smallest-letter-greater-than-target",
    "title": "Find Smallest Letter Greater Than Target",
    "difficulty": "Easy",
    "description": "You are given an array of characters `letters` that is sorted in **non-decreasing order**, and a character `target`. There are **at least two different** characters in `letters`. Return _the smallest character in_ `letters` _that is lexicographically greater than_ `target`. If such a character does not exist, return the first character in `letters`.",
    "examples": [
      {
        "input": "letters = \\[ \"c \", \"f \", \"j \"\\], target =  \"a \"",
        "output": "\"c \"",
        "explanation": "The smallest character that is lexicographically greater than 'a' in letters is 'c'."
      },
      {
        "input": "letters = \\[ \"c \", \"f \", \"j \"\\], target =  \"c \"",
        "output": "\"f \"",
        "explanation": "The smallest character that is lexicographically greater than 'c' in letters is 'f'."
      },
      {
        "input": "letters = \\[ \"x \", \"x \", \"y \", \"y \"\\], target =  \"z \"",
        "output": "\"x \"",
        "explanation": "There are no characters in letters that is lexicographically greater than 'z' so we return letters\\[0\\]."
      }
    ],
    "constraints": [
      "`2 <= letters.length <= 104`",
      "`letters[i]` is a lowercase English letter.",
      "`letters` is sorted in non-decreasing order.",
      "`letters` contains at least two different characters.",
      "`target` is a lowercase English letter."
    ],
    "companies": [
      {
        "name": "LinkedIn",
        "slug": "linkedin",
        "frequency": 3
      },
      {
        "name": "Google",
        "slug": "google",
        "frequency": 3
      },
      {
        "name": "Bloomberg",
        "slug": "bloomberg",
        "frequency": 2
      }
    ]
  },
  {
    "id": "745",
    "slug": "prefix-and-suffix-search",
    "title": "Prefix and Suffix Search",
    "difficulty": "Hard",
    "description": "Design a special dictionary that searches the words in it by a prefix and a suffix. Implement the `WordFilter` class: *  `WordFilter(string[] words)` Initializes the object with the `words` in the dictionary. *  `f(string pref, string suff)` Returns _the index of the word in the dictionary,_ which has the prefix `pref` and the suffix `suff`. If there is more than one valid index, return **the largest** of them. If there is no such word in the dictionary, return `-1`.",
    "examples": [],
    "constraints": [
      "`1 <= words.length <= 104`",
      "`1 <= words[i].length <= 7`",
      "`1 <= pref.length, suff.length <= 7`",
      "`words[i]`, `pref` and `suff` consist of lowercase English letters only.",
      "At most `104` calls will be made to the function `f`."
    ],
    "companies": []
  },
  {
    "id": "759",
    "slug": "employee-free-time",
    "title": "Employee Free Time",
    "difficulty": "Hard",
    "description": "We are given a list `schedule` of employees, which represents the working time for each employee. Each employee has a list of non-overlapping `Intervals`, and these intervals are in sorted order. Return the list of finite intervals representing **common, positive-length free time** for _all_ employees, also in sorted order. (Even though we are representing `Intervals` in the form `[x, y]`, the objects inside are `Intervals`, not lists or arrays. For example, `schedule[0][0].start = 1`, `schedule[0][0].end = 2`, and `schedule[0][0][0]` is not defined). Also, we wouldn't include intervals like \\[5, 5\\] in our answer, as they have zero length.",
    "examples": [
      {
        "input": "schedule = \\[\\[\\[1,2\\],\\[5,6\\]\\],\\[\\[1,3\\]\\],\\[\\[4,10\\]\\]\\]",
        "output": "\\[\\[3,4\\]\\]",
        "explanation": "There are a total of three employees, and all common"
      },
      {
        "input": "schedule = \\[\\[\\[1,3\\],\\[6,7\\]\\],\\[\\[2,4\\]\\],\\[\\[2,5\\],\\[9,12\\]\\]\\]",
        "output": "\\[\\[5,6\\],\\[7,9\\]\\]"
      }
    ],
    "constraints": [
      "`1 <= schedule.length , schedule[i].length <= 50`",
      "`0 <= schedule[i].start < schedule[i].end <= 10^8`"
    ],
    "companies": [
      {
        "name": "Citadel",
        "slug": "citadel",
        "frequency": 4
      },
      {
        "name": "Google",
        "slug": "google",
        "frequency": 2
      },
      {
        "name": "Apple",
        "slug": "apple",
        "frequency": 2
      }
    ]
  },
  {
    "id": "767",
    "slug": "reorganize-string",
    "title": "Reorganize String",
    "difficulty": "Medium",
    "description": "Given a string `s`, rearrange the characters of `s` so that any two adjacent characters are not the same. Return _any possible rearrangement of_ `s` _or return_ `\" \"` _if not possible_.",
    "examples": [
      {
        "input": "s = \"aab\"",
        "output": "\"aba\""
      },
      {
        "input": "s = \"aaab\"",
        "output": "\"\""
      }
    ],
    "constraints": [
      "`1 <= s.length <= 500`",
      "`s` consists of lowercase English letters."
    ],
    "companies": [
      {
        "name": "Amazon",
        "slug": "amazon",
        "frequency": 97
      },
      {
        "name": "Roblox",
        "slug": "roblox",
        "frequency": 17
      },
      {
        "name": "Google",
        "slug": "google",
        "frequency": 7
      },
      {
        "name": "TikTok",
        "slug": "tiktok",
        "frequency": 6
      },
      {
        "name": "Microsoft",
        "slug": "microsoft",
        "frequency": 4
      },
      {
        "name": "Pinterest",
        "slug": "pinterest",
        "frequency": 3
      },
      {
        "name": "Meta",
        "slug": "facebook",
        "frequency": 2
      },
      {
        "name": "Oracle",
        "slug": "oracle",
        "frequency": 2
      },
      {
        "name": "eBay",
        "slug": "ebay",
        "frequency": 2
      }
    ]
  },
  {
    "id": "784",
    "slug": "letter-case-permutation",
    "title": "Letter Case Permutation",
    "difficulty": "Medium",
    "description": "Given a string `s`, you can transform every letter individually to be lowercase or uppercase to create another string. Return _a list of all possible strings we could create_. Return the output in **any order**.",
    "examples": [
      {
        "input": "s =  \"a1b2 \"",
        "output": "\\[ \"a1b2 \", \"a1B2 \", \"A1b2 \", \"A1B2 \"\\]"
      },
      {
        "input": "s =  \"3z4 \"",
        "output": "\\[ \"3z4 \", \"3Z4 \"\\]"
      }
    ],
    "constraints": [
      "`1 <= s.length <= 12`",
      "`s` consists of lowercase English letters, uppercase English letters, and digits."
    ],
    "companies": [
      {
        "name": "Meta",
        "slug": "facebook",
        "frequency": 4
      },
      {
        "name": "TikTok",
        "slug": "tiktok",
        "frequency": 2
      }
    ]
  },
  {
    "id": "828",
    "slug": "count-unique-characters-of-all-substrings-of-a-given-string",
    "title": "Count Unique Characters of All Substrings of a Given String",
    "difficulty": "Hard",
    "description": "Let's define a function `countUniqueChars(s)` that returns the number of unique characters on `s`. *  For example, calling `countUniqueChars(s)` if `s = \"LEETCODE \"` then `\"L \"`, `\"T \"`, `\"C \"`, `\"O \"`, `\"D \"` are the unique characters since they appear only once in `s`, therefore `countUniqueChars(s) = 5`. Given a string `s`, return the sum of `countUniqueChars(t)` where `t` is a substring of `s`. The test cases are generated such that the answer fits in a 32-bit integer. Notice that some substrings can be repeated so in this case you have to count the repeated ones too.",
    "examples": [
      {
        "input": "s =  \"ABC \"",
        "output": "10",
        "explanation": "All possible substrings are:  \"A \", \"B \", \"C \", \"AB \", \"BC \" and  \"ABC \"."
      },
      {
        "input": "s =  \"ABA \"",
        "output": "8",
        "explanation": "The same as example 1, except `countUniqueChars`( \"ABA \") = 1."
      },
      {
        "input": "s =  \"LEETCODE \"",
        "output": "92"
      }
    ],
    "constraints": [
      "`1 <= s.length <= 105`",
      "`s` consists of uppercase English letters only."
    ],
    "companies": []
  },
  {
    "id": "844",
    "slug": "backspace-string-compare",
    "title": "Backspace String Compare",
    "difficulty": "Easy",
    "description": "Given two strings `s` and `t`, return `true` _if they are equal when both are typed into empty text editors_. `'#'` means a backspace character. Note that after backspacing an empty text, the text will continue empty.",
    "examples": [
      {
        "input": "s =  \"ab#c \", t =  \"ad#c \"",
        "output": "true",
        "explanation": "Both s and t become  \"ac \"."
      },
      {
        "input": "s =  \"ab## \", t =  \"c#d# \"",
        "output": "true",
        "explanation": "Both s and t become  \" \"."
      },
      {
        "input": "s =  \"a#c \", t =  \"b \"",
        "output": "false",
        "explanation": "s becomes  \"c \" while t becomes  \"b \"."
      }
    ],
    "constraints": [
      "`1 <= s.length, t.length <= 200`",
      "`s` and `t` only contain lowercase letters and `'#'` characters.",
      "Follow up: Can you solve it in `O(n)` time and `O(1)` space?"
    ],
    "companies": [
      {
        "name": "Amazon",
        "slug": "amazon",
        "frequency": 5
      },
      {
        "name": "Goldman Sachs",
        "slug": "goldman-sachs",
        "frequency": 5
      },
      {
        "name": "Meta",
        "slug": "facebook",
        "frequency": 3
      },
      {
        "name": "Microstrategy",
        "slug": "microstrategy",
        "frequency": 2
      },
      {
        "name": "Agoda",
        "slug": "agoda",
        "frequency": 2
      },
      {
        "name": "Google",
        "slug": "google",
        "frequency": 2
      },
      {
        "name": "IBM",
        "slug": "ibm",
        "frequency": 2
      },
      {
        "name": "Wayfair",
        "slug": "wayfair",
        "frequency": 2
      }
    ]
  },
  {
    "id": "852",
    "slug": "peak-index-in-a-mountain-array",
    "title": "Peak Index in a Mountain Array",
    "difficulty": "Medium",
    "description": "An array `arr` a **mountain** if the following properties hold: *  `arr.length >= 3` *  There exists some `i` with `0 < i < arr.length - 1` such that: *  `arr[0] < arr[1] < ... < arr[i - 1] < arr[i]` *  `arr[i] > arr[i + 1] > ... > arr[arr.length - 1]` Given a mountain array `arr`, return the index `i` such that `arr[0] < arr[1] < ... < arr[i - 1] < arr[i] > arr[i + 1] > ... > arr[arr.length - 1]`. You must solve it in `O(log(arr.length))` time complexity.",
    "examples": [
      {
        "input": "arr = \\[0,1,0\\]",
        "output": "1"
      },
      {
        "input": "arr = \\[0,2,1,0\\]",
        "output": "1"
      },
      {
        "input": "arr = \\[0,10,5,2\\]",
        "output": "1"
      }
    ],
    "constraints": [
      "`3 <= arr.length <= 105`",
      "`0 <= arr[i] <= 106`",
      "`arr` is guaranteed to be a mountain array."
    ],
    "companies": [
      {
        "name": "Google",
        "slug": "google",
        "frequency": 9
      },
      {
        "name": "Meta",
        "slug": "facebook",
        "frequency": 6
      },
      {
        "name": "Bloomberg",
        "slug": "bloomberg",
        "frequency": 3
      },
      {
        "name": "Microsoft",
        "slug": "microsoft",
        "frequency": 2
      },
      {
        "name": "Amazon",
        "slug": "amazon",
        "frequency": 2
      }
    ]
  },
  {
    "id": "863",
    "slug": "all-nodes-distance-k-in-binary-tree",
    "title": "All Nodes Distance K in Binary Tree",
    "difficulty": "Medium",
    "description": "Given the `root` of a binary tree, the value of a target node `target`, and an integer `k`, return _an array of the values of all nodes that have a distance_ `k` _from the target node._ You can return the answer in **any order**.",
    "examples": [
      {
        "input": "root = \\[3,5,1,6,2,0,8,null,null,7,4\\], target = 5, k = 2",
        "output": "\\[7,4,1\\]"
      },
      {
        "input": "root = \\[1\\], target = 1, k = 3",
        "output": "\\[\\]"
      }
    ],
    "constraints": [
      "The number of nodes in the tree is in the range `[1, 500]`.",
      "`0 <= Node.val <= 500`",
      "All the values `Node.val` are unique.",
      "`target` is the value of one of the nodes in the tree.",
      "`0 <= k <= 1000`"
    ],
    "companies": [
      {
        "name": "Meta",
        "slug": "facebook",
        "frequency": 42
      },
      {
        "name": "Amazon",
        "slug": "amazon",
        "frequency": 17
      },
      {
        "name": "Google",
        "slug": "google",
        "frequency": 5
      },
      {
        "name": "Microsoft",
        "slug": "microsoft",
        "frequency": 4
      },
      {
        "name": "Salesforce",
        "slug": "salesforce",
        "frequency": 3
      },
      {
        "name": "TikTok",
        "slug": "tiktok",
        "frequency": 3
      }
    ]
  },
  {
    "id": "876",
    "slug": "middle-of-the-linked-list",
    "title": "Middle of the Linked List",
    "difficulty": "Easy",
    "description": "Given the `head` of a singly linked list, return _the middle node of the linked list_. If there are two middle nodes, return **the second middle** node.",
    "examples": [
      {
        "input": "head = \\[1,2,3,4,5\\]",
        "output": "\\[3,4,5\\]",
        "explanation": "The middle node of the list is node 3."
      },
      {
        "input": "head = \\[1,2,3,4,5,6\\]",
        "output": "\\[4,5,6\\]",
        "explanation": "Since the list has two middle nodes with values 3 and 4, we return the second one."
      }
    ],
    "constraints": [
      "The number of nodes in the list is in the range `[1, 100]`.",
      "`1 <= Node.val <= 100`"
    ],
    "companies": [
      {
        "name": "Amazon",
        "slug": "amazon",
        "frequency": 7
      },
      {
        "name": "Google",
        "slug": "google",
        "frequency": 6
      },
      {
        "name": "Bloomberg",
        "slug": "bloomberg",
        "frequency": 3
      },
      {
        "name": "Microsoft",
        "slug": "microsoft",
        "frequency": 2
      },
      {
        "name": "Meta",
        "slug": "facebook",
        "frequency": 2
      },
      {
        "name": "tcs",
        "slug": "tcs",
        "frequency": 2
      },
      {
        "name": "Intuit",
        "slug": "intuit",
        "frequency": 2
      }
    ]
  },
  {
    "id": "895",
    "slug": "maximum-frequency-stack",
    "title": "Maximum Frequency Stack",
    "difficulty": "Hard",
    "description": "Design a stack-like data structure to push elements to the stack and pop the most frequent element from the stack. Implement the `FreqStack` class: *  `FreqStack()` constructs an empty frequency stack. *  `void push(int val)` pushes an integer `val` onto the top of the stack. *  `int pop()` removes and returns the most frequent element in the stack. *  If there is a tie for the most frequent element, the element closest to the stack's top is removed and returned.",
    "examples": [],
    "constraints": [
      "`0 <= val <= 109`",
      "At most `2  104` calls will be made to `push` and `pop`.",
      "It is guaranteed that there will be at least one element in the stack before calling `pop`."
    ],
    "companies": [
      {
        "name": "Amazon",
        "slug": "amazon",
        "frequency": 3
      },
      {
        "name": "Uber",
        "slug": "uber",
        "frequency": 2
      },
      {
        "name": "Apple",
        "slug": "apple",
        "frequency": 2
      },
      {
        "name": "Microsoft",
        "slug": "microsoft",
        "frequency": 2
      },
      {
        "name": "Nutanix",
        "slug": "nutanix",
        "frequency": 2
      }
    ]
  },
  {
    "id": "904",
    "slug": "fruit-into-baskets",
    "title": "Fruit Into Baskets",
    "difficulty": "Medium",
    "description": "You are visiting a farm that has a single row of fruit trees arranged from left to right. The trees are represented by an integer array `fruits` where `fruits[i]` is the **type** of fruit the `ith` tree produces. You want to collect as much fruit as possible. However, the owner has some strict rules that you must follow: *  You only have **two** baskets, and each basket can only hold a **single type** of fruit. There is no limit on the amount of fruit each basket can hold. *  Starting from any tree of your choice, you must pick **exactly one fruit** from **every** tree (including the start tree) while moving to the right. The picked fruits must fit in one of your baskets. *  Once you reach a tree with fruit that cannot fit in your baskets, you must stop. Given the integer array `fruits`, return _the **maximum** number of fruits you can pick_.",
    "examples": [
      {
        "input": "fruits = \\[1,2,1\\]",
        "output": "3",
        "explanation": "We can pick from all 3 trees."
      },
      {
        "input": "fruits = \\[0,1,2,2\\]",
        "output": "3",
        "explanation": "We can pick from trees \\[1,2,2\\]."
      },
      {
        "input": "fruits = \\[1,2,3,2,2\\]",
        "output": "4",
        "explanation": "We can pick from trees \\[2,3,2,2\\]."
      }
    ],
    "constraints": [
      "`1 <= fruits.length <= 105`",
      "`0 <= fruits[i] < fruits.length`"
    ],
    "companies": [
      {
        "name": "Amazon",
        "slug": "amazon",
        "frequency": 6
      },
      {
        "name": "Google",
        "slug": "google",
        "frequency": 4
      },
      {
        "name": "Microsoft",
        "slug": "microsoft",
        "frequency": 2
      }
    ]
  },
  {
    "id": "973",
    "slug": "k-closest-points-to-origin",
    "title": "K Closest Points to Origin",
    "difficulty": "Medium",
    "description": "Given an array of `points` where `points[i] = [xi, yi]` represents a point on the **X-Y** plane and an integer `k`, return the `k` closest points to the origin `(0, 0)`. The distance between two points on the **X-Y** plane is the Euclidean distance (i.e., `\u221a(x1 - x2)2 + (y1 - y2)2`). You may return the answer in **any order**. The answer is **guaranteed** to be **unique** (except for the order that it is in).",
    "examples": [
      {
        "input": "points = \\[\\[1,3\\],\\[-2,2\\]\\], k = 1",
        "output": "\\[\\[-2,2\\]\\]",
        "explanation": ""
      },
      {
        "input": "points = \\[\\[3,3\\],\\[5,-1\\],\\[-2,4\\]\\], k = 2",
        "output": "\\[\\[3,3\\],\\[-2,4\\]\\]",
        "explanation": "The answer \\[\\[-2,4\\],\\[3,3\\]\\] would also be accepted."
      }
    ],
    "constraints": [
      "`1 <= k <= points.length <= 104`",
      "`-104 < xi, yi < 104`"
    ],
    "companies": [
      {
        "name": "Meta",
        "slug": "facebook",
        "frequency": 80
      },
      {
        "name": "Amazon",
        "slug": "amazon",
        "frequency": 12
      },
      {
        "name": "Google",
        "slug": "google",
        "frequency": 2
      },
      {
        "name": "Salesforce",
        "slug": "salesforce",
        "frequency": 2
      }
    ]
  },
  {
    "id": "977",
    "slug": "squares-of-a-sorted-array",
    "title": "Squares of a Sorted Array",
    "difficulty": "Easy",
    "description": "Given an integer array `nums` sorted in **non-decreasing** order, return _an array of **the squares of each number** sorted in non-decreasing order_.",
    "examples": [
      {
        "input": "nums = \\[-4,-1,0,3,10\\]",
        "output": "\\[0,1,9,16,100\\]",
        "explanation": "After squaring, the array becomes \\[16,1,0,9,100\\]."
      },
      {
        "input": "nums = \\[-7,-3,2,3,11\\]",
        "output": "\\[4,9,9,49,121\\]"
      }
    ],
    "constraints": [
      "`1 <= nums.length <= 104`",
      "`-104 <= nums[i] <= 104`",
      "`nums` is sorted in non-decreasing order.",
      "Follow up: Squaring each element and sorting the new array is very trivial, could you find an `O(n)` solution using a different approach?"
    ],
    "companies": [
      {
        "name": "Meta",
        "slug": "facebook",
        "frequency": 20
      },
      {
        "name": "Uber",
        "slug": "uber",
        "frequency": 17
      },
      {
        "name": "Amazon",
        "slug": "amazon",
        "frequency": 6
      },
      {
        "name": "Google",
        "slug": "google",
        "frequency": 5
      },
      {
        "name": "Yandex",
        "slug": "yandex",
        "frequency": 3
      },
      {
        "name": "Bloomberg",
        "slug": "bloomberg",
        "frequency": 3
      },
      {
        "name": "Instacart",
        "slug": "instacart",
        "frequency": 2
      },
      {
        "name": "Microsoft",
        "slug": "microsoft",
        "frequency": 2
      },
      {
        "name": "Agoda",
        "slug": "agoda",
        "frequency": 2
      }
    ]
  },
  {
    "id": "986",
    "slug": "interval-list-intersections",
    "title": "Interval List Intersections",
    "difficulty": "Medium",
    "description": "You are given two lists of closed intervals, `firstList` and `secondList`, where `firstList[i] = [starti, endi]` and `secondList[j] = [startj, endj]`. Each list of intervals is pairwise **disjoint** and in **sorted order**. Return _the intersection of these two interval lists_. A **closed interval** `[a, b]` (with `a <= b`) denotes the set of real numbers `x` with `a <= x <= b`. The **intersection** of two closed intervals is a set of real numbers that are either empty or represented as a closed interval. For example, the intersection of `[1, 3]` and `[2, 4]` is `[2, 3]`.",
    "examples": [
      {
        "input": "firstList = \\[\\[0,2\\],\\[5,10\\],\\[13,23\\],\\[24,25\\]\\], secondList = \\[\\[1,5\\],\\[8,12\\],\\[15,24\\],\\[25,26\\]\\]",
        "output": "\\[\\[1,2\\],\\[5,5\\],\\[8,10\\],\\[15,23\\],\\[24,24\\],\\[25,25\\]\\]"
      },
      {
        "input": "firstList = \\[\\[1,3\\],\\[5,9\\]\\], secondList = \\[\\]",
        "output": "\\[\\]"
      }
    ],
    "constraints": [
      "`0 <= firstList.length, secondList.length <= 1000`",
      "`firstList.length + secondList.length >= 1`",
      "`0 <= starti < endi <= 109`",
      "`endi < starti+1`",
      "`0 <= startj < endj <= 109`",
      "`endj < startj+1`"
    ],
    "companies": [
      {
        "name": "Meta",
        "slug": "facebook",
        "frequency": 73
      },
      {
        "name": "Google",
        "slug": "google",
        "frequency": 6
      },
      {
        "name": "Uber",
        "slug": "uber",
        "frequency": 5
      },
      {
        "name": "Yandex",
        "slug": "yandex",
        "frequency": 3
      },
      {
        "name": "Amazon",
        "slug": "amazon",
        "frequency": 3
      },
      {
        "name": "Microsoft",
        "slug": "microsoft",
        "frequency": 2
      },
      {
        "name": "Verkada",
        "slug": "verkada",
        "frequency": 2
      }
    ]
  },
  {
    "id": "995",
    "slug": "minimum-number-of-k-consecutive-bit-flips",
    "title": "Minimum Number of K Consecutive Bit Flips",
    "difficulty": "Hard",
    "description": "You are given a binary array `nums` and an integer `k`. A **k-bit flip** is choosing a **subarray** of length `k` from `nums` and simultaneously changing every `0` in the subarray to `1`, and every `1` in the subarray to `0`. Return _the minimum number of **k-bit flips** required so that there is no_ `0` _in the array_. If it is not possible, return `-1`. A **subarray** is a **contiguous** part of an array.",
    "examples": [
      {
        "input": "nums = \\[0,1,0\\], k = 1",
        "output": "2",
        "explanation": "Flip nums\\[0\\], then flip nums\\[2\\]."
      },
      {
        "input": "nums = \\[1,1,0\\], k = 2",
        "output": "-1",
        "explanation": "No matter how we flip subarrays of size 2, we cannot make the array become \\[1,1,1\\]."
      },
      {
        "input": "nums = \\[0,0,0,1,0,1,1,0\\], k = 3",
        "output": "3",
        "explanation": ""
      }
    ],
    "constraints": ["`1 <= nums.length <= 105`", "`1 <= k <= nums.length`"],
    "companies": [
      {
        "name": "Amazon",
        "slug": "amazon",
        "frequency": 3
      },
      {
        "name": "Google",
        "slug": "google",
        "frequency": 2
      },
      {
        "name": "Meta",
        "slug": "facebook",
        "frequency": 2
      }
    ]
  },
  {
    "id": "1065",
    "slug": "index-pairs-of-a-string",
    "title": "Index Pairs of a String",
    "difficulty": "Easy",
    "description": "Given a string `text` and an array of strings `words`, return _an array of all index pairs_ `[i, j]` _so that the substring_ `text[i...j]` _is in `words`_. Return the pairs `[i, j]` in sorted order (i.e., sort them by their first coordinate, and in case of ties sort them by their second coordinate).",
    "examples": [
      {
        "input": "text =  \"thestoryofleetcodeandme \", words = \\[ \"story \", \"fleet \", \"leetcode \"\\]",
        "output": "\\[\\[3,7\\],\\[9,13\\],\\[10,17\\]\\]"
      },
      {
        "input": "text =  \"ababa \", words = \\[ \"aba \", \"ab \"\\]",
        "output": "\\[\\[0,1\\],\\[0,2\\],\\[2,3\\],\\[2,4\\]\\]",
        "explanation": "Notice that matches can overlap, see  \"aba \" is found in \\[0,2\\] and \\[2,4\\]."
      }
    ],
    "constraints": [
      "`1 <= text.length <= 100`",
      "`1 <= words.length <= 20`",
      "`1 <= words[i].length <= 50`",
      "`text` and `words[i]` consist of lowercase English letters.",
      "All the strings of `words` are unique."
    ],
    "companies": []
  },
  {
    "id": "1203",
    "slug": "sort-items-by-groups-respecting-dependencies",
    "title": "Sort Items by Groups Respecting Dependencies",
    "difficulty": "Hard",
    "description": "There are `n` items each belonging to zero or one of `m` groups where `group[i]` is the group that the `i`\\-th item belongs to and it's equal to `-1` if the `i`\\-th item belongs to no group. The items and the groups are zero indexed. A group can have no item belonging to it. Return a sorted list of the items such that: *  The items that belong to the same group are next to each other in the sorted list. *  There are some relations between these items where `beforeItems[i]` is a list containing all the items that should come before the `i`\\-th item in the sorted array (to the left of the `i`\\-th item). Return any solution if there is more than one solution and return an **empty list** if there is no solution.",
    "examples": [
      {
        "input": "n = 8, m = 2, group = \\[-1,-1,1,0,0,1,0,-1\\], beforeItems = \\[\\[\\],\\[6\\],\\[5\\],\\[6\\],\\[3,6\\],\\[\\],\\[\\],\\[\\]\\]",
        "output": "\\[6,3,4,1,5,2,0,7\\]"
      },
      {
        "input": "n = 8, m = 2, group = \\[-1,-1,1,0,0,1,0,-1\\], beforeItems = \\[\\[\\],\\[6\\],\\[5\\],\\[6\\],\\[3\\],\\[\\],\\[4\\],\\[\\]\\]",
        "output": "\\[\\]",
        "explanation": "This is the same as example 1 except that 4 needs to be before 6 in the sorted list."
      }
    ],
    "constraints": [
      "`1 <= m <= n <= 3  104`",
      "`group.length == beforeItems.length == n`",
      "`-1 <= group[i] <= m - 1`",
      "`0 <= beforeItems[i].length <= n - 1`",
      "`0 <= beforeItems[i][j] <= n - 1`",
      "`i != beforeItems[i][j]`",
      "`beforeItems[i]` does not contain duplicates elements."
    ],
    "companies": [
      {
        "name": "Citadel",
        "slug": "citadel",
        "frequency": 3
      }
    ]
  },
  {
    "id": "1593",
    "slug": "split-a-string-into-the-max-number-of-unique-substrings",
    "title": "Split a String Into the Max Number of Unique Substrings",
    "difficulty": "Medium",
    "description": "Given a string `s`, return _the maximum number of unique substrings that the given string can be split into_. You can split string `s` into any list of **non-empty substrings**, where the concatenation of the substrings forms the original string. However, you must split the substrings such that all of them are **unique**. A **substring** is a contiguous sequence of characters within a string.",
    "examples": [
      {
        "input": "s =  \"ababccc \"",
        "output": "5"
      },
      {
        "input": "s =  \"aba \"",
        "output": "2"
      },
      {
        "input": "s =  \"aa \"",
        "output": "1"
      }
    ],
    "constraints": [
      "`1 <= s.length <= 16`",
      "`s` contains only lower case English letters."
    ],
    "companies": [
      {
        "name": "Amazon",
        "slug": "amazon",
        "frequency": 2
      },
      {
        "name": "Meta",
        "slug": "facebook",
        "frequency": 2
      }
    ]
  },
  {
    "id": "2022",
    "slug": "convert-1d-array-into-2d-array",
    "title": "Convert 1D Array Into 2D Array",
    "difficulty": "Easy",
    "description": "You are given a **0-indexed** 1-dimensional (1D) integer array `original`, and two integers, `m` and `n`. You are tasked with creating a 2-dimensional (2D) array with `m` rows and `n` columns using **all** the elements from `original`. The elements from indices `0` to `n - 1` (**inclusive**) of `original` should form the first row of the constructed 2D array, the elements from indices `n` to `2 * n - 1` (**inclusive**) should form the second row of the constructed 2D array, and so on. Return _an_ `m x n` _2D array constructed according to the above procedure, or an empty 2D array if it is impossible_.",
    "examples": [
      {
        "input": "original = \\[1,2,3,4\\], m = 2, n = 2",
        "output": "\\[\\[1,2\\],\\[3,4\\]\\]",
        "explanation": "The constructed 2D array should contain 2 rows and 2 columns."
      },
      {
        "input": "original = \\[1,2,3\\], m = 1, n = 3",
        "output": "\\[\\[1,2,3\\]\\]",
        "explanation": "The constructed 2D array should contain 1 row and 3 columns."
      },
      {
        "input": "original = \\[1,2\\], m = 1, n = 1",
        "output": "\\[\\]",
        "explanation": "There are 2 elements in original."
      }
    ],
    "constraints": [
      "`1 <= original.length <= 5  104`",
      "`1 <= original[i] <= 105`",
      "`1 <= m, n <= 4  104`"
    ],
    "companies": [
      {
        "name": "Google",
        "slug": "google",
        "frequency": 2
      },
      {
        "name": "Amazon",
        "slug": "amazon",
        "frequency": 2
      },
      {
        "name": "Meta",
        "slug": "facebook",
        "frequency": 2
      }
    ]
  }
]
