[
  {
    "id": "1",
    "slug": "two-sum",
    "solution": "def twoSum(nums, target):\n    map = {}\n    for i, num in enumerate(nums):\n        complement = target - num\n        if complement in map:\n            return [map[complement], i]\n        map[num] = i\n    return []"
  },
  {
    "id": "2",
    "slug": "add-two-numbers",
    "solution": "class ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\ndef addTwoNumbers(l1, l2):\n    dummy = ListNode(0)\n    current = dummy\n    carry = 0\n\n    while l1 or l2 or carry:\n        sum_val = (l1.val if l1 else 0) + (l2.val if l2 else 0) + carry\n        carry = sum_val // 10\n        current.next = ListNode(sum_val % 10)\n        current = current.next\n\n        if l1: l1 = l1.next\n        if l2: l2 = l2.next\n\n    return dummy.next"
  },
  {
    "id": "3",
    "slug": "longest-substring-without-repeating-characters",
    "solution": "def length_of_longest_substring(s: str) -> int:\n    left = 0\n    right = 0\n    max_length = 0\n    characters = set()\n\n    while right < len(s):\n        if s[right] not in characters:\n            characters.add(s[right])\n            max_length = max(max_length, right - left + 1)\n            right += 1\n        else:\n            characters.remove(s[left])\n            left += 1\n\n    return max_length"
  },
  {
    "id": "4",
    "slug": "median-of-two-sorted-arrays",
    "solution": "def findMedianSortedArrays(nums1, nums2):\n    if len(nums1) > len(nums2):\n        return findMedianSortedArrays(nums2, nums1)\n    \n    x, y = len(nums1), len(nums2)\n    low, high = 0, x\n\n    while low <= high:\n        partition_x = (low + high) // 2\n        partition_y = (x + y + 1) // 2 - partition_x\n\n        max_left_x = float('-inf') if partition_x == 0 else nums1[partition_x - 1]\n        min_right_x = float('inf') if partition_x == x else nums1[partition_x]\n\n        max_left_y = float('-inf') if partition_y == 0 else nums2[partition_y - 1]\n        min_right_y = float('inf') if partition_y == y else nums2[partition_y]\n\n        if max_left_x <= min_right_y and max_left_y <= min_right_x:\n            if (x + y) % 2 == 0:\n                return (max(max_left_x, max_left_y) + min(min_right_x, min_right_y)) / 2\n            else:\n                return max(max_left_x, max_left_y)\n        elif max_left_x > min_right_y:\n            high = partition_x - 1\n        else:\n            low = partition_x + 1\n    \n    return 0"
  },
  {
    "id": "5",
    "slug": "longest-palindromic-substring",
    "solution": "def longest_palindromic_substring(s: str) -> str:\n    n = len(s)\n    if n == 0: return \"\"\n\n    start, max_length = 0, 1\n\n    for i in range(n):\n        l, r = i, i\n\n        while r < n - 1 and s[r] == s[r + 1]:\n            r += 1\n        i = r\n\n        while l > 0 and r < n - 1 and s[l - 1] == s[r + 1]:\n            l -= 1\n            r += 1\n\n        length = r - l + 1\n        if length > max_length:\n            start, max_length = l, length\n\n    return s[start:start + max_length]"
  },
  {
    "id": "11",
    "slug": "container-with-most-water",
    "solution": "def max_area(height):\n    max_area, left, right = 0, 0, len(height) - 1\n    while left < right:\n        max_area = max(max_area, min(height[left], height[right]) * (right - left))\n        if height[left] < height[right]:\n            left += 1\n        else:\n            right -= 1\n    return max_area"
  },
  {
    "id": "15",
    "slug": "3sum",
    "solution": "def threeSum(nums):\n    nums.sort()\n    result = []\n\n    for i in range(len(nums) - 2):\n        if i == 0 or nums[i] != nums[i - 1]:\n            j, k = i + 1, len(nums) - 1\n            while j < k:\n                s = nums[i] + nums[j] + nums[k]\n                if s == 0:\n                    result.append([nums[i], nums[j], nums[k]])\n                    while j < k and nums[j] == nums[j + 1]:\n                        j += 1\n                    while j < k and nums[k] == nums[k - 1]:\n                        k -= 1\n                    j += 1\n                    k -= 1\n                elif s < 0:\n                    j += 1\n                else:\n                    k -= 1\n\n    return result"
  },
  {
    "id": "16",
    "slug": "3sum-closest",
    "solution": "def threeSumClosest(nums, target):\n    nums.sort()\n    closest = sum(nums[:3])\n    for i in range(len(nums) - 2):\n        left, right = i + 1, len(nums) - 1\n        while left < right:\n            cur_sum = nums[i] + nums[left] + nums[right]\n            if cur_sum == target:\n                return cur_sum\n            if abs(target - cur_sum) < abs(target - closest):\n                closest = cur_sum\n            if cur_sum < target:\n                left += 1\n            else:\n                right -= 1\n    return closest"
  },
  {
    "id": "17",
    "slug": "letter-combinations-of-a-phone-number",
    "solution": "def letter_combinations(digits: str):\n    if not digits: return []\n    phone = [\"abc\", \"def\", \"ghi\", \"jkl\", \"mno\", \"pqrs\", \"tuv\", \"wxyz\"]\n    result = [\"\"]\n\n    for digit in digits:\n        temp = []\n        for s in result:\n            for c in phone[int(digit) - 2]:\n                temp.append(s + c)\n        result = temp\n\n    return result"
  },
  {
    "id": "19",
    "slug": "remove-nth-node-from-end-of-list",
    "solution": "class ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\ndef removeNthFromEnd(head, n):\n    first = head\n    second = head\n    \n    for i in range(n):\n        first = first.next\n    \n    if not first:\n        head = head.next\n        return head\n    \n    while first.next:\n        first = first.next\n        second = second.next\n    \n    second.next = second.next.next\n    \n    return head"
  },
  {
    "id": "21",
    "slug": "merge-two-sorted-lists",
    "solution": "class ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n         \ndef merge_two_lists(list1, list2):\n    if list1 is None:\n        return list2\n    if list2 is None:\n        return list1\n\n    if list1.val < list2.val:\n        list1.next = merge_two_lists(list1.next, list2)\n        return list1\n    else:\n        list2.next = merge_two_lists(list1, list2.next)\n        return list2"
  },
  {
    "id": "22",
    "slug": "generate-parentheses",
    "solution": "def generate_parenthesis(n):\n    def generate_parenthesis_helper(open, close, current):\n        if open == 0 and close == 0:\n            result.append(current)\n            return\n        if open > 0:\n            generate_parenthesis_helper(open - 1, close + 1, current + '(')\n        if close > 0:\n            generate_parenthesis_helper(open, close - 1, current + ')')\n\n    result = []\n    generate_parenthesis_helper(n, 0, '')\n    return result"
  },
  {
    "id": "23",
    "slug": "merge-k-sorted-lists",
    "solution": "class ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n        \nclass Solution:\n    def mergeKLists(self, lists):\n        if not lists: return None\n        while len(lists) > 1:\n            lists.append(self.merge2Lists(lists.pop(0), lists.pop(0)))\n        return lists[0]\n        \n    def merge2Lists(self, l1, l2):\n        if not l1: return l2\n        if not l2: return l1\n        if l1.val <= l2.val:\n            l1.next = self.merge2Lists(l1.next, l2)\n            return l1\n        else:\n            l2.next = self.merge2Lists(l1, l2.next)\n            return l2"
  },
  {
    "id": "24",
    "slug": "swap-nodes-in-pairs",
    "solution": "def swapPairs(head: Optional[ListNode]) -> Optional[ListNode]:\n    if not head or not head.next:\n        return head\n\n    second = head.next\n    head.next = swapPairs(second.next)\n    second.next = head\n\n    return second"
  },
  {
    "id": "25",
    "slug": "reverse-nodes-in-k-group",
    "solution": "class ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\ndef reverseKGroup(head, k):\n    if not head or k == 1:\n        return head\n        \n    cur = head\n    length = 0\n    while cur:\n        length += 1\n        cur = cur.next\n        \n    dummy = ListNode(0)\n    dummy.next = head\n    prev = dummy\n    cur = head\n    \n    while length >= k:\n        for _ in range(1, k):\n            temp = cur.next\n            cur.next = temp.next\n            temp.next = prev.next\n            prev.next = temp\n            \n        prev = cur\n        cur = cur.next\n        length -= k\n        \n    return dummy.next"
  },
  {
    "id": "30",
    "slug": "substring-with-concatenation-of-all-words",
    "solution": "from collections import Counter\n\ndef findSubstring(s, words):\n    if not s or not words:\n        return []\n\n    word_count = Counter(words)\n    word_length = len(words[0])\n    total_words = len(words)\n    total_length = word_length * total_words\n    result = []\n\n    for i in range(len(s) - total_length + 1):\n        temp_word_count = Counter()\n        for j in range(total_words):\n            current_word = s[i + j * word_length:i + (j + 1) * word_length]\n            if current_word not in word_count:\n                break\n            temp_word_count[current_word] += 1\n            if temp_word_count[current_word] > word_count[current_word]:\n                break\n            if j + 1 == total_words:\n                result.append(i)\n\n    return result"
  },
  {
    "id": "33",
    "slug": "search-in-rotated-sorted-array",
    "solution": "def search(nums, target):\n    left, right = 0, len(nums) - 1\n    while left <= right:\n        mid = left + (right - left) // 2\n        if nums[mid] == target:\n            return mid\n        if nums[mid] >= nums[left]:\n            if target >= nums[left] and target < nums[mid]:\n                right = mid - 1\n            else:\n                left = mid + 1\n        else:\n            if target > nums[mid] and target <= nums[right]:\n                left = mid + 1\n            else:\n                right = mid - 1\n    return -1"
  },
  {
    "id": "37",
    "slug": "sudoku-solver",
    "solution": "def isValid(board, row, col, c):\n    for i in range(9):\n        if board[i][col] == c:\n            return False\n        if board[row][i] == c:\n            return False\n        if board[3 * (row // 3) + i // 3][3 * (col // 3) + i % 3] == c:\n            return False\n    return True\n\ndef solveSudokuHelper(board):\n    for i in range(9):\n        for j in range(9):\n            if board[i][j] == '.':\n                for c in '123456789':\n                    if isValid(board, i, j, c):\n                        board[i][j] = c\n\n                        if solveSudokuHelper(board):\n                            return True\n\n                        board[i][j] = '.'\n                return False\n\n    return True\n\ndef solveSudoku(board):\n    solveSudokuHelper(board)"
  },
  {
    "id": "39",
    "slug": "combination-sum",
    "solution": "def combinationSum(candidates, target):\n    def findCombinations(startIndex, remaining):\n        if remaining == 0:\n            return [[]]\n        if startIndex == len(candidates) or remaining < 0:\n            return []\n\n        result = []\n        result.extend(findCombinations(startIndex + 1, remaining))\n        result.extend([x + [candidates[startIndex]] for x in findCombinations(startIndex, remaining - candidates[startIndex])])\n        \n        return result\n\n    return findCombinations(0, target)"
  },
  {
    "id": "40",
    "slug": "combination-sum-ii",
    "solution": "def combinationSum2(candidates, target):\n    def combine(candidates, target, start, path, res):\n        if target == 0:\n            res.append(path)\n            return\n        for i in range(start, len(candidates)):\n            if i > start and candidates[i] == candidates[i - 1]:\n                continue\n            if candidates[i] > target:\n                break\n            combine(candidates, target - candidates[i], i+1, path + [candidates[i]], res)\n\n    candidates.sort()\n    res = []\n    combine(candidates, target, 0, [], res)\n    return res"
  },
  {
    "id": "41",
    "slug": "first-missing-positive",
    "solution": "def firstMissingPositive(nums):\n    n = len(nums)\n    for i in range(n):\n        while 1 <= nums[i] <= n and nums[nums[i] - 1] != nums[i]:\n            nums[nums[i] - 1], nums[i] = nums[i], nums[nums[i] - 1]\n\n    for i in range(n):\n        if nums[i] != i + 1:\n            return i + 1\n    return n + 1"
  },
  {
    "id": "42",
    "slug": "trapping-rain-water",
    "solution": "def trap(height):\n    n = len(height)\n    left, right, max_left, max_right, water = 0, n - 1, 0, 0, 0\n\n    while left < right:\n        if height[left] <= height[right]:\n            max_left = max(max_left, height[left])\n            water += max_left - height[left]\n            left += 1\n        else:\n            max_right = max(max_right, height[right])\n            water += max_right - height[right]\n            right -= 1\n\n    return water"
  },
  {
    "id": "46",
    "slug": "permutations",
    "solution": "from typing import List\n\ndef permute(nums: List[int]) -> List[List[int]]:\n    def helper(index):\n        if index == len(nums) - 1:\n            results.append(nums[:])\n            return\n\n        for i in range(index, len(nums)):\n            nums[index], nums[i] = nums[i], nums[index]\n            helper(index + 1)\n            nums[index], nums[i] = nums[i], nums[index]\n\n    results = []\n    helper(0)\n    return results"
  },
  {
    "id": "47",
    "slug": "permutations-ii",
    "solution": "from typing import List\n\ndef permuteUnique(nums: List[int]) -> List[List[int]]:\n    def backtrack(start):\n        if start == len(nums):\n            result.append(nums[:])\n        for i in range(start, len(nums)):\n            if i > start and nums[i] == nums[start]:\n                continue\n            nums[start], nums[i] = nums[i], nums[start]\n            backtrack(start + 1)\n            nums[start], nums[i] = nums[i], nums[start]\n\n    nums.sort()\n    result = []\n    backtrack(0)\n    return result"
  },
  {
    "id": "48",
    "slug": "rotate-image",
    "solution": "def rotate(matrix):\n    n = len(matrix)\n    for i in range(n // 2):\n        for j in range(i, n - i - 1):\n            temp = matrix[i][j]\n            matrix[i][j] = matrix[n - j - 1][i]\n            matrix[n - j - 1][i] = matrix[n - i - 1][n - j - 1]\n            matrix[n - i - 1][n - j - 1] = matrix[j][n - i - 1]\n            matrix[j][n - i - 1] = temp"
  },
  {
    "id": "51",
    "slug": "n-queens",
    "solution": "def solveNQueens(n):\n    def isSafe(board, row, col):\n        for i in range(col):\n            if board[row][i] == 'Q': return False\n        i, j = row, col\n        while i >= 0 and j >= 0:\n            if board[i][j] == 'Q': return False\n            i, j = i - 1, j - 1\n        i, j = row, col\n        while i < n and j >= 0:\n            if board[i][j] == 'Q': return False\n            i, j = i + 1, j - 1\n        return True\n\n    def solve(result, board, n, col):\n        if col == n:\n            result.append(board.copy())\n            return\n        for row in range(n):\n            if isSafe(board, row, col):\n                board[row] = board[row][:col] + 'Q' + board[row][col + 1:]\n                solve(result, board, n, col + 1)\n                board[row] = board[row][:col] + '.' + board[row][col + 1:]\n\n    result, board = [], ['.' * n for _ in range(n)]\n    solve(result, board, n, 0)\n    return result"
  },
  {
    "id": "53",
    "slug": "maximum-subarray",
    "solution": "def maxSubArray(nums):\n    max_sum = current_sum = nums[0]\n\n    for num in nums[1:]:\n        current_sum = max(current_sum + num, num)\n        max_sum = max(max_sum, current_sum)\n\n    return max_sum"
  },
  {
    "id": "54",
    "slug": "spiral-matrix",
    "solution": "def spiralOrder(matrix):\n    result = []\n    if not matrix: return result\n    m, n = len(matrix), len(matrix[0])\n    rowStart, colStart, rowEnd, colEnd = 0, 0, m - 1, n - 1\n\n    while rowStart <= rowEnd and colStart <= colEnd:\n        for i in range(colStart, colEnd + 1): \n            result.append(matrix[rowStart][i])\n        rowStart += 1\n        \n        for i in range(rowStart, rowEnd + 1): \n            result.append(matrix[i][colEnd]) \n        colEnd -= 1\n        \n        if rowStart <= rowEnd:\n            for i in range(colEnd, colStart - 1, -1): \n                result.append(matrix[rowEnd][i]) \n        rowEnd -= 1\n        \n        if colStart <= colEnd:\n            for i in range(rowEnd, rowStart - 1, -1): \n                result.append(matrix[i][colStart]) \n        colStart += 1\n        \n    return result"
  },
  {
    "id": "55",
    "slug": "jump-game",
    "solution": "def canJump(nums):\n    max_reach = 0\n    for i, num in enumerate(nums):\n        if i > max_reach:\n            return False\n        max_reach = max(max_reach, i + num)\n    return True"
  },
  {
    "id": "56",
    "slug": "merge-intervals",
    "solution": "def merge(intervals):\n    if not intervals:\n        return []\n\n    intervals.sort()\n    result = [intervals[0]]\n\n    for i in range(1, len(intervals)):\n        if result[-1][1] >= intervals[i][0]:\n            result[-1][1] = max(result[-1][1], intervals[i][1])\n        else:\n            result.append(intervals[i])\n\n    return result"
  },
  {
    "id": "57",
    "slug": "insert-interval",
    "solution": "from typing import List\n\ndef insert(intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\n    result = []\n    start_pos = 0\n\n    while start_pos < len(intervals) and intervals[start_pos][1] < newInterval[0]:\n        result.append(intervals[start_pos])\n        start_pos += 1\n\n    while start_pos < len(intervals) and intervals[start_pos][0] <= newInterval[1]:\n        newInterval[0] = min(newInterval[0], intervals[start_pos][0])\n        newInterval[1] = max(newInterval[1], intervals[start_pos][1])\n        start_pos += 1\n\n    result.append(newInterval)\n\n    while start_pos < len(intervals):\n        result.append(intervals[start_pos])\n        start_pos += 1\n\n    return result"
  },
  {
    "id": "61",
    "slug": "rotate-list",
    "solution": "class ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\ndef rotateRight(head, k):\n    if not head or not head.next or k == 0:\n        return head\n\n    current = head\n    length = 1\n    while current.next:\n        length += 1\n        current = current.next\n    current.next = head\n    k = length - k % length\n\n    while k:\n        k -= 1\n        current = current.next\n    head = current.next\n    current.next = None\n\n    return head"
  },
  {
    "id": "62",
    "slug": "unique-paths",
    "solution": "def uniquePaths(m, n):\n    dp = [[1] * n for _ in range(m)]\n    for i in range(1, m):\n        for j in range(1, n):\n            dp[i][j] = dp[i - 1][j] + dp[i][j - 1]\n    return dp[m - 1][n - 1]"
  },
  {
    "id": "70",
    "slug": "climbing-stairs",
    "solution": "def climbStairs(n):\n    if n <= 2:\n        return n\n    a, b = 1, 2\n    for _ in range(3, n+1):\n        a, b = b, a + b\n    return b"
  },
  {
    "id": "73",
    "slug": "set-matrix-zeroes",
    "solution": "def setZeroes(matrix):\n    rows = len(matrix)\n    cols = len(matrix[0])\n    firstRow, firstCol = False, False\n\n    for i in range(rows):\n        for j in range(cols):\n            if matrix[i][j] == 0:\n                if i == 0: firstRow = True\n                if j == 0: firstCol = True\n                matrix[i][0] = 0\n                matrix[0][j] = 0\n\n    for i in range(1, rows):\n        for j in range(1, cols):\n            if matrix[i][0] == 0 or matrix[0][j] == 0:\n                matrix[i][j] = 0\n\n    if firstRow:\n        for j in range(cols):\n            matrix[0][j] = 0\n\n    if firstCol:\n        for i in range(rows):\n            matrix[i][0] = 0"
  },
  {
    "id": "74",
    "slug": "search-a-2d-matrix",
    "solution": "def searchMatrix(matrix, target):\n    m, n = len(matrix), len(matrix[0])\n    l, r = 0, m * n - 1\n\n    while l <= r:\n        mid = l + (r - l) // 2\n        mid_val = matrix[mid // n][mid % n]\n\n        if mid_val == target:\n            return True\n        elif mid_val < target:\n            l = mid + 1\n        else:\n            r = mid - 1\n\n    return False"
  },
  {
    "id": "75",
    "slug": "sort-colors",
    "solution": "def sortColors(nums: List[int]) -> None:\n    red, white, blue = 0, 0, len(nums) - 1\n    while white <= blue:\n        if nums[white] == 0:\n            nums[red], nums[white] = nums[white], nums[red]\n            red += 1\n            white += 1\n        elif nums[white] == 1:\n            white += 1\n        else:\n            nums[white], nums[blue] = nums[blue], nums[white]\n            blue -= 1"
  },
  {
    "id": "76",
    "slug": "minimum-window-substring",
    "solution": "from collections import Counter\n\ndef min_window(s, t):\n    need = Counter(t)\n    window = {}\n    \n    left = 0\n    right = 0\n    valid = 0\n    start = 0\n    length = float('inf')\n\n    while right < len(s):\n        c = s[right]\n        right += 1\n        if c in need:\n            window[c] = window.get(c, 0) + 1\n            if window[c] <= need[c]:\n                valid += 1\n\n        while valid == len(t):\n            if right - left < length:\n                start = left\n                length = right - left\n\n            d = s[left]\n            left += 1\n            if d in need:\n                if window[d] <= need[d]:\n                    valid -= 1\n                window[d] -= 1\n\n    return \"\" if length == float('inf') else s[start : start + length]"
  },
  {
    "id": "77",
    "slug": "combinations",
    "solution": "from typing import List\n\ndef combine(n: int, k: int) -> List[List[int]]:\n    def backtrack(start, current_combination):\n        if len(current_combination) == k:\n            result.append(current_combination[:])\n\n        for i in range(start, n + 1):\n            current_combination.append(i)\n            backtrack(i + 1, current_combination)\n            current_combination.pop()\n\n    result = []\n    backtrack(1, [])\n    return result"
  },
  {
    "id": "78",
    "slug": "subsets",
    "solution": "def subsets(nums):\n    n = len(nums)\n    num_subsets = 1 << n\n    result = []\n\n    for i in range(num_subsets):\n        subset = []\n        for j in range(n):\n            if i & (1 << j):\n                subset.append(nums[j])\n        result.append(subset)\n    return result"
  },
  {
    "id": "79",
    "slug": "word-search",
    "solution": "def exist(board, word):\n    m, n = len(board), len(board[0])\n\n    def dfs(i, j, k):\n        if not 0 <= i < m or not 0 <= j < n or board[i][j] != word[k]:\n            return False\n        if k == len(word) - 1:\n            return True\n\n        tmp, board[i][j] = board[i][j], '/'\n        res = dfs(i + 1, j, k + 1) or dfs(i - 1, j, k + 1) or dfs(i, j + 1, k + 1) or dfs(i, j - 1, k + 1)\n        board[i][j] = tmp\n        return res\n\n    for i in range(m):\n        for j in range(n):\n            if dfs(i, j, 0):\n                return True\n    return False"
  },
  {
    "id": "81",
    "slug": "search-in-rotated-sorted-array-ii",
    "solution": "def search(nums, target):\n    left, right = 0, len(nums) - 1\n    while left <= right:\n        mid = left + (right - left) // 2\n        if nums[mid] == target:\n            return True\n\n        if nums[mid] == nums[left]:\n            left += 1\n        elif nums[mid] > nums[left]:\n            if nums[left] <= target < nums[mid]:\n                right = mid - 1\n            else:\n                left = mid + 1\n        else:\n            if nums[mid] < target <= nums[right]:\n                left = mid + 1\n            else:\n                right = mid - 1\n    return False"
  },
  {
    "id": "83",
    "slug": "remove-duplicates-from-sorted-list",
    "solution": "class ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\ndef delete_duplicates(head):\n    current = head\n    while current and current.next:\n        if current.next.val == current.val:\n            current.next = current.next.next\n        else:\n            current = current.next\n    return head"
  },
  {
    "id": "90",
    "slug": "subsets-ii",
    "solution": "from itertools import combinations\n\ndef subsetsWithDup(nums):\n    result = set()\n    nums.sort()\n    for i in range(len(nums) + 1):\n        for combo in combinations(nums, i):\n            result.add(combo)\n    return list(result)"
  },
  {
    "id": "91",
    "slug": "decode-ways",
    "solution": "def numDecodings(s: str) -> int:\n    n = len(s)\n    dp = [0] * (n + 1)\n    dp[0] = 1\n    dp[1] = 1 if s[0] != '0' else 0\n\n    for i in range(2, n + 1):\n        one_digit = int(s[i - 1:i])\n        two_digits = int(s[i - 2:i])\n\n        if one_digit >= 1:\n            dp[i] += dp[i - 1]\n        if two_digits >= 10 and two_digits <= 26:\n            dp[i] += dp[i - 2]\n    return dp[n]"
  },
  {
    "id": "92",
    "slug": "reverse-linked-list-ii",
    "solution": "def reverseBetween(self, head: Optional[ListNode], left: int, right: int) -> Optional[ListNode]:\n    if not head or left == right:\n        return head\n    dummy = ListNode(0)\n    dummy.next = head\n    pre = dummy\n    for _ in range(left - 1):\n        pre = pre.next\n    cur = pre.next\n    for _ in range(left, right):\n        t = cur.next\n        cur.next = t.next\n        t.next = pre.next\n        pre.next = t\n    return dummy.next"
  },
  {
    "id": "98",
    "slug": "validate-binary-search-tree",
    "solution": "class TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef isValidBSTHelper(node, min_val, max_val):\n    if node is None:\n        return True\n    if not min_val < node.val < max_val:\n        return False\n    return (isValidBSTHelper(node.left, min_val, node.val) and\n            isValidBSTHelper(node.right, node.val, max_val))\n\ndef isValidBST(root):\n    return isValidBSTHelper(root, float('-inf'), float('inf'))"
  },
  {
    "id": "100",
    "slug": "same-tree",
    "solution": "class TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef is_same_tree(p, q):\n    if p is None and q is None:\n        return True\n    if p is None or q is None:\n        return False\n    if p.val != q.val:\n        return False\n    return is_same_tree(p.left, q.left) and is_same_tree(p.right, q.right)"
  },
  {
    "id": "102",
    "slug": "binary-tree-level-order-traversal",
    "solution": "class TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef levelOrder(root):\n    if not root:\n        return []\n\n    result = []\n    queue = [root]\n\n    while queue:\n        level = []\n        for i in range(len(queue)):\n            node = queue.pop(0)\n\n            if node.left:\n                queue.append(node.left)\n\n            if node.right:\n                queue.append(node.right)\n\n            level.append(node.val)\n\n        result.append(level)\n\n    return result"
  },
  {
    "id": "103",
    "slug": "binary-tree-zigzag-level-order-traversal",
    "solution": "class TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef zigzagLevelOrder(root):\n    if not root:\n        return []\n\n    result = []\n    queue = [root]\n    zigzag = False\n\n    while queue:\n        level = []\n        for i in range(len(queue)):\n            node = queue.pop(0)\n\n            if zigzag:\n                level.insert(0, node.val)\n            else:\n                level.append(node.val)\n\n            if node.left:\n                queue.append(node.left)\n            if node.right:\n                queue.append(node.right)\n\n        result.append(level)\n        zigzag = not zigzag\n\n    return result"
  },
  {
    "id": "104",
    "slug": "maximum-depth-of-binary-tree",
    "solution": "def maxDepth(root):\n    if root is None:\n        return 0\n    return 1 + max(maxDepth(root.left), maxDepth(root.right))"
  },
  {
    "id": "105",
    "slug": "construct-binary-tree-from-preorder-and-inorder-traversal",
    "solution": "class TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef build_tree(preorder, inorder):\n    def construct_tree(in_left, in_right):\n        nonlocal pre_idx\n        if in_left > in_right:\n            return None\n\n        root_val = preorder[pre_idx]\n        root = TreeNode(root_val)\n        idx = in_map[root_val]\n\n        pre_idx += 1\n        root.left = construct_tree(in_left, idx - 1)\n        root.right = construct_tree(idx + 1, in_right)\n\n        return root\n\n    in_map = {val: idx for idx, val in enumerate(inorder)}\n    pre_idx = 0\n    return construct_tree(0, len(inorder) - 1)"
  },
  {
    "id": "107",
    "slug": "binary-tree-level-order-traversal-ii",
    "solution": "from collections import deque\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef levelOrderBottom(root):\n    result = []\n    if not root:\n        return result\n\n    queue = deque([root])\n\n    while queue:\n        level = []\n        size = len(queue)\n\n        for i in range(size):\n            current = queue.popleft()\n            level.append(current.val)\n\n            if current.left:\n                queue.append(current.left)\n            if current.right:\n                queue.append(current.right)\n\n        result.insert(0, level)\n\n    return result"
  },
  {
    "id": "111",
    "slug": "minimum-depth-of-binary-tree",
    "solution": "def minDepth(root):\n    if not root:\n        return 0\n    left = minDepth(root.left)\n    right = minDepth(root.right)\n    return (left == 0 or right == 0) and left + right + 1 or min(left, right) + 1"
  },
  {
    "id": "112",
    "slug": "path-sum",
    "solution": "class TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef hasPathSum(root, targetSum):\n    if root is None:\n        return False\n    if root.left is None and root.right is None:\n        return targetSum - root.val == 0\n    return hasPathSum(root.left, targetSum - root.val) or hasPathSum(root.right, targetSum - root.val)"
  },
  {
    "id": "113",
    "slug": "path-sum-ii",
    "solution": "class TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef pathSum(root, targetSum):\n    def helper(root, targetSum, current, ans):\n        if not root:\n            return\n        current.append(root.val)\n        if not root.left and not root.right and targetSum == root.val:\n            ans.append(current[:])\n        helper(root.left, targetSum - root.val, current, ans)\n        helper(root.right, targetSum - root.val, current, ans)\n        current.pop()\n\n    ans = []\n    helper(root, targetSum, [], ans)\n    return ans"
  },
  {
    "id": "121",
    "slug": "best-time-to-buy-and-sell-stock",
    "solution": "def maxProfit(prices):\n    minPrice = float('inf')\n    maxProfit = 0\n    for price in prices:\n        minPrice = min(minPrice, price)\n        maxProfit = max(maxProfit, price - minPrice)\n    return maxProfit"
  },
  {
    "id": "124",
    "slug": "binary-tree-maximum-path-sum",
    "solution": "class TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef maxPathSum(root: TreeNode) -> int:\n    def helper(root):\n        nonlocal maxSum\n        if not root:\n            return 0\n\n        left = max(0, helper(root.left))\n        right = max(0, helper(root.right))\n\n        maxSum = max(maxSum, left + right + root.val)\n\n        return max(left, right) + root.val\n\n    maxSum = float('-inf')\n    helper(root)\n    return maxSum"
  },
  {
    "id": "128",
    "slug": "longest-consecutive-sequence",
    "solution": "def longest_consecutive(nums):\n    elements = set(nums)\n    longest_seq = 0\n\n    for num in nums:\n        if num - 1 not in elements:\n            current_num = num\n            current_seq = 1\n            \n            while current_num + 1 in elements:\n                current_num += 1\n                current_seq += 1\n\n            longest_seq = max(longest_seq, current_seq)\n    \n    return longest_seq"
  },
  {
    "id": "131",
    "slug": "palindrome-partitioning",
    "solution": "def isPalindrome(s, start, end):\n    while start < end:\n        if s[start] != s[end]:\n            return False\n        start += 1\n        end -= 1\n    return True\n\ndef dfs(s, start, results, current):\n    if start == len(s):\n        results.append(current[:])\n        return\n    \n    for end in range(start, len(s)):\n        if isPalindrome(s, start, end):\n            current.append(s[start:end+1])\n            dfs(s, end + 1, results, current)\n            current.pop()\n\ndef partition(s):\n    results = []\n    dfs(s, 0, results, [])\n    return results"
  },
  {
    "id": "134",
    "slug": "gas-station",
    "solution": "def can_complete_circuit(gas, cost):\n    total_gas, total_cost, start, gas_tank = 0, 0, 0, 0\n    for i in range(len(gas)):\n        total_gas += gas[i]\n        total_cost += cost[i]\n        gas_tank += gas[i] - cost[i]\n        if gas_tank < 0:\n            start = i + 1\n            gas_tank = 0\n    return -1 if total_gas < total_cost else start"
  },
  {
    "id": "136",
    "slug": "single-number",
    "solution": "def singleNumber(nums):\n    result = 0\n    for num in nums:\n        result ^= num\n    return result"
  },
  {
    "id": "139",
    "slug": "word-break",
    "solution": "def word_break(s, word_dict):\n    word_set = set(word_dict)\n    dp = [False] * (len(s) + 1)\n    dp[0] = True\n    for i in range(1, len(s) + 1):\n        for j in range(i):\n            if dp[j] and s[j:i] in word_set:\n                dp[i] = True\n                break\n    return dp[len(s)]"
  },
  {
    "id": "141",
    "slug": "linked-list-cycle",
    "solution": "def hasCycle(head):\n    slow = fast = head\n    while fast is not None and fast.next is not None:\n        slow = slow.next\n        fast = fast.next.next\n        if slow == fast:\n            return True\n    return False"
  },
  {
    "id": "142",
    "slug": "linked-list-cycle-ii",
    "solution": "class ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\ndef detectCycle(head):\n    slow, fast = head, head\n    \n    while fast and fast.next:\n        slow = slow.next\n        fast = fast.next.next\n        \n        if slow == fast:\n            start = head\n            while start != slow:\n                start = start.next\n                slow = slow.next\n            return start\n    \n    return None"
  },
  {
    "id": "143",
    "slug": "reorder-list",
    "solution": "class ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\ndef reorderList(head):\n    if not head or not head.next or not head.next.next:\n        return\n\n    # Find the middle node\n    slow = head\n    fast = head\n    while fast.next and fast.next.next:\n        slow = slow.next\n        fast = fast.next.next\n\n    # Reverse the second half\n    prev = None\n    curr = slow.next\n    while curr:\n        next = curr.next\n        curr.next = prev\n        prev = curr\n        curr = next\n    slow.next = None\n\n    # Merge two halves\n    first = head\n    second = prev\n    while second:\n        next = first.next\n        first.next = second\n        first = second\n        second = next"
  },
  {
    "id": "148",
    "slug": "sort-list",
    "solution": "class ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n\ndef sortList(head):\n    if not head or not head.next:\n        return head\n\n    slow, fast = head, head.next\n    while fast and fast.next:\n        slow = slow.next\n        fast = fast.next.next\n\n    mid = slow.next\n    slow.next = None\n\n    return merge(sortList(head), sortList(mid))\n\ndef merge(left, right):\n    if not left:\n        return right\n    if not right:\n        return left\n    if left.val < right.val:\n        left.next = merge(left.next, right)\n        return left\n    else:\n        right.next = merge(left, right.next)\n        return right"
  },
  {
    "id": "152",
    "slug": "maximum-product-subarray",
    "solution": "def maxProduct(nums):\n    max_so_far = min_so_far = result = nums[0]\n    \n    for i in range(1, len(nums)):\n        if nums[i] < 0:\n            max_so_far, min_so_far = min_so_far, max_so_far\n        \n        max_so_far = max(nums[i], max_so_far * nums[i])\n        min_so_far = min(nums[i], min_so_far * nums[i])\n        result = max(result, max_so_far)\n    \n    return result"
  },
  {
    "id": "153",
    "slug": "find-minimum-in-rotated-sorted-array",
    "solution": "def find_min(nums):\n    left, right = 0, len(nums) - 1\n\n    while left < right:\n        mid = left + (right - left) // 2\n        if nums[mid] > nums[right]:\n            left = mid + 1\n        else:\n            right = mid\n    return nums[left]"
  },
  {
    "id": "162",
    "slug": "find-peak-element",
    "solution": "def findPeakElement(nums):\n    left, right = 0, len(nums) - 1\n    while left < right:\n        mid = left + (right - left) // 2\n        if nums[mid] < nums[mid + 1]:\n            left = mid + 1\n        else:\n            right = mid\n    return left"
  },
  {
    "id": "169",
    "slug": "majority-element",
    "solution": "def majority_element(nums):\n    count = 0\n    candidate = None\n\n    for num in nums:\n        if count == 0:\n            candidate = num\n        count += (num == candidate) - (num != candidate)\n\n    return candidate"
  },
  {
    "id": "198",
    "slug": "house-robber",
    "solution": "def rob(nums):\n    prev1, prev2 = 0, 0\n    for num in nums:\n        prev1, prev2 = max(prev2 + num, prev1), prev1\n    return prev1"
  },
  {
    "id": "199",
    "slug": "binary-tree-right-side-view",
    "solution": "class TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef rightSideView(root):\n    if not root:\n        return []\n\n    result = []\n    queue = [root]\n\n    while queue:\n        level_size = len(queue)\n\n        for i in range(level_size):\n            current = queue.pop(0)\n\n            if i == level_size - 1:\n                result.append(current.val)\n            \n            if current.left:\n                queue.append(current.left)\n            if current.right:\n                queue.append(current.right)\n\n    return result"
  },
  {
    "id": "200",
    "slug": "number-of-islands",
    "solution": "def dfs(grid, i, j):\n    if i < 0 or i >= len(grid) or j < 0 or j >= len(grid[0]) or grid[i][j] == '0':\n        return\n\n    grid[i][j] = '0'\n    dfs(grid, i + 1, j)\n    dfs(grid, i - 1, j)\n    dfs(grid, i, j + 1)\n    dfs(grid, i, j - 1)\n\ndef numIslands(grid):\n    count = 0\n    for i in range(len(grid)):\n        for j in range(len(grid[0])):\n            if grid[i][j] == '1':\n                count += 1\n                dfs(grid, i, j)\n    return count"
  },
  {
    "id": "203",
    "slug": "remove-linked-list-elements",
    "solution": "class ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\ndef remove_elements(head, val):\n    sentinel = ListNode(0)\n    sentinel.next = head\n    prev, curr = sentinel, head\n\n    while curr:\n        if curr.val == val:\n            prev.next = curr.next\n        else:\n            prev = curr\n        curr = curr.next\n\n    return sentinel.next"
  },
  {
    "id": "206",
    "slug": "reverse-linked-list",
    "solution": "class ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\ndef reverse_list(head):\n    prev = None\n    current = head\n    while current is not None:\n        next = current.next\n        current.next = prev\n        prev = current\n        current = next\n    return prev"
  },
  {
    "id": "207",
    "slug": "course-schedule",
    "solution": "from collections import defaultdict, deque\n\ndef canFinish(numCourses, prerequisites):\n    adj = defaultdict(list)\n    inDegree = [0] * numCourses\n    \n    for a, b in prerequisites:\n        adj[b].append(a)\n        inDegree[a] += 1\n    \n    q = deque([i for i in range(numCourses) if inDegree[i]==0])\n    \n    while q:\n        currCourse = q.popleft()\n        numCourses -= 1\n        \n        for nextCourse in adj[currCourse]:\n            inDegree[nextCourse] -= 1\n            if inDegree[nextCourse] == 0:\n                q.append(nextCourse)\n    \n    return numCourses == 0"
  },
  {
    "id": "208",
    "slug": "implement-trie-prefix-tree",
    "solution": "class TrieNode:\n    def __init__(self):\n        self.children = {}\n        self.is_end_of_word = False\n\nclass Trie:\n    def __init__(self):\n        self.root = TrieNode()\n\n    def insert(self, word: str) -> None:\n        node = self.root\n        for c in word:\n            if c not in node.children:\n                node.children[c] = TrieNode()\n            node = node.children[c]\n        node.is_end_of_word = True\n\n    def search(self, word: str) -> bool:\n        node = self.root\n        for c in word:\n            if c not in node.children:\n                return False\n            node = node.children[c]\n        return node.is_end_of_word\n\n    def startsWith(self, prefix: str) -> bool:\n        node = self.root\n        for c in prefix:\n            if c not in node.children:\n                return False\n            node = node.children[c]\n        return True"
  },
  {
    "id": "209",
    "slug": "minimum-size-subarray-sum",
    "solution": "def minSubArrayLen(target: int, nums: List[int]) -> int:\n    left, cur_sum, min_len = 0, 0, float('inf')\n    for right in range(len(nums)):\n        cur_sum += nums[right]\n        while cur_sum >= target:\n            min_len = min(min_len, right - left + 1)\n            cur_sum -= nums[left]\n            left += 1\n    return min_len if min_len != float('inf') else 0"
  },
  {
    "id": "210",
    "slug": "course-schedule-ii",
    "solution": "from collections import deque\n\ndef findOrder(numCourses, prerequisites):\n    in_degree = [0] * numCourses\n    adj_list = [[] for _ in range(numCourses)]\n    \n    for p in prerequisites:\n        adj_list[p[1]].append(p[0])\n        in_degree[p[0]] += 1\n    \n    q = deque([i for i in range(numCourses) if in_degree[i] == 0])\n    order = []\n    \n    while q:\n        curr = q.popleft()\n        order.append(curr)\n        for next in adj_list[curr]:\n            in_degree[next] -= 1\n            if in_degree[next] == 0:\n                q.append(next)\n    \n    return order if len(order) == numCourses else []"
  },
  {
    "id": "212",
    "slug": "word-search-ii",
    "solution": "def findWords(board, words):\n    def dfs(board, word, index, i, j, visited):\n        if index == len(word):\n            return True\n        if i < 0 or j < 0 or i >= len(board) or j >= len(board[0]) or visited[i][j] or board[i][j] != word[index]:\n            return False\n        visited[i][j] = True\n        found = dfs(board, word, index + 1, i - 1, j, visited) or \\\n                dfs(board, word, index + 1, i + 1, j, visited) or \\\n                dfs(board, word, index + 1, i, j - 1, visited) or \\\n                dfs(board, word, index + 1, i, j + 1, visited)\n        visited[i][j] = False\n        return found\n\n    res = []\n    for word in words:\n        if any(dfs(board, word, 0, i, j, [[False] * len(board[0]) for _ in range(len(board))])\n               for i in range(len(board)) for j in range(len(board[0]))):\n            res.append(word)\n    return res"
  },
  {
    "id": "213",
    "slug": "house-robber-ii",
    "solution": "def rob(nums):\n    if len(nums) == 1:\n        return nums[0]\n    prev, curr = 0, 0\n    for i in range(len(nums) - 1):\n        temp = max(curr, prev + nums[i])\n        prev, curr = curr, temp\n    res = curr\n    prev, curr = 0, 0\n    for i in range(1, len(nums)):\n        temp = max(curr, prev + nums[i])\n        prev, curr = curr, temp\n    return max(res, curr)"
  },
  {
    "id": "215",
    "slug": "kth-largest-element-in-an-array",
    "solution": "def findKthLargest(nums: List[int], k: int) -> int:\n    nums.sort(reverse=True)\n    return nums[k-1]"
  },
  {
    "id": "216",
    "slug": "combination-sum-iii",
    "solution": "def combinationSum3(k, n):\n    def helper(k, n, current, current_comb, result):\n        if k == 0 and n == 0:\n            result.append(list(current_comb))\n        elif k > 0 and n > 0:\n            for i in range(current + 1, 10):\n                current_comb.append(i)\n                helper(k - 1, n - i, i, current_comb, result)\n                current_comb.pop()\n\n    result = []\n    helper(k, n, 0, [], result)\n    return result"
  },
  {
    "id": "217",
    "slug": "contains-duplicate",
    "solution": "def containsDuplicate(nums):\n    return len(nums) != len(set(nums))"
  },
  {
    "id": "226",
    "slug": "invert-binary-tree",
    "solution": "class TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef invert_tree(root):\n    if root is None:\n        return None\n    root.left, root.right = invert_tree(root.right), invert_tree(root.left)\n    return root"
  },
  {
    "id": "230",
    "slug": "kth-smallest-element-in-a-bst",
    "solution": "class TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef kthSmallest(root, k):\n    stk = []\n    curr = root\n    \n    while True:\n        while curr:\n            stk.append(curr)\n            curr = curr.left\n        \n        curr = stk.pop()\n        \n        k -= 1\n        if k == 0:\n            return curr.val\n        \n        curr = curr.right"
  },
  {
    "id": "234",
    "slug": "palindrome-linked-list",
    "solution": "class ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\ndef isPalindrome(head):\n    if not head or not head.next:\n        return True\n\n    fast, slow, prev = head, head, None\n    while fast and fast.next:\n        fast = fast.next.next\n        temp = slow.next\n        slow.next = prev\n        prev = slow\n        slow = temp\n\n    if fast:\n        slow = slow.next\n\n    while prev and prev.val == slow.val:\n        prev = prev.next\n        slow = slow.next\n\n    return prev == None"
  },
  {
    "id": "235",
    "slug": "lowest-common-ancestor-of-a-binary-search-tree",
    "solution": "class TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef lowest_common_ancestor(root, p, q):\n    if root is None or root == p or root == q:\n        return root\n\n    left = lowest_common_ancestor(root.left, p, q)\n    right = lowest_common_ancestor(root.right, p, q)\n\n    if left is not None and right is not None:\n        return root\n    else:\n        return left if left is not None else right"
  },
  {
    "id": "236",
    "slug": "lowest-common-ancestor-of-a-binary-tree",
    "solution": "class TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef lowestCommonAncestor(root, p, q):\n    if not root or root == p or root == q:\n        return root\n    left = lowestCommonAncestor(root.left, p, q)\n    right = lowestCommonAncestor(root.right, p, q)\n    return right if left is None else (left if right is None else root)"
  },
  {
    "id": "238",
    "slug": "product-of-array-except-self",
    "solution": "def productExceptSelf(nums):\n    n = len(nums)\n    answer = [1] * n\n    \n    left = 1\n    for i in range(n):\n        answer[i] *= left\n        left *= nums[i]\n    \n    right = 1\n    for i in range(n - 1, -1, -1):\n        answer[i] *= right\n        right *= nums[i]\n    \n    return answer"
  },
  {
    "id": "239",
    "slug": "sliding-window-maximum",
    "solution": "from collections import deque\n\ndef maxSlidingWindow(nums, k):\n    dq = deque()\n    result = []\n\n    for i in range(len(nums)):\n        while dq and dq[0] < i - k + 1:\n            dq.popleft()\n\n        while dq and nums[dq[-1]] < nums[i]:\n            dq.pop()\n\n        dq.append(i)\n\n        if i >= k - 1:\n            result.append(nums[dq[0]])\n\n    return result"
  },
  {
    "id": "240",
    "slug": "search-a-2d-matrix-ii",
    "solution": "def searchMatrix(matrix, target):\n    row, col = len(matrix) - 1, 0\n    while row >= 0 and col < len(matrix[0]):\n        if matrix[row][col] > target:\n            row -= 1\n        elif matrix[row][col] < target:\n            col += 1\n        else:\n            return True\n    return False"
  },
  {
    "id": "252",
    "slug": "meeting-rooms",
    "solution": "def can_attend_meetings(intervals):\n    intervals.sort()\n\n    for i in range(1, len(intervals)):\n        if intervals[i][0] < intervals[i - 1][1]:\n            return False\n\n    return True"
  },
  {
    "id": "253",
    "slug": "meeting-rooms-ii",
    "solution": "import heapq\n\ndef minMeetingRooms(intervals):\n    if not intervals:\n        return 0\n\n    intervals.sort(key=lambda x: x[0])\n\n    min_heap = [intervals[0][1]]\n    for start, end in intervals[1:]:\n        if start >= min_heap[0]:\n            heapq.heappop(min_heap)\n        heapq.heappush(min_heap, end)\n\n    return len(min_heap)"
  },
  {
    "id": "254",
    "slug": "factor-combinations",
    "solution": "def getFactors(n):\n    def helper(n, start, path, result):\n        if n == 1:\n            if len(path) > 1:\n                result.append(path[:])\n            return\n\n        for i in range(start, n + 1):\n            if n % i == 0:\n                path.append(i)\n                helper(n // i, i, path, result)\n                path.pop()\n\n    result = []\n    helper(n, 2, [], result)\n    return result"
  },
  {
    "id": "257",
    "slug": "binary-tree-paths",
    "solution": "class TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef binary_tree_paths(root: TreeNode):\n    if not root:\n        return []\n    if not root.left and not root.right:\n        return [str(root.val)]\n    paths = []\n    for path in binary_tree_paths(root.left):\n        paths.append(str(root.val) + \"->\" + path)\n    for path in binary_tree_paths(root.right):\n        paths.append(str(root.val) + \"->\" + path)\n    return paths"
  },
  {
    "id": "261",
    "slug": "graph-valid-tree",
    "solution": "from typing import List\n\ndef isTree(n: int, edges: List[List[int]]) -> bool:\n    neighbors = [[] for _ in range(n)]\n    for edge in edges:\n        neighbors[edge[0]].append(edge[1])\n        neighbors[edge[1]].append(edge[0])\n    visited = [False] * n\n    if hasCycle(neighbors, visited, -1, 0): return False\n    return all(visited)\n\ndef hasCycle(neighbors: List[List[int]], visited: List[bool], parent: int, node: int) -> bool:\n    visited[node] = True\n    for neighbor in neighbors[node]:\n        if (neighbor != parent and visited[neighbor]) or (not visited[neighbor] and hasCycle(neighbors, visited, node, neighbor)): return True\n    return False"
  },
  {
    "id": "268",
    "slug": "missing-number",
    "solution": "def missingNumber(nums):\n    n = len(nums)\n    expected_sum = (n * (n + 1)) // 2\n    actual_sum = sum(nums)\n    return expected_sum - actual_sum"
  },
  {
    "id": "269",
    "slug": "alien-dictionary",
    "solution": "from collections import deque, defaultdict, Counter\n\ndef alienOrder(words):\n    graph = defaultdict(set)\n    in_degree = Counter({c: 0 for word in words for c in word})\n    \n    for word1, word2 in zip(words, words[1:]):\n        found = False\n        for c1, c2 in zip(word1, word2):\n            if c1 != c2:\n                if c2 not in graph[c1]:\n                    graph[c1].add(c2)\n                    in_degree[c2] += 1\n                found = True\n                break\n        if not found and len(word1) > len(word2):\n            return \"\"\n    \n    q = deque([c for c in in_degree if in_degree[c] == 0])\n    result = []\n    while q:\n        c = q.popleft()\n        result.append(c)\n        \n        for neigh in graph[c]:\n            in_degree[neigh] -= 1\n            if in_degree[neigh] == 0:\n                q.append(neigh)\n                 \n    if len(result) < len(in_degree):\n        return \"\"\n    \n    return \"\".join(result)"
  },
  {
    "id": "283",
    "slug": "move-zeroes",
    "solution": "def moveZeroes(nums):\n    index = 0\n    for i in range(len(nums)):\n        if nums[i] != 0:\n            nums[index] = nums[i]\n            index += 1\n    for i in range(index, len(nums)):\n        nums[i] = 0"
  },
  {
    "id": "287",
    "slug": "find-the-duplicate-number",
    "solution": "def findDuplicate(nums):\n    slow = nums[0]\n    fast = nums[0]\n\n    while True:\n        slow = nums[slow]\n        fast = nums[nums[fast]]\n        if slow == fast:\n            break\n\n    slow = nums[0]\n\n    while slow != fast:\n        slow = nums[slow]\n        fast = nums[fast]\n\n    return slow"
  },
  {
    "id": "295",
    "slug": "find-median-from-data-stream",
    "solution": "import heapq\n\nclass MedianFinder:\n    def __init__(self):\n        self.left = []  # max heap\n        self.right = []  # min heap\n\n    def addNum(self, num: int) -> None:\n        if not self.left or num <= -self.left[0]:\n            heapq.heappush(self.left, -num)\n        else:\n            heapq.heappush(self.right, num)\n        \n        if len(self.left) < len(self.right):\n            heapq.heappush(self.left, -heapq.heappop(self.right))\n        elif len(self.left) > len(self.right) + 1:\n            heapq.heappush(self.right, -heapq.heappop(self.left))\n\n    def findMedian(self) -> float:\n        if len(self.left) == len(self.right):\n            return (-self.left[0] + self.right[0]) / 2\n        else:\n            return -self.left[0]"
  },
  {
    "id": "297",
    "slug": "serialize-and-deserialize-binary-tree",
    "solution": "class TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\ndef serialize(root):\n    if not root: return \"null,\"\n    return str(root.val) + \",\" + serialize(root.left) + serialize(root.right)\n\ndef deserialize(data):\n    def deserialize_helper(values):\n        val = values.pop(0)\n        if val == 'null': return None\n        root = TreeNode(int(val))\n        root.left = deserialize_helper(values)\n        root.right = deserialize_helper(values)\n        return root\n\n    values = data.split(\",\")\n    return deserialize_helper(values[:-1])  # Excluding the last empty element"
  },
  {
    "id": "300",
    "slug": "longest-increasing-subsequence",
    "solution": "def lengthOfLIS(nums):\n    dp = [1] * len(nums)\n    max_length = 1\n    for i in range(1, len(nums)):\n        for j in range(i):\n            if nums[i] > nums[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n        max_length = max(max_length, dp[i])\n    return max_length"
  },
  {
    "id": "303",
    "slug": "range-sum-query-immutable",
    "solution": "class NumArray:\n\n    def __init__(self, nums: List[int]):\n        self.pSum = [0] * (len(nums) + 1)\n        for i, num in enumerate(nums):\n            self.pSum[i + 1] = self.pSum[i] + num\n\n    def sumRange(self, left: int, right: int) -> int:\n        return self.pSum[right + 1] - self.pSum[left]"
  },
  {
    "id": "309",
    "slug": "best-time-to-buy-and-sell-stock-with-cooldown",
    "solution": "def maxProfit(prices):\n    profit = 0\n    for i in range(1, len(prices)):\n        profit += max(prices[i] - prices[i - 1], 0)\n    return profit"
  },
  {
    "id": "310",
    "slug": "minimum-height-trees",
    "solution": "from collections import deque\nfrom typing import List\n\ndef find_min_height_trees(n: int, edges: List[List[int]]) -> List[int]:\n    if n == 1:\n        return [0]\n\n    adj_list = [set() for _ in range(n)]\n    for a, b in edges:\n        adj_list[a].add(b)\n        adj_list[b].add(a)\n\n    leaves = deque(i for i in range(n) if len(adj_list[i]) == 1)\n\n    while n > 2:\n        leaves_size = len(leaves)\n        n -= leaves_size\n        for _ in range(leaves_size):\n            leaf = leaves.popleft()\n            for neighbor in adj_list[leaf]:\n                adj_list[neighbor].remove(leaf)\n                if len(adj_list[neighbor]) == 1:\n                    leaves.append(neighbor)\n\n    return list(leaves)"
  },
  {
    "id": "320",
    "slug": "generalized-abbreviation",
    "solution": "def generateAbbreviations(word):\n    if not word:\n        return [\"\"]\n    res = []\n    for i in range(len(word) + 1):\n        for item in generateAbbreviations(word[i+1:]):\n            if i == 0 or not item or not item[0].isdigit():\n                res.append(word[:i+1] + item)\n            if item and item[0].isdigit():\n                res.append(word[:i] + '1' + item)\n    return res"
  },
  {
    "id": "322",
    "slug": "coin-change",
    "solution": "def coinChange(coins, amount):\n    dp = [amount + 1] * (amount + 1)\n    dp[0] = 0\n\n    for coin in coins:\n        for i in range(coin, amount + 1):\n            dp[i] = min(dp[i], dp[i - coin] + 1)\n\n    return dp[amount] if dp[amount] <= amount else -1"
  },
  {
    "id": "323",
    "slug": "number-of-connected-components-in-an-undirected-graph",
    "solution": "def countComponents(n, edges):\n    adj_list = [[] for _ in range(n)]\n    for edge in edges:\n        adj_list[edge[0]].append(edge[1])\n        adj_list[edge[1]].append(edge[0])\n\n    visited = [False] * n\n    connected_components = 0\n\n    def dfs(node):\n        visited[node] = True\n        for neighbor in adj_list[node]:\n            if not visited[neighbor]:\n                dfs(neighbor)\n\n    for i in range(n):\n        if not visited[i]:\n            dfs(i)\n            connected_components += 1\n\n    return connected_components"
  },
  {
    "id": "327",
    "slug": "count-of-range-sum",
    "solution": "def countRangeSum(nums, lower, upper):\n    sums = [0] * (len(nums) + 1)\n    for i in range(len(nums)):\n        sums[i + 1] = sums[i] + nums[i]\n\n    def mergeSort(start, end):\n        if start == end:\n            return 0\n        mid = start + (end - start) // 2\n        count = mergeSort(start, mid) + mergeSort(mid + 1, end)\n\n        j, k = mid + 1, mid + 1\n        for i in range(start, mid + 1):\n            while j <= end and sums[j] - sums[i] < lower: j += 1\n            while k <= end and sums[k] - sums[i] <= upper: k += 1\n            count += k - j\n\n        sums[start:end + 1] = sorted(sums[start:end + 1])\n        return count\n\n    return mergeSort(0, len(nums))"
  },
  {
    "id": "328",
    "slug": "odd-even-linked-list",
    "solution": "class ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\ndef odd_even_list(head: ListNode) -> ListNode:\n    if not head:\n        return None\n    odd, even, even_head = head, head.next, head.next\n    while even and even.next:\n        odd.next = even.next\n        odd = odd.next\n        even.next = odd.next\n        even = even.next\n    odd.next = even_head\n    return head"
  },
  {
    "id": "336",
    "slug": "palindrome-pairs",
    "solution": "def palindrome_pairs(words):\n    def is_palindrome(s):\n        return s == s[::-1]\n\n    result = []\n    for i in range(len(words)):\n        for j in range(len(words)):\n            if i == j:\n                continue\n            concat = words[i] + words[j]\n            if is_palindrome(concat):\n                result.append([i, j])\n    return result"
  },
  {
    "id": "338",
    "slug": "counting-bits",
    "solution": "def countBits(n):\n    ans = [0] * (n + 1)\n    for i in range(1, n + 1):\n        ans[i] = ans[i & (i - 1)] + 1\n    return ans"
  },
  {
    "id": "347",
    "slug": "top-k-frequent-elements",
    "solution": "from heapq import heappush, heappop\nfrom collections import Counter\n\ndef k_most_frequent(nums, k):\n    frequency = Counter(nums)\n    min_heap = []\n\n    for num, freq in frequency.items():\n        heappush(min_heap, (freq, num))\n        if len(min_heap) > k:\n            heappop(min_heap)\n\n    return [heappop(min_heap)[1] for _ in range(k)]"
  },
  {
    "id": "358",
    "slug": "rearrange-string-k-distance-apart",
    "solution": "import heapq\nfrom collections import Counter\n\ndef rearrange_string(s, k):\n    if k == 0:\n        return s\n\n    counter = Counter(s)\n    max_heap = [(-count, char) for char, count in counter.items()]\n    heapq.heapify(max_heap)\n\n    result = []\n    while max_heap:\n        temp = []\n\n        for _ in range(k):\n            if not max_heap:\n                break\n\n            count, char = heapq.heappop(max_heap)\n            result.append(char)\n\n            if count + 1 < 0:\n                temp.append((count + 1, char))\n\n        for item in temp:\n            heapq.heappush(max_heap, item)\n\n        if not max_heap:\n            break\n\n        if len(result) < len(s):\n            result.extend([' '] * (k - len(temp)))\n\n    if len(result) < len(s):\n        return \"\"\n    return \"\".join(result)"
  },
  {
    "id": "373",
    "slug": "find-k-pairs-with-smallest-sums",
    "solution": "import heapq\n\ndef kSmallestPairs(nums1, nums2, k):\n    if not nums1 or not nums2:\n        return []\n    \n    heap = [(nums1[i] + nums2[0], i, 0) for i in range(min(k, len(nums1)))]\n    heapq.heapify(heap)\n    result = []\n\n    while k > 0 and heap:\n        s, i, j = heapq.heappop(heap)\n        result.append([nums1[i], nums2[j]])\n        if j + 1 < len(nums2):\n            heapq.heappush(heap, (nums1[i] + nums2[j + 1], i, j + 1))\n        k -= 1\n\n    return result"
  },
  {
    "id": "377",
    "slug": "combination-sum-iv",
    "solution": "def combination_sum(nums, target):\n    dp = [0] * (target + 1)\n    dp[0] = 1\n\n    for num in nums:\n        for i in range(num, target + 1):\n            dp[i] += dp[i - num]\n\n    return dp[target]"
  },
  {
    "id": "378",
    "slug": "kth-smallest-element-in-a-sorted-matrix",
    "solution": "import heapq\n\ndef kthSmallest(matrix, k):\n    n = len(matrix)\n    min_heap = []\n\n    for i in range(n):\n        heapq.heappush(min_heap, (matrix[i][0], i, 0))\n\n    while k > 1:\n        val, row, col = heapq.heappop(min_heap)\n\n        if col + 1 < n:\n            heapq.heappush(min_heap, (matrix[row][col + 1], row, col + 1))\n\n        k -= 1\n\n    return min_heap[0][0]"
  },
  {
    "id": "392",
    "slug": "is-subsequence",
    "solution": "def is_subsequence(s, t):\n    si, ti = 0, 0\n\n    while si < len(s) and ti < len(t):\n        if s[si] == t[ti]:\n            si += 1\n        ti += 1\n\n    return si == len(s)"
  },
  {
    "id": "416",
    "slug": "partition-equal-subset-sum",
    "solution": "def canPartition(nums):\n    total_sum = sum(nums)\n    if total_sum % 2 != 0:\n        return False\n    \n    target = total_sum // 2\n    dp = [False] * (target + 1)\n    dp[0] = True\n    \n    for num in nums:\n        for i in range(target, num - 1, -1):\n            dp[i] = dp[i] or dp[i - num]\n    \n    return dp[target]"
  },
  {
    "id": "417",
    "slug": "pacific-atlantic-water-flow",
    "solution": "def pacificAtlantic(heights):\n    def dfs(r, c, prev_height, visited):\n        if not (0 <= r < len(heights)) or not (0 <= c < len(heights[0])):\n            return\n        if heights[r][c] >= prev_height and not visited[r][c]:\n            visited[r][c] = True\n            dfs(r - 1, c, heights[r][c], visited)\n            dfs(r + 1, c, heights[r][c], visited)\n            dfs(r, c - 1, heights[r][c], visited)\n            dfs(r, c + 1, heights[r][c], visited)\n\n    m, n = len(heights), len(heights[0])\n    pacific = [[False] * n for _ in range(m)]\n    atlantic = [[False] * n for _ in range(m)]\n\n    for r in range(m):\n        dfs(r, 0, -1, pacific)\n        dfs(r, n - 1, -1, atlantic)\n    for c in range(n):\n        dfs(0, c, -1, pacific)\n        dfs(m - 1, c, -1, atlantic)\n\n    result = []\n    for r in range(m):\n        for c in range(n):\n            if pacific[r][c] and atlantic[r][c]:\n                result.append([r, c])\n    return result"
  },
  {
    "id": "421",
    "slug": "maximum-xor-of-two-numbers-in-an-array",
    "solution": "def findMaximumXOR(nums):\n    max_xor = 0\n    mask = 0\n\n    for i in range(31, -1, -1):\n        mask |= (1 << i)\n        prefixes = {num & mask for num in nums}\n\n        possible_max = max_xor | (1 << i)\n\n        for prefix in prefixes:\n            if prefix ^ possible_max in prefixes:\n                max_xor = possible_max\n                break\n\n    return max_xor"
  },
  {
    "id": "424",
    "slug": "longest-repeating-character-replacement",
    "solution": "def characterReplacement(s:str, k:int) -> int:\n    n = len(s)\n    left = 0\n    right = 0\n    maxFreq = 0\n    result = 0\n    freq = [0] * 26\n\n    for right in range(n):\n        freq[ord(s[right]) - ord('A')] += 1\n        maxFreq = max(maxFreq, freq[ord(s[right]) - ord('A')])\n\n        if right - left + 1 - maxFreq > k:\n            freq[ord(s[left]) - ord('A')] -= 1\n            left += 1\n\n        result = max(result, right - left + 1)\n\n    return result"
  },
  {
    "id": "425",
    "slug": "word-squares",
    "solution": "from collections import defaultdict\n\ndef wordSquares(words):\n    def build(row, squares, word_lens):\n        if row == word_lens:\n            res.append(list(squares))\n            return\n        prefix = ''.join(squares[i][row] for i in range(row))\n        for w in prefixes[prefix]:\n            squares[row] = w\n            build(row+1, squares, word_lens)\n\n    if not words: return []\n    res = []\n    word_lens = len(words[0])\n    \n    prefixes = defaultdict(list)\n    for word in words:\n        for i in range(word_lens+1):\n            prefixes[word[:i]].append(word)\n            \n    for word in words:\n        build(1, [word] + [None]*(word_lens-1), word_lens)\n        \n    return res"
  },
  {
    "id": "435",
    "slug": "non-overlapping-intervals",
    "solution": "def eraseOverlapIntervals(intervals):\n    if not intervals:\n        return 0\n    \n    intervals.sort(key=lambda x: x[1])\n    \n    count = 0\n    prev_end = intervals[0][1]\n    \n    for i in range(1, len(intervals)):\n        if intervals[i][0] < prev_end:\n            count += 1\n        else:\n            prev_end = intervals[i][1]\n    \n    return count"
  },
  {
    "id": "437",
    "slug": "path-sum-iii",
    "solution": "def path_sum_helper(node, target_sum, current_sum):\n    if node is None:\n        return 0\n\n    current_sum += node.val\n    total_paths = 1 if current_sum == target_sum else 0\n    total_paths += path_sum_helper(node.left, target_sum, current_sum)\n    total_paths += path_sum_helper(node.right, target_sum, current_sum)\n    return total_paths\n\ndef path_sum(root, target_sum):\n    if root is None:\n        return 0\n\n    return path_sum_helper(root, target_sum, 0) + path_sum(root.left, target_sum) + path_sum(root.right, target_sum)"
  },
  {
    "id": "442",
    "slug": "find-all-duplicates-in-an-array",
    "solution": "def find_duplicates(nums):\n    duplicates = []\n    for i in range(len(nums)):\n        index = abs(nums[i]) - 1\n        if nums[index] < 0:\n            duplicates.append(abs(nums[i]))\n        else:\n            nums[index] *= -1\n    return duplicates"
  },
  {
    "id": "444",
    "slug": "sequence-reconstruction",
    "solution": "def is_shortest_and_unique_supersequence(nums, sequences):\n    pos = {val: idx for idx, val in enumerate(nums)}\n\n    for seq in sequences:\n        if pos[seq[0]] > pos[seq[-1]]:\n            return False\n    return True"
  },
  {
    "id": "448",
    "slug": "find-all-numbers-disappeared-in-an-array",
    "solution": "def find_disappeared_numbers(nums):\n    result = []\n    \n    for num in nums:\n        index = abs(num) - 1\n        nums[index] = -abs(nums[index])\n\n    for i, num in enumerate(nums):\n        if num > 0:\n            result.append(i + 1)\n\n    return result"
  },
  {
    "id": "451",
    "slug": "sort-characters-by-frequency",
    "solution": "from collections import Counter\n\ndef sort_by_frequency(s):\n    freq = Counter(s)\n    chars = list(s)\n    chars.sort(key=lambda c: freq[c], reverse=True)\n    return ''.join(chars)"
  },
  {
    "id": "452",
    "slug": "minimum-number-of-arrows-to-burst-balloons",
    "solution": "def findMinArrowShots(points):\n    if not points:\n        return 0\n    points.sort(key=lambda x: x[1])\n\n    arrows = 1\n    end = points[0][1]\n\n    for i in range(1, len(points)):\n        if points[i][0] > end:\n            arrows += 1\n            end = points[i][1]\n\n    return arrows"
  },
  {
    "id": "472",
    "slug": "concatenated-words",
    "solution": "def is_concatenated(word, word_dict):\n    n = len(word)\n    dp = [False] * (n + 1)\n    dp[0] = True\n\n    for i in range(1, n + 1):\n        for j in range(i):\n            if dp[j] and word[j:i] in word_dict:\n                dp[i] = True\n                break\n\n    return dp[n]\n\n\ndef find_all_concatenated_words(words):\n    word_dict = set(words)\n    result = []\n\n    for word in words:\n        if is_concatenated(word, word_dict):\n            result.append(word)\n\n    return result"
  },
  {
    "id": "480",
    "slug": "sliding-window-median",
    "solution": "from sortedcontainers import SortedList\n\ndef medianSlidingWindow(nums, k):\n    window = SortedList(nums[:k])\n    medians = []\n    \n    for i in range(k, len(nums) + 1):\n        medians.append((window[k // 2 - 1] + window[k // 2]) / 2 if k % 2 == 0 else float(window[k // 2]))\n        \n        if i < len(nums):\n            window.remove(nums[i - k])\n            window.add(nums[i])\n\n    return medians"
  },
  {
    "id": "494",
    "slug": "target-sum",
    "solution": "def findTargetSumWays(nums, target):\n    total_sum = sum(nums)\n    if total_sum < target or (total_sum + target) % 2 != 0:\n        return 0\n    target_sum = (total_sum + target) // 2\n    dp = [0] * (target_sum + 1)\n    dp[0] = 1\n    for num in nums:\n        for j in range(target_sum, num - 1, -1):\n            dp[j] += dp[j - num]\n    return dp[target_sum]"
  },
  {
    "id": "543",
    "slug": "diameter-of-binary-tree",
    "solution": "class TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef diameter_of_binary_tree(root):\n    def _diameter_of_binary_tree(node):\n        if not node:\n            return 0, 0\n        left_height, left_diameter = _diameter_of_binary_tree(node.left)\n        right_height, right_diameter = _diameter_of_binary_tree(node.right)\n        height = 1 + max(left_height, right_height)\n        diameter = max(left_height + right_height, max(left_diameter, right_diameter))\n        return height, diameter\n\n    return _diameter_of_binary_tree(root)[1]"
  },
  {
    "id": "567",
    "slug": "permutation-in-string",
    "solution": "def checkInclusion(s1: str, s2: str) -> bool:\n    if len(s1) > len(s2): \n        return False\n    \n    s1_map = [0] * 26\n    s2_map = [0] * 26\n    \n    for i in range(len(s1)):\n        s1_map[ord(s1[i]) - ord('a')] += 1\n        s2_map[ord(s2[i]) - ord('a')] += 1\n    \n    for i in range(len(s2) - len(s1)):\n        if s1_map == s2_map: \n            return True\n        \n        s2_map[ord(s2[i]) - ord('a')] -= 1\n        s2_map[ord(s2[i + len(s1)]) - ord('a')] += 1\n\n    return s1_map == s2_map"
  },
  {
    "id": "572",
    "slug": "subtree-of-another-tree",
    "solution": "javascript\r\nclass TreeNode {\r\n    constructor(val, left = null, right = null) {\r\n        this.val = val;\r\n        this.left = left;\r\n        this.right = right;\r\n    }\r\n}\r\n\r\nfunction isSubtree(root, subRoot) {\r\n    if (root === null) return false;\r\n    if (isIdentical(root, subRoot)) return true;\r\n    return isSubtree(root.left, subRoot) || isSubtree(root.right, subRoot);\r\n}\r\n\r\nfunction isIdentical(n1, n2) {\r\n    if (n1 === null || n2 === null) return n1 === n2;\r\n    if (n1.val !== n2.val) return false;\r\n    return isIdentical(n1.left, n2.left) && isIdentical(n1.right, n2.right);\r\n}"
  },
  {
    "id": "617",
    "slug": "merge-two-binary-trees",
    "solution": "class TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef merge_trees(root1: TreeNode, root2: TreeNode) -> TreeNode:\n    if root1 is None: return root2\n    if root2 is None: return root1\n\n    root1.val += root2.val\n    root1.left = merge_trees(root1.left, root2.left)\n    root1.right = merge_trees(root1.right, root2.right)\n    return root1"
  },
  {
    "id": "621",
    "slug": "task-scheduler",
    "solution": "from collections import Counter\n\ndef least_interval(tasks, n):\n    task_freq = Counter(tasks)\n\n    max_f = max(task_freq.values())\n    max_count = sum(1 for count in task_freq.values() if count == max_f)\n\n    return max(len(tasks), (max_f - 1) * (n + 1) + max_count)"
  },
  {
    "id": "630",
    "slug": "course-schedule-iii",
    "solution": "import heapq\n\ndef scheduleCourse(courses):\n    courses.sort(key=lambda x: x[1])\n    curr_time, duration_sum = 0, []\n\n    for duration, deadline in courses:\n        curr_time += duration\n        heapq.heappush(duration_sum, -duration)\n\n        if curr_time > deadline:\n            curr_time += heapq.heappop(duration_sum)\n\n    return len(duration_sum)"
  },
  {
    "id": "632",
    "slug": "smallest-range-covering-elements-from-k-lists",
    "solution": "import heapq\n\ndef smallestRange(nums):\n    minHeap = []\n    maxVal = -1e9\n    \n    for i, lst in enumerate(nums):\n        heapq.heappush(minHeap, (lst[0], i))\n        maxVal = max(maxVal, lst[0])\n        \n    listIndices = [0] * len(nums)\n    minRange = 1e9\n    start, end = -1, -1\n    \n    while len(minHeap) == len(nums):\n        val, listIdx = heapq.heappop(minHeap)\n        range_ = maxVal - val\n        \n        if range_ < minRange:\n            minRange = range_\n            start, end = val, maxVal\n            \n        listIndices[listIdx] += 1\n        if listIndices[listIdx] < len(nums[listIdx]):\n            newVal = nums[listIdx][listIndices[listIdx]]\n            heapq.heappush(minHeap, (newVal, listIdx))\n            maxVal = max(maxVal, newVal)\n            \n    return [start, end]"
  },
  {
    "id": "637",
    "slug": "average-of-levels-in-binary-tree",
    "solution": "class TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef averageOfLevels(root: TreeNode):\n    result = []\n    queue = [root]\n\n    while queue:\n        sum_ = 0\n        count = 0\n        temp = []\n        while queue:\n            node = queue.pop(0)\n            sum_ += node.val\n            count += 1\n            if node.left: temp.append(node.left)\n            if node.right: temp.append(node.right)\n        queue = temp\n        result.append(sum_ / count)\n\n    return result"
  },
  {
    "id": "642",
    "slug": "design-search-autocomplete-system",
    "solution": "from typing import List\nimport heapq\n\nclass TrieNode:\n    def __init__(self):\n        self.children = {}\n        self.sentence = \"\"\n        self.times = 0\n\nclass AutocompleteSystem:\n\n    def __init__(self, sentences: List[str], times: List[int]):\n        self.root = TrieNode()\n        self.current = self.root\n        self.search = \"\"\n        \n        for i in range(len(sentences)):\n            self.insert(sentences[i], times[i])\n\n    def insert(self, sentence: str, times: int):\n        curr = self.root\n        for c in sentence:\n            if c not in curr.children:\n                curr.children[c] = TrieNode()\n            curr = curr.children[c]\n        curr.sentence = sentence\n        curr.times += times\n\n    def input(self, c: str) -> List[str]:\n        if c == '#':\n            self.insert(self.search, 1)\n            self.search = \"\"\n            self.current = self.root\n            return []\n        \n        self.search += c\n        if not self.current:\n            return []\n        \n        if c not in self.current.children:\n            self.current = None\n            return []\n        \n        self.current = self.current.children[c]\n        heap = []\n        for child in self.current.children.values():\n            if child.times:\n                heapq.heappush(heap, (-child.times, child.sentence))\n        \n        res = []\n        for _ in range(3):\n            if not heap:\n                break\n            res.append(heapq.heappop(heap)[1])\n        return res"
  },
  {
    "id": "643",
    "slug": "maximum-average-subarray-i",
    "solution": "def findMaxAverage(nums, k):\n    n = len(nums)\n    sum_ = sum(nums[:k])\n    max_avg = sum_ / k\n    for i in range(k, n):\n        sum_ = sum_ - nums[i - k] + nums[i]\n        max_avg = max(max_avg, sum_ / k)\n    return max_avg"
  },
  {
    "id": "647",
    "slug": "palindromic-substrings",
    "solution": "def countSubstrings(s: str) -> int:\n    n = len(s)\n    count = 0\n    for center in range(2 * n - 1):\n        left = center // 2\n        right = left + center % 2\n        while left >= 0 and right < n and s[left] == s[right]:\n            count += 1\n            left -= 1\n            right += 1\n    return count"
  },
  {
    "id": "654",
    "slug": "maximum-binary-tree",
    "solution": "class TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef constructMaximumBinaryTree(nums):\n    def helper(nums, left, right):\n        if left > right:\n            return None\n\n        maxIdx = left\n        for i in range(left + 1, right + 1):\n            if nums[i] > nums[maxIdx]:\n                maxIdx = i\n\n        root = TreeNode(nums[maxIdx])\n        root.left = helper(nums, left, maxIdx - 1)\n        root.right = helper(nums, maxIdx + 1, right)\n        return root\n\n    return helper(nums, 0, len(nums) - 1)"
  },
  {
    "id": "658",
    "slug": "find-k-closest-elements",
    "solution": "from typing import List\n\ndef findClosestElements(arr: List[int], k: int, x: int) -> List[int]:\n    left = 0\n    right = len(arr) - k\n\n    while left < right:\n        mid = left + (right - left) // 2\n        if x - arr[mid] > arr[mid + k] - x:\n            left = mid + 1\n        else:\n            right = mid\n\n    return arr[left:left + k]"
  },
  {
    "id": "662",
    "slug": "maximum-width-of-binary-tree",
    "solution": "from collections import deque\n\ndef widthOfBinaryTree(root):\n    if not root:\n        return 0\n\n    maxWidth = 0\n    q = deque([(root, 1)])\n\n    while q:\n        levelSize = len(q)\n        left, _ = q[0]\n        right = left\n        for _ in range(levelSize):\n            node, pos = q.popleft()\n            right = pos\n\n            if node.left:\n                q.append((node.left, 2 * pos))\n            if node.right:\n                q.append((node.right, 2 * pos + 1))\n        \n        maxWidth = max(maxWidth, right - left + 1)\n    \n    return maxWidth"
  },
  {
    "id": "673",
    "slug": "number-of-longest-increasing-subsequence",
    "solution": "def findNumberOfLIS(nums):\n    n = len(nums)\n    maxLength = ans = 0\n    length = [1] * n\n    count = [1] * n\n\n    for i in range(n):\n        for j in range(i):\n            if nums[i] > nums[j]:\n                if length[i] == length[j] + 1:\n                    count[i] += count[j]\n                elif length[i] < length[j] + 1:\n                    length[i] = length[j] + 1\n                    count[i] = count[j]\n        if maxLength == length[i]:\n            ans += count[i]\n        elif maxLength < length[i]:\n            maxLength = length[i]\n            ans = count[i]\n\n    return ans"
  },
  {
    "id": "698",
    "slug": "partition-to-k-equal-sum-subsets",
    "solution": "def canPartitionKSubsets(nums, k):\n    total_sum = sum(nums)\n    if total_sum % k != 0:\n        return False\n    target = total_sum // k\n    visited = [False] * len(nums)\n    return dfs(nums, visited, 0, target, 0, k)\n\ndef dfs(nums, visited, start, target, curr_sum, k):\n    if k == 1:\n        return True\n    if curr_sum == target:\n        return dfs(nums, visited, 0, target, 0, k - 1)\n    for i in range(start, len(nums)):\n        if not visited[i] and curr_sum + nums[i] <= target:\n            visited[i] = True\n            if dfs(nums, visited, i + 1, target, curr_sum + nums[i], k):\n                return True\n            visited[i] = False\n    return False"
  },
  {
    "id": "704",
    "slug": "binary-search",
    "solution": "def search(nums: List[int], target: int) -> int:\n    left, right = 0, len(nums) - 1\n    while left <= right:\n        mid = left + (right - left) // 2\n        if nums[mid] == target:\n            return mid\n        if nums[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n    return -1"
  },
  {
    "id": "713",
    "slug": "subarray-product-less-than-k",
    "solution": "def numSubarrayProductLessThanK(nums, k):\n    if k <= 1:\n        return 0\n    prod = 1\n    count = 0\n    left = 0\n    for right in range(len(nums)):\n        prod *= nums[right]\n        while prod >= k:\n            prod /= nums[left]\n            left += 1\n        count += right - left + 1\n    return count"
  },
  {
    "id": "720",
    "slug": "longest-word-in-dictionary",
    "solution": "def longest_word(words):\n    built_words = set()\n    result = ''\n\n    for word in sorted(words):\n        if len(word) == 1 or word[:-1] in built_words:\n            if len(word) > len(result):\n                result = word\n            built_words.add(word)\n\n    return result"
  },
  {
    "id": "744",
    "slug": "find-smallest-letter-greater-than-target",
    "solution": "import heapq\nfrom collections import defaultdict\n\ndef networkDelayTime(times, n, k):\n    graph = defaultdict(list)\n    for u, v, w in times:\n        graph[u].append((v, w))\n\n    dist = {i: float('inf') for i in range(1, n + 1)}\n    dist[k] = 0\n\n    pq = [(0, k)]\n\n    while pq:\n        time, node = heapq.heappop(pq)\n\n        if time > dist[node]:\n            continue\n\n        for neighbour, neighbourTime in graph[node]:\n            candidate_dist = time + neighbourTime\n            if candidate_dist < dist[neighbour]:\n                dist[neighbour] = candidate_dist\n                heapq.heappush(pq, (candidate_dist, neighbour))\n\n    maxTime = max(dist.values())\n    return maxTime if maxTime < float('inf') else -1"
  },
  {
    "id": "745",
    "slug": "prefix-and-suffix-search",
    "solution": "def next_greatest_letter(letters, target):\n    for letter in letters:\n        if letter > target:\n            return letter\n    return letters[0]"
  },
  {
    "id": "759",
    "slug": "employee-free-time",
    "solution": "def min_set_size(intervals):\n    intervals.sort()\n    n = len(intervals)\n    end = intervals[0][1]\n    count = 1\n\n    for i in range(1, n):\n        if end < intervals[i][0]:\n            end = intervals[i][1]\n            count += 1\n        else:\n            end = min(end, intervals[i][1])\n    return count * 2"
  },
  {
    "id": "767",
    "slug": "reorganize-string",
    "solution": "def is_prime(n: int) -> bool:\n    if n <= 1:\n        return False\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef count_prime_set_bits(left: int, right: int) -> int:\n    count = 0\n    for i in range(left, right + 1):\n        bits = bin(i).count('1')\n        if is_prime(bits):\n            count += 1\n    return count"
  },
  {
    "id": "784",
    "slug": "letter-case-permutation",
    "solution": "class TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\ndef insertIntoBST(root, val):\n    if root is None:\n        return TreeNode(val)\n\n    if val < root.val:\n        root.left = insertIntoBST(root.left, val)\n    else:\n        root.right = insertIntoBST(root.right, val)\n\n    return root"
  },
  {
    "id": "828",
    "slug": "count-unique-characters-of-all-substrings-of-a-given-string",
    "solution": "def xor_game(nums: List[int]) -> bool:\n    xor_sum = 0\n    for num in nums:\n        xor_sum ^= num\n    return xor_sum == 0 or len(nums) % 2 == 0"
  },
  {
    "id": "844",
    "slug": "backspace-string-compare",
    "solution": "def backspaceCompare(s: str, t: str) -> bool:\n    i, j = len(s) - 1, len(t) - 1\n    while True:\n        back = 0\n        while i >= 0 and (back > 0 or s[i] == '#'):\n            back = back + 1 if s[i] == '#' else back - 1\n            i -= 1\n        back = 0\n        while j >= 0 and (back > 0 or t[j] == '#'):\n            back = back + 1 if t[j] == '#' else back - 1\n            j -= 1\n        if i >= 0 and j >= 0 and s[i] == t[j]:\n            i, j = i -1, j - 1\n        else:\n            return i == -1 and j == -1"
  },
  {
    "id": "852",
    "slug": "peak-index-in-a-mountain-array",
    "solution": "def numFriendRequests(ages):\n    count = [0] * 121\n    total_requests = 0\n\n    for age in ages:\n        count[age] += 1\n\n    for a in range(1, 121):\n        for b in range(1, 121):\n            if a * 0.5 + 7 >= b:\n                continue\n            if a < b:\n                continue\n            if a < b * 2:\n                total_requests += count[a] * count[b]\n                if a == b:\n                    total_requests -= count[a]\n\n    return total_requests"
  },
  {
    "id": "863",
    "slug": "all-nodes-distance-k-in-binary-tree",
    "solution": "from collections import defaultdict\n\ndef sumOfDistancesInTree(n, edges):\n    tree = defaultdict(set)\n    for u, v in edges:\n        tree[u].add(v)\n        tree[v].add(u)\n\n    count = [1] * n\n    res = [0] * n\n\n    def dfs(node, parent):\n        for child in tree[node]:\n            if child != parent:\n                dfs(child, node)\n                count[node] += count[child]\n                res[node] += res[child] + count[child]\n\n    def dfs2(node, parent):\n        for child in tree[node]:\n            if child != parent:\n                res[child] = res[node] - count[child] + n - count[child]\n                dfs2(child, node)\n\n    dfs(0, -1)\n    dfs2(0, -1)\n\n    return res"
  },
  {
    "id": "876",
    "slug": "middle-of-the-linked-list",
    "solution": "from collections import Counter\n\ndef is_n_straight_hand(hand, group_size):\n    counts = Counter(hand)\n\n    for card in sorted(counts):\n        if counts[card] > 0:\n            for i in range(group_size - 1, -1, -1):\n                if counts[card + i] < counts[card]:\n                    return False\n                counts[card + i] -= counts[card]\n\n    return True"
  },
  {
    "id": "895",
    "slug": "maximum-frequency-stack",
    "solution": "from collections import deque\n\ndef shortestPathAllKeys(grid):\n    m, n, steps, k, x, y, mask = len(grid), len(grid[0]), 0, 0, -1, -1, 0\n\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == '@':\n                x, y = i, j\n            elif 'a' <= grid[i][j] <= 'f':\n                k = max(k, ord(grid[i][j]) - ord('a') + 1)\n\n    q = deque([(x, y, 0)])\n    visited = {(x, y, mask)}\n\n    dirs = [(-1, 0), (1, 0), (0, 1), (0, -1)]\n\n    while q:\n        qs = len(q)\n        for sz in range(qs):\n            x, y, mask = q.popleft()\n\n            if mask == (1 << k) - 1:\n                return steps\n\n            for dx, dy in dirs:\n                nx, ny, nmask = x + dx, y + dy, mask\n\n                if 0 <= nx < m and 0 <= ny < n:\n                    c = grid[nx][ny]\n                    if 'A' <= c <= 'F' and not nmask & (1 << (ord(c) - ord('A'))):\n                        continue\n                    if 'a' <= c <= 'f':\n                        nmask |= (1 << (ord(c) - ord('a')))\n\n                    if (nx, ny, nmask) in visited:\n                        continue\n\n                    visited.add((nx, ny, nmask))\n                    q.append((nx, ny, nmask))\n\n        steps += 1\n\n    return -1"
  },
  {
    "id": "904",
    "slug": "fruit-into-baskets",
    "solution": "def leafSimilar(root1, root2):\n    def getLeaves(node):\n        if not node:\n            return []\n        if not node.left and not node.right:\n            return [node.val]\n        return getLeaves(node.left) + getLeaves(node.right)\n\n    return getLeaves(root1) == getLeaves(root2)"
  },
  {
    "id": "973",
    "slug": "k-closest-points-to-origin",
    "solution": "def moves_to_stamp(stamp: str, target: str) -> list:\n    result = []\n    is_stamped = [False] * len(target)\n    stamp_count = 0\n    target = list(target)\n\n    while stamp_count < 10 * len(target):\n        found_stamp = False\n        for i in range(len(target) - len(stamp) + 1):\n            if is_stamped[i]:\n                continue\n            j = 0\n            overlap = 0\n            while j < len(stamp) and (target[i + j] == '?' or target[i + j] == stamp[j]):\n                if target[i + j] == stamp[j]:\n                    overlap += 1\n                j += 1\n            if j == len(stamp) and overlap > 0:\n                for j in range(len(stamp)):\n                    target[i + j] = '?'\n                result.append(i)\n                is_stamped[i] = True\n                found_stamp = True\n        if not found_stamp:\n            break\n        \n        stamp_count += 1\n\n    for c in target:\n        if c != '?':\n            return []\n\n    return result[::-1]"
  },
  {
    "id": "977",
    "slug": "squares-of-a-sorted-array",
    "solution": "def distinctSubseqII(s):\n    mod = 10**9 + 7\n    n = len(s)\n    dp = [0] * (n + 1)\n    dp[0] = 1\n    last = [-1] * 26\n\n    for i in range(1, n + 1):\n        dp[i] = (dp[i - 1] * 2) % mod\n        if last[ord(s[i - 1]) - ord('a')] != -1:\n            dp[i] = (dp[i] - dp[last[ord(s[i - 1]) - ord('a')]] + mod) % mod\n        last[ord(s[i - 1]) - ord('a')] = i - 1\n\n    dp[n] = (dp[n] - 1 + mod) % mod\n    return dp[n]"
  },
  {
    "id": "986",
    "slug": "interval-list-intersections",
    "solution": "from itertools import permutations\n\ndef largestTimeFromDigits(arr):\n    max_time = -1\n    for h, i, j, k in permutations(arr):\n        hour = h * 10 + i\n        minute = j * 10 + k\n        time = hour * 60 + minute\n        if hour < 24 and minute < 60 and time > max_time:\n            max_time = time\n\n    if max_time == -1:\n        return \"\"\n    else:\n        return \"{:02d}:{:02d}\".format(max_time // 60, max_time % 60)"
  },
  {
    "id": "995",
    "slug": "minimum-number-of-k-consecutive-bit-flips",
    "solution": "def min_k_bit_flips(nums, k):\n    n = len(nums)\n    flipped = [0] * n\n    flips = ans = 0\n    for i in range(n):\n        if i >= k:\n            flips -= flipped[i - k]\n        if (flips + nums[i]) % 2 == 0:\n            if i + k > n:\n                return -1\n            flipped[i] = 1\n            flips += 1\n            ans += 1\n    return ans"
  },
  {
    "id": "1065",
    "slug": "index-pairs-of-a-string",
    "solution": "def has_all_codes_in_range(s: str, n: int) -> bool:\n    substrings = set()\n    length = len(bin(n)) - 2\n    for i in range(len(s) - length + 1):\n        substrings.add(s[i:i + length])\n    return len(substrings) == n"
  },
  {
    "id": "1203",
    "slug": "sort-items-by-groups-respecting-dependencies",
    "solution": "from threading import Condition\n\nclass Foo:\n    def __init__(self):\n        self.order = 1\n        self.cv = Condition()\n\n    def first(self):\n        with self.cv:\n            # printFirst() outputs \"first\". Do not change or remove this line.\n            printFirst()\n            self.order = 2\n            self.cv.notify_all()\n\n    def second(self):\n        with self.cv:\n            self.cv.wait_for(lambda: self.order == 2)\n            # printSecond() outputs \"second\". Do not change or remove this line.\n            printSecond()\n            self.order = 3\n            self.cv.notify_all()\n\n    def third(self):\n        with self.cv:\n            self.cv.wait_for(lambda: self.order == 3)\n            # printThird() outputs \"third\". Do not change or remove this line.\n            printThird()"
  },
  {
    "id": "1593",
    "slug": "split-a-string-into-the-max-number-of-unique-substrings",
    "solution": "def maxUniqueSplit(s, start=0, seen=None):\n    if seen is None:\n        seen = set()\n    if start == len(s):\n        return 0\n    maxUnique = -1\n    for i in range(start + 1, len(s) + 1):\n        sub = s[start:i]\n        if sub not in seen:\n            seen.add(sub)\n            unique = maxUniqueSplit(s, i, seen)\n            if unique != -1:\n                maxUnique = max(maxUnique, unique + 1)\n            seen.remove(sub)\n    return maxUnique"
  },
  {
    "id": "2022",
    "slug": "convert-1d-array-into-2d-array",
    "solution": "def max_alternating_sum(nums):\n    even_sum = odd_sum = 0\n    for num in nums:\n        even_sum, odd_sum = max(even_sum + num, odd_sum), even_sum - num\n    return even_sum"
  }
]
